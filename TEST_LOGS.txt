========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 13 items

kornia/test_metrics.py FFFFFFFFFF...                                                                                                                                                             [100%]

=============================================================================================== FAILURES ===============================================================================================
_________________________________________________________________________________ test_accuracy[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_accuracy(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[0, 1, 0]]),
            torch.tensor([[1]]),
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[0, 0.8, 0.2], [0, 0.4, 0.6]]),
            torch.tensor([1, 2]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.metrics.accuracy,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_metrics.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function accuracy at 0x7f9a7d154310>, trace_args = (tensor([[0, 1, 0]]), tensor([[1]])), trace_kwargs = {}
test_args = (tensor([[0.0000, 0.8000, 0.2000],
        [0.0000, 0.4000, 0.6000]]), tensor([1, 2])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s'
skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function accuracy at 0x7f9a7d154310>, trace_args = (tensor([[0, 1, 0]]), tensor([[1]])), trace_kwargs = {}
test_args = (tensor([[0.0000, 0.8000, 0.2000],
        [0.0000, 0.4000, 0.6000]]), tensor([1, 2])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function accuracy at 0x7f9a7d154310>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.accuracy.accuracy
_____________________________________________________________________________ test_confusion_matrix[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_confusion_matrix(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([0, 1, 0]),
            torch.tensor([0, 1, 0]),
            3,
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([0, 1, 2]),
            torch.tensor([0, 2, 1]),
            3,
        )
        test_kwargs = {}
>       _test_function(
            kornia.metrics.confusion_matrix,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_metrics.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function confusion_matrix at 0x7f9a7d154820>, trace_args = (tensor([0, 1, 0]), tensor([0, 1, 0]), 3), trace_kwargs = {}, test_args = (tensor([0, 1, 2]), tensor([0, 2, 1]), 3), test_kwargs = {}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function confusion_matrix at 0x7f9a7d154820>, trace_args = (tensor([0, 1, 0]), tensor([0, 1, 0]), 3), trace_kwargs = {}, test_args = (tensor([0, 1, 2]), tensor([0, 2, 1]), 3), test_kwargs = {}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function confusion_matrix at 0x7f9a7d154820>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.confusion_matrix.confusion_matrix
_________________________________________________________________________________ test_mean_iou[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_mean_iou(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([0, 1, 0]),
            torch.tensor([0, 1, 0]),
            3,
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([0, 1, 2]),
            torch.tensor([0, 2, 1]),
            3,
        )
        test_kwargs = {}
>       _test_function(
            kornia.metrics.mean_iou,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_metrics.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function mean_iou at 0x7f9a7d154dc0>, trace_args = (tensor([0, 1, 0]), tensor([0, 1, 0]), 3), trace_kwargs = {}, test_args = (tensor([0, 1, 2]), tensor([0, 2, 1]), 3), test_kwargs = {}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function mean_iou at 0x7f9a7d154dc0>, trace_args = (tensor([0, 1, 0]), tensor([0, 1, 0]), 3), trace_kwargs = {}, test_args = (tensor([0, 1, 2]), tensor([0, 2, 1]), 3), test_kwargs = {}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function mean_iou at 0x7f9a7d154dc0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.mean_iou.mean_iou
__________________________________________________________________________ test_mean_average_precision[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_mean_average_precision(target_framework, mode, backend_compile):
        trace_args = (
            [torch.tensor([[100, 50, 150, 100.]])],
            [torch.tensor([1.])],
            [torch.tensor([0.7])],
            [torch.tensor([[100, 50, 150, 100.]])],
            [torch.tensor([1.])],
            2,
        )
        trace_kwargs = {}
        test_args = (
            [torch.tensor([[50, 25, 75, 50], [100, 50, 150, 100.]])],
            [torch.tensor([1, 2.])],
            [torch.tensor([0.6, 0.8])],
            [torch.tensor([[50, 25, 75, 50], [100, 50, 150, 100.]])],
            [torch.tensor([1, 2.])],
            3,
        )
        kornia.metrics.mean_average_precision(*trace_args)
        kornia.metrics.mean_average_precision(*test_args)
        test_kwargs = {}
    
        # NOTE: this test fails due to the use of dynamic control flow; skipping
>       _test_function(
            kornia.metrics.mean_average_precision,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            skip=True,
        )

kornia/test_metrics.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function mean_average_precision at 0x7f9a7d154940>
trace_args = ([tensor([[100.,  50., 150., 100.]])], [tensor([1.])], [tensor([0.7000])], [tensor([[100.,  50., 150., 100.]])], [tensor([1.])], 2), trace_kwargs = {}
test_args = ([tensor([[ 50.,  25.,  75.,  50.],
        [100.,  50., 150., 100.]])], [tensor([1., 2.])], [tensor([0.6000, 0.8000])], [tensor([[ 50.,  25.,  75.,  50.],
        [100.,  50., 150., 100.]])], [tensor([1., 2.])], 3)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = True, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function mean_average_precision at 0x7f9a7d154940>
trace_args = ([tensor([[100.,  50., 150., 100.]])], [tensor([1.])], [tensor([0.7000])], [tensor([[100.,  50., 150., 100.]])], [tensor([1.])], 2), trace_kwargs = {}
test_args = ([tensor([[ 50.,  25.,  75.,  50.],
        [100.,  50., 150., 100.]])], [tensor([1., 2.])], [tensor([0.6000, 0.8000])], [tensor([[ 50.,  25.,  75.,  50.],
        [100.,  50., 150., 100.]])], [tensor([1., 2.])], 3)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function mean_average_precision at 0x7f9a7d154940>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.mean_average_precision.mean_average_precision
_______________________________________________________________________________ test_mean_iou_bbox[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_mean_iou_bbox(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[40, 40, 60, 60], [30, 40, 50, 60]]),
            torch.tensor([[40, 50, 60, 70], [30, 40, 40, 50]])
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[20, 20, 40, 40], [10, 30, 30, 50]]),
            torch.tensor([[20, 30, 40, 50], [10, 20, 20, 30]])
        )
        test_kwargs = {}
>       _test_function(
            kornia.metrics.mean_iou_bbox,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_metrics.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function mean_iou_bbox at 0x7f9a7d154e50>, trace_args = (tensor([[40, 40, 60, 60],
        [30, 40, 50, 60]]), tensor([[40, 50, 60, 70],
        [30, 40, 40, 50]])), trace_kwargs = {}
test_args = (tensor([[20, 20, 40, 40],
        [10, 30, 30, 50]]), tensor([[20, 30, 40, 50],
        [10, 20, 20, 30]])), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function mean_iou_bbox at 0x7f9a7d154e50>, trace_args = (tensor([[40, 40, 60, 60],
        [30, 40, 50, 60]]), tensor([[40, 50, 60, 70],
        [30, 40, 40, 50]])), trace_kwargs = {}
test_args = (tensor([[20, 20, 40, 40],
        [10, 30, 30, 50]]), tensor([[20, 30, 40, 50],
        [10, 20, 20, 30]])), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function mean_iou_bbox at 0x7f9a7d154e50>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.mean_iou.mean_iou_bbox
___________________________________________________________________________________ test_psnr[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_psnr(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 4, 4),
            1.2 * torch.rand(1, 1, 4, 4),
            2.0,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2, 3, 4, 4),
            1.1 * torch.rand(2, 3, 4, 4),
            2.0,
        )
        test_kwargs = {}
>       _test_function(
            kornia.metrics.psnr,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_metrics.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function psnr at 0x7f9a7d155000>
trace_args = (tensor([[[[0.0673, 0.2092, 0.4431, 0.9191],
          [0.3656, 0.3591, 0.1274, 0.9231],
          [0.2189, 0.3456, 0....7367, 1.0166, 0.8066],
          [1.0370, 1.1372, 0.1916, 0.2037],
          [1.1228, 0.8301, 0.4561, 0.3000]]]]), 2.0)
trace_kwargs = {}
test_args = (tensor([[[[0.1602, 0.8411, 0.8632, 0.0590],
          [0.8413, 0.6232, 0.0900, 0.7501],
          [0.8132, 0.9105, 0....3321, 0.3647, 0.7996],
          [0.6796, 0.9904, 0.1554, 0.9838],
          [0.3817, 0.3654, 0.4211, 0.0024]]]]), 2.0)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function psnr at 0x7f9a7d155000>
trace_args = (tensor([[[[0.0673, 0.2092, 0.4431, 0.9191],
          [0.3656, 0.3591, 0.1274, 0.9231],
          [0.2189, 0.3456, 0....7367, 1.0166, 0.8066],
          [1.0370, 1.1372, 0.1916, 0.2037],
          [1.1228, 0.8301, 0.4561, 0.3000]]]]), 2.0)
trace_kwargs = {}
test_args = (tensor([[[[0.1602, 0.8411, 0.8632, 0.0590],
          [0.8413, 0.6232, 0.0900, 0.7501],
          [0.8132, 0.9105, 0....3321, 0.3647, 0.7996],
          [0.6796, 0.9904, 0.1554, 0.9838],
          [0.3817, 0.3654, 0.4211, 0.0024]]]]), 2.0)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function psnr at 0x7f9a7d155000>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.psnr.psnr
___________________________________________________________________________________ test_ssim[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ssim(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 5, 5),
            torch.rand(1, 1, 5, 5),
            5,
        )
        trace_kwargs = {}
        test_args = (
            # TODO: changing the channels dim here doesn't work with the transpiled function;
            # perhaps due to the looping implementation of conv_general_dilated in the ivy numpy backend?
            # (ivy/functional/backends/numpy/layers.py::conv_general_dilated)
            torch.rand(2, 1, 5, 5),
            torch.rand(2, 1, 5, 5),
            5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.metrics.ssim,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_metrics.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function ssim at 0x7f9a7d155240>
trace_args = (tensor([[[[0.4678, 0.2651, 0.2082, 0.7634, 0.1396],
          [0.3647, 0.3778, 0.4105, 0.9581, 0.5998],
          [0....0.6193],
          [0.0873, 0.5272, 0.2616, 0.2830, 0.2884],
          [0.0353, 0.5519, 0.4724, 0.0322, 0.7293]]]]), 5)
trace_kwargs = {}
test_args = (tensor([[[[0.8641, 0.5212, 0.1617, 0.2303, 0.1163],
          [0.0387, 0.2716, 0.2716, 0.2462, 0.7226],
          [0....0.3395],
          [0.6419, 0.0679, 0.3953, 0.4651, 0.1984],
          [0.0525, 0.9475, 0.5452, 0.0665, 0.5343]]]]), 5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function ssim at 0x7f9a7d155240>
trace_args = (tensor([[[[0.4678, 0.2651, 0.2082, 0.7634, 0.1396],
          [0.3647, 0.3778, 0.4105, 0.9581, 0.5998],
          [0....0.6193],
          [0.0873, 0.5272, 0.2616, 0.2830, 0.2884],
          [0.0353, 0.5519, 0.4724, 0.0322, 0.7293]]]]), 5)
trace_kwargs = {}
test_args = (tensor([[[[0.8641, 0.5212, 0.1617, 0.2303, 0.1163],
          [0.0387, 0.2716, 0.2716, 0.2462, 0.7226],
          [0....0.3395],
          [0.6419, 0.0679, 0.3953, 0.4651, 0.1984],
          [0.0525, 0.9475, 0.5452, 0.0665, 0.5343]]]]), 5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function ssim at 0x7f9a7d155240>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.ssim.ssim
__________________________________________________________________________________ test_ssim3d[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ssim3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 5, 5, 5),
            torch.rand(1, 1, 5, 5, 5),
            5,
        )
        trace_kwargs = {}
        test_args = (
            # TODO: same as `test_ssim`: changing the channels dim doesn't work with the transpiled function
            torch.rand(2, 1, 5, 5, 5),
            torch.rand(2, 1, 5, 5, 5),
            5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.metrics.ssim3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_metrics.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function ssim3d at 0x7f9a7d1555a0>
trace_args = (tensor([[[[[0.7755, 0.7010, 0.8084, 0.9145, 0.7863],
           [0.7569, 0.1717, 0.1037, 0.0638, 0.8416],
           ...310],
           [0.9769, 0.8082, 0.2448, 0.4334, 0.3777],
           [0.0223, 0.0463, 0.7909, 0.2827, 0.4866]]]]]), 5)
trace_kwargs = {}
test_args = (tensor([[[[[0.2689, 0.0597, 0.2237, 0.9569, 0.0223],
           [0.8823, 0.7511, 0.4696, 0.3570, 0.2476],
           ..., 9.7311e-02, 4.4072e-01, 3.7356e-01],
           [9.6246e-01, 3.7041e-01, 2.2411e-01, 7.0056e-01, 5.4724e-01]]]]]), 5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function ssim3d at 0x7f9a7d1555a0>
trace_args = (tensor([[[[[0.7755, 0.7010, 0.8084, 0.9145, 0.7863],
           [0.7569, 0.1717, 0.1037, 0.0638, 0.8416],
           ...310],
           [0.9769, 0.8082, 0.2448, 0.4334, 0.3777],
           [0.0223, 0.0463, 0.7909, 0.2827, 0.4866]]]]]), 5)
trace_kwargs = {}
test_args = (tensor([[[[[0.2689, 0.0597, 0.2237, 0.9569, 0.0223],
           [0.8823, 0.7511, 0.4696, 0.3570, 0.2476],
           ..., 9.7311e-02, 4.4072e-01, 3.7356e-01],
           [9.6246e-01, 3.7041e-01, 2.2411e-01, 7.0056e-01, 5.4724e-01]]]]]), 5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function ssim3d at 0x7f9a7d1555a0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.ssim3d.ssim3d
___________________________________________________________________________________ test_aepe[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_aepe(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(4, 4, 2),
            1.2 * torch.rand(4, 4, 2),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 4, 4, 2),
            torch.rand(5, 4, 4, 2),
        )
        test_kwargs = {}
>       _test_function(
            kornia.metrics.aepe,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_metrics.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function aepe at 0x7f9a7d154af0>
trace_args = (tensor([[[0.5145, 0.9296],
         [0.6915, 0.4115],
         [0.5001, 0.6271],
         [0.0222, 0.7934]],

       ...6484]],

        [[1.1618, 0.1102],
         [0.2015, 0.5356],
         [0.1990, 0.5149],
         [0.8115, 1.0416]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.7358, 0.8931],
          [0.9667, 0.4252],
          [0.1945, 0.8146],
          [0.5126, 0.7756]],

   ...],

         [[0.7131, 0.6994],
          [0.5948, 0.4562],
          [0.3484, 0.0831],
          [0.1185, 0.4066]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function aepe at 0x7f9a7d154af0>
trace_args = (tensor([[[0.5145, 0.9296],
         [0.6915, 0.4115],
         [0.5001, 0.6271],
         [0.0222, 0.7934]],

       ...6484]],

        [[1.1618, 0.1102],
         [0.2015, 0.5356],
         [0.1990, 0.5149],
         [0.8115, 1.0416]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.7358, 0.8931],
          [0.9667, 0.4252],
          [0.1945, 0.8146],
          [0.5126, 0.7756]],

   ...],

         [[0.7131, 0.6994],
          [0.5948, 0.4562],
          [0.3484, 0.0831],
          [0.1185, 0.4066]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function aepe at 0x7f9a7d154af0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.endpoint_error.aepe
___________________________________________________________________________________ test_SSIM[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SSIM(target_framework, mode, backend_compile):
        print("kornia.metrics.SSIM")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSSIM = ivy.transpile(kornia.metrics.SSIM, source="torch", target=target_framework)

kornia/test_metrics.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.metrics.ssim.SSIM'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.metrics.SSIM
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_metrics.py::test_accuracy[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_metrics.py::test_confusion_matrix[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/test_metrics.py::test_mean_iou[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_metrics.py::test_mean_average_precision[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you d...
FAILED kornia/test_metrics.py::test_mean_iou_bbox[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/test_metrics.py::test_psnr[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_...
FAILED kornia/test_metrics.py::test_ssim[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_...
FAILED kornia/test_metrics.py::test_ssim3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_metrics.py::test_aepe[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_...
FAILED kornia/test_metrics.py::test_SSIM[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_...
=============================================================================== 10 failed, 3 passed in 139.30s (0:02:19) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 57 items

kornia/geometry/test_transform.py FF...FF...F..FF.FFFFFFFFFFFFFFFFFFFF.F...F.F.FF.FF.F..FFF                                                                                                      [100%]

=============================================================================================== FAILURES ===============================================================================================
_____________________________________________________________________________ test_warp_perspective[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_warp_perspective(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.eye(3).unsqueeze(0),
            (4, 4),
        )
        trace_kwargs = {'mode': 'bilinear', 'padding_mode': 'zeros', 'align_corners': True}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.eye(3).unsqueeze(0),
            (4, 4),  # TODO: changing this fails the test
        )
        test_kwargs = {'mode': 'bilinear', 'padding_mode': 'zeros', 'align_corners': True}
>       _test_function(
            kornia.geometry.transform.warp_perspective,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function warp_perspective at 0x7fcbc354dd80>
trace_args = (tensor([[[[0.4980, 0.1593, 0.5021, 0.2341, 0.0483],
          [0.6181, 0.1164, 0.5273, 0.1706, 0.6957],
          [0....2, 0.6151, 0.9986, 0.6050, 0.5308]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), (4, 4))
trace_kwargs = {'align_corners': True, 'mode': 'bilinear', 'padding_mode': 'zeros'}
test_args = (tensor([[[[4.8691e-02, 2.7701e-01, 2.6025e-01, 4.7055e-01, 8.5996e-01],
          [8.5381e-01, 4.9354e-01, 3.5189e-02....8556e-02, 5.8754e-01, 9.7042e-01]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), (4, 4))
test_kwargs = {'align_corners': True, 'mode': 'bilinear', 'padding_mode': 'zeros'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function warp_perspective at 0x7fcbc354dd80>
trace_args = (tensor([[[[0.4980, 0.1593, 0.5021, 0.2341, 0.0483],
          [0.6181, 0.1164, 0.5273, 0.1706, 0.6957],
          [0....2, 0.6151, 0.9986, 0.6050, 0.5308]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), (4, 4))
trace_kwargs = {'align_corners': True, 'mode': 'bilinear', 'padding_mode': 'zeros'}
test_args = (tensor([[[[4.8691e-02, 2.7701e-01, 2.6025e-01, 4.7055e-01, 8.5996e-01],
          [8.5381e-01, 4.9354e-01, 3.5189e-02....8556e-02, 5.8754e-01, 9.7042e-01]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), (4, 4))
test_kwargs = {'align_corners': True, 'mode': 'bilinear', 'padding_mode': 'zeros'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function warp_perspective at 0x7fcbc354dd80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.warp_perspective
____________________________________________________________________________ test_warp_perspective3d[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_warp_perspective3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5, 5),
            torch.eye(4).unsqueeze(0),
            (4, 4, 4),
        )
        trace_kwargs = {'flags': 'bilinear', 'border_mode': 'zeros', 'align_corners': False}
        test_args = (
            torch.rand(1, 3, 6, 7, 6),
            torch.eye(4).unsqueeze(0),
            (2, 2, 2),
        )
        test_kwargs = {'flags': 'bilinear', 'border_mode': 'zeros', 'align_corners': False}
>       _test_function(
            kornia.geometry.transform.warp_perspective3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function warp_perspective3d at 0x7fcbc354e8c0>
trace_args = (tensor([[[[[0.9338, 0.2059, 0.3483, 0.5206, 0.3231],
           [0.5252, 0.7046, 0.7330, 0.6446, 0.0502],
           ...nsor([[[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]]]), (4, 4, 4))
trace_kwargs = {'align_corners': False, 'border_mode': 'zeros', 'flags': 'bilinear'}
test_args = (tensor([[[[[8.3499e-01, 2.6562e-01, 7.7317e-02, 6.7527e-01, 7.1702e-01,
            6.5422e-01],
           [2.7575e-...nsor([[[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]]]), (2, 2, 2))
test_kwargs = {'align_corners': False, 'border_mode': 'zeros', 'flags': 'bilinear'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function warp_perspective3d at 0x7fcbc354e8c0>
trace_args = (tensor([[[[[0.9338, 0.2059, 0.3483, 0.5206, 0.3231],
           [0.5252, 0.7046, 0.7330, 0.6446, 0.0502],
           ...nsor([[[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]]]), (4, 4, 4))
trace_kwargs = {'align_corners': False, 'border_mode': 'zeros', 'flags': 'bilinear'}
test_args = (tensor([[[[[8.3499e-01, 2.6562e-01, 7.7317e-02, 6.7527e-01, 7.1702e-01,
            6.5422e-01],
           [2.7575e-...nsor([[[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]]]), (2, 2, 2))
test_kwargs = {'align_corners': False, 'border_mode': 'zeros', 'flags': 'bilinear'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function warp_perspective3d at 0x7fcbc354e8c0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.warp_perspective3d
______________________________________________________________________________ test_warp_points_tps[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_warp_points_tps(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 5, 2),
            torch.rand(1, 5, 2),
            torch.rand(1, 5, 2),
            torch.rand(1, 3, 2),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 10, 2),
            torch.rand(5, 10, 2),
            torch.rand(5, 10, 2),
            torch.rand(5, 3, 2),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.warp_points_tps,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function warp_points_tps at 0x7fcbc35631c0>
trace_args = (tensor([[[0.3536, 0.5381],
         [0.5114, 0.4181],
         [0.2705, 0.8909],
         [0.2993, 0.3803],
         ...677],
         [0.1558, 0.2075]]]), tensor([[[0.9952, 0.8886],
         [0.8014, 0.7218],
         [0.3706, 0.7404]]]))
trace_kwargs = {}
test_args = (tensor([[[0.6612, 0.9463],
         [0.0206, 0.5783],
         [0.0825, 0.6091],
         [0.9000, 0.7904],
         ...7734],
         [0.3142, 0.7725]],

        [[0.9188, 0.0723],
         [0.0533, 0.8187],
         [0.2973, 0.4847]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function warp_points_tps at 0x7fcbc35631c0>
trace_args = (tensor([[[0.3536, 0.5381],
         [0.5114, 0.4181],
         [0.2705, 0.8909],
         [0.2993, 0.3803],
         ...677],
         [0.1558, 0.2075]]]), tensor([[[0.9952, 0.8886],
         [0.8014, 0.7218],
         [0.3706, 0.7404]]]))
trace_kwargs = {}
test_args = (tensor([[[0.6612, 0.9463],
         [0.0206, 0.5783],
         [0.0825, 0.6091],
         [0.9000, 0.7904],
         ...7734],
         [0.3142, 0.7725]],

        [[0.9188, 0.0723],
         [0.0533, 0.8187],
         [0.2973, 0.4847]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function warp_points_tps at 0x7fcbc35631c0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.thin_plate_spline.warp_points_tps
_________________________________________________________________________________ test_warp_grid[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_warp_grid(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 5, 5, 2),
            torch.eye(3).unsqueeze(0),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(1, 10, 10, 2),
            torch.eye(3).unsqueeze(0),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.warp_grid,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function warp_grid at 0x7fcbc354df30>
trace_args = (tensor([[[[0.8042, 0.4709],
          [0.0319, 0.9909],
          [0.1560, 0.5058],
          [0.5975, 0.4166],
     ....0573, 0.0026],
          [0.1172, 0.3926]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.8151, 0.1716],
          [0.4285, 0.1751],
          [0.2628, 0.5323],
          [0.2128, 0.3318],
     ....0659, 0.7845],
          [0.9849, 0.5652]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function warp_grid at 0x7fcbc354df30>
trace_args = (tensor([[[[0.8042, 0.4709],
          [0.0319, 0.9909],
          [0.1560, 0.5058],
          [0.5975, 0.4166],
     ....0573, 0.0026],
          [0.1172, 0.3926]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.8151, 0.1716],
          [0.4285, 0.1751],
          [0.2628, 0.5323],
          [0.2128, 0.3318],
     ....0659, 0.7845],
          [0.9849, 0.5652]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function warp_grid at 0x7fcbc354df30>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.warp_grid
__________________________________________________________________________________ test_rotate[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rotate(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3, 4, 4),
            torch.tensor([90.]),
        )
        trace_kwargs = {'mode': 'bilinear', 'padding_mode': 'zeros', 'align_corners': True}
        test_args = (
            torch.rand(5, 3, 4, 4),
            torch.tensor([45., 45., 45., 45., 45.]),
        )
        test_kwargs = {'mode': 'bilinear', 'padding_mode': 'zeros', 'align_corners': True}
>       _test_function(
            kornia.geometry.transform.rotate,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rotate at 0x7fcbc354f0a0>
trace_args = (tensor([[[[0.1725, 0.8636, 0.0280, 0.4102],
          [0.3977, 0.7004, 0.2157, 0.7271],
          [0.6567, 0.6778, 0....19, 0.7902],
          [0.3054, 0.5167, 0.1790, 0.7567],
          [0.2838, 0.7204, 0.1237, 0.4575]]]]), tensor([90.]))
trace_kwargs = {'align_corners': True, 'mode': 'bilinear', 'padding_mode': 'zeros'}
test_args = (tensor([[[[0.0124, 0.1107, 0.2247, 0.5251],
          [0.4114, 0.2997, 0.1676, 0.0562],
          [0.4139, 0.6453, 0....   [0.8007, 0.2034, 0.2556, 0.0057],
          [0.8493, 0.8394, 0.1898, 0.0202]]]]), tensor([45., 45., 45., 45., 45.]))
test_kwargs = {'align_corners': True, 'mode': 'bilinear', 'padding_mode': 'zeros'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rotate at 0x7fcbc354f0a0>
trace_args = (tensor([[[[0.1725, 0.8636, 0.0280, 0.4102],
          [0.3977, 0.7004, 0.2157, 0.7271],
          [0.6567, 0.6778, 0....19, 0.7902],
          [0.3054, 0.5167, 0.1790, 0.7567],
          [0.2838, 0.7204, 0.1237, 0.4575]]]]), tensor([90.]))
trace_kwargs = {'align_corners': True, 'mode': 'bilinear', 'padding_mode': 'zeros'}
test_args = (tensor([[[[0.0124, 0.1107, 0.2247, 0.5251],
          [0.4114, 0.2997, 0.1676, 0.0562],
          [0.4139, 0.6453, 0....   [0.8007, 0.2034, 0.2556, 0.0057],
          [0.8493, 0.8394, 0.1898, 0.0202]]]]), tensor([45., 45., 45., 45., 45.]))
test_kwargs = {'align_corners': True, 'mode': 'bilinear', 'padding_mode': 'zeros'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rotate at 0x7fcbc354f0a0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.affwarp.rotate
___________________________________________________________________________________ test_shear[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_shear(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3, 4, 4),
            torch.tensor([[0.5, 0.0]]),
        )
        trace_kwargs = {'mode': 'bilinear', 'padding_mode': 'zeros', 'align_corners': False}
        test_args = (
            torch.rand(5, 3, 4, 4),
            torch.tensor([[0.1, 0.3]]).repeat(5, 1),
        )
        test_kwargs = {'mode': 'bilinear', 'padding_mode': 'zeros', 'align_corners': False}
>       _test_function(
            kornia.geometry.transform.shear,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function shear at 0x7fcbc354f400>
trace_args = (tensor([[[[0.2400, 0.6174, 0.8039, 0.7244],
          [0.9168, 0.0815, 0.8860, 0.8257],
          [0.5874, 0.4842, 0....          [0.7775, 0.9882, 0.2675, 0.1452],
          [0.7826, 0.0506, 0.1157, 0.6106]]]]), tensor([[0.5000, 0.0000]]))
trace_kwargs = {'align_corners': False, 'mode': 'bilinear', 'padding_mode': 'zeros'}
test_args = (tensor([[[[0.1004, 0.8775, 0.0669, 0.2903],
          [0.7322, 0.4774, 0.0130, 0.2746],
          [0.2283, 0.2741, 0....000, 0.3000],
        [0.1000, 0.3000],
        [0.1000, 0.3000],
        [0.1000, 0.3000],
        [0.1000, 0.3000]]))
test_kwargs = {'align_corners': False, 'mode': 'bilinear', 'padding_mode': 'zeros'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function shear at 0x7fcbc354f400>
trace_args = (tensor([[[[0.2400, 0.6174, 0.8039, 0.7244],
          [0.9168, 0.0815, 0.8860, 0.8257],
          [0.5874, 0.4842, 0....          [0.7775, 0.9882, 0.2675, 0.1452],
          [0.7826, 0.0506, 0.1157, 0.6106]]]]), tensor([[0.5000, 0.0000]]))
trace_kwargs = {'align_corners': False, 'mode': 'bilinear', 'padding_mode': 'zeros'}
test_args = (tensor([[[[0.1004, 0.8775, 0.0669, 0.2903],
          [0.7322, 0.4774, 0.0130, 0.2746],
          [0.2283, 0.2741, 0....000, 0.3000],
        [0.1000, 0.3000],
        [0.1000, 0.3000],
        [0.1000, 0.3000],
        [0.1000, 0.3000]]))
test_kwargs = {'align_corners': False, 'mode': 'bilinear', 'padding_mode': 'zeros'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function shear at 0x7fcbc354f400>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.affwarp.shear
___________________________________________________________________________________ test_hflip[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_hflip(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.hflip,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function hflip at 0x7fcbc3560f70>
trace_args = (tensor([[[[0.3029, 0.3309, 0.7479, 0.0646],
          [0.0686, 0.0900, 0.6593, 0.6720],
          [0.6597, 0.4270, 0...., 0.7065, 0.0950, 0.8080],
          [0.0608, 0.9209, 0.4335, 0.1407],
          [0.8189, 0.4056, 0.2226, 0.0674]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.6245, 0.1158, 0.8506, 0.5400],
          [0.8479, 0.7943, 0.1954, 0.3417],
          [0.8460, 0.3712, 0...., 0.2637, 0.7844, 0.7482],
          [0.1102, 0.8967, 0.5222, 0.5677],
          [0.6272, 0.4488, 0.9309, 0.1142]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function hflip at 0x7fcbc3560f70>
trace_args = (tensor([[[[0.3029, 0.3309, 0.7479, 0.0646],
          [0.0686, 0.0900, 0.6593, 0.6720],
          [0.6597, 0.4270, 0...., 0.7065, 0.0950, 0.8080],
          [0.0608, 0.9209, 0.4335, 0.1407],
          [0.8189, 0.4056, 0.2226, 0.0674]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.6245, 0.1158, 0.8506, 0.5400],
          [0.8479, 0.7943, 0.1954, 0.3417],
          [0.8460, 0.3712, 0...., 0.2637, 0.7844, 0.7482],
          [0.1102, 0.8967, 0.5222, 0.5677],
          [0.6272, 0.4488, 0.9309, 0.1142]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function hflip at 0x7fcbc3560f70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.flips.hflip
__________________________________________________________________________________ test_rot180[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rot180(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.rot180,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rot180 at 0x7fcbc3560b80>
trace_args = (tensor([[[[0.7735, 0.3560, 0.7800, 0.0350],
          [0.7360, 0.6387, 0.5373, 0.2893],
          [0.2672, 0.0582, 0...., 0.9650, 0.4737, 0.7001],
          [0.7841, 0.1073, 0.9894, 0.3470],
          [0.3029, 0.5120, 0.1226, 0.7036]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.6135, 0.6565, 0.6993, 0.4376],
          [0.1383, 0.5757, 0.5752, 0.8833],
          [0.3540, 0.6755, 0...., 0.1965, 0.8454, 0.8735],
          [0.4907, 0.2260, 0.5887, 0.4360],
          [0.4456, 0.9361, 0.6998, 0.5021]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rot180 at 0x7fcbc3560b80>
trace_args = (tensor([[[[0.7735, 0.3560, 0.7800, 0.0350],
          [0.7360, 0.6387, 0.5373, 0.2893],
          [0.2672, 0.0582, 0...., 0.9650, 0.4737, 0.7001],
          [0.7841, 0.1073, 0.9894, 0.3470],
          [0.3029, 0.5120, 0.1226, 0.7036]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.6135, 0.6565, 0.6993, 0.4376],
          [0.1383, 0.5757, 0.5752, 0.8833],
          [0.3540, 0.6755, 0...., 0.1965, 0.8454, 0.8735],
          [0.4907, 0.2260, 0.5887, 0.4360],
          [0.4456, 0.9361, 0.6998, 0.5021]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rot180 at 0x7fcbc3560b80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.flips.rot180
__________________________________________________________________________________ test_resize[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_resize(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
            (6, 8),
        )
        trace_kwargs = {'interpolation': 'bilinear'}
        test_args = (
            torch.rand(5, 3, 4, 4),
            (12, 16),
        )
        test_kwargs = {'interpolation': 'bilinear'}
>       _test_function(
            kornia.geometry.transform.resize,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function resize at 0x7fcbc354f5b0>
trace_args = (tensor([[[[0.3118, 0.1496, 0.1453, 0.3158],
          [0.6039, 0.6044, 0.2668, 0.6965],
          [0.1959, 0.4694, 0....0, 0.1658, 0.4214],
          [0.9483, 0.5685, 0.9045, 0.7109],
          [0.5901, 0.1816, 0.5408, 0.9947]]]]), (6, 8))
trace_kwargs = {'interpolation': 'bilinear'}
test_args = (tensor([[[[0.0090, 0.6716, 0.7123, 0.7831],
          [0.5023, 0.2257, 0.4112, 0.6888],
          [0.6603, 0.7505, 0.... 0.1729, 0.9412],
          [0.6320, 0.3601, 0.3555, 0.2048],
          [0.8327, 0.3067, 0.3039, 0.7658]]]]), (12, 16))
test_kwargs = {'interpolation': 'bilinear'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function resize at 0x7fcbc354f5b0>
trace_args = (tensor([[[[0.3118, 0.1496, 0.1453, 0.3158],
          [0.6039, 0.6044, 0.2668, 0.6965],
          [0.1959, 0.4694, 0....0, 0.1658, 0.4214],
          [0.9483, 0.5685, 0.9045, 0.7109],
          [0.5901, 0.1816, 0.5408, 0.9947]]]]), (6, 8))
trace_kwargs = {'interpolation': 'bilinear'}
test_args = (tensor([[[[0.0090, 0.6716, 0.7123, 0.7831],
          [0.5023, 0.2257, 0.4112, 0.6888],
          [0.6603, 0.7505, 0.... 0.1729, 0.9412],
          [0.6320, 0.3601, 0.3555, 0.2048],
          [0.8327, 0.3067, 0.3039, 0.7658]]]]), (12, 16))
test_kwargs = {'interpolation': 'bilinear'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function resize at 0x7fcbc354f5b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.affwarp.resize
__________________________________________________________________________________ test_rescale[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rescale(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
            (2, 3),
        )
        trace_kwargs = {'interpolation': 'bilinear'}
        test_args = (
            torch.rand(5, 3, 4, 4),
            (1.5, 2),
        )
        test_kwargs = {'interpolation': 'bilinear'}
>       _test_function(
            kornia.geometry.transform.rescale,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rescale at 0x7fcbc354f6d0>
trace_args = (tensor([[[[0.4593, 0.5876, 0.5917, 0.1229],
          [0.4540, 0.2572, 0.1834, 0.0617],
          [0.8767, 0.9323, 0....1, 0.8873, 0.3677],
          [0.9595, 0.6131, 0.7859, 0.8673],
          [0.5587, 0.5413, 0.4907, 0.9204]]]]), (2, 3))
trace_kwargs = {'interpolation': 'bilinear'}
test_args = (tensor([[[[0.1460, 0.7430, 0.8484, 0.8536],
          [0.3292, 0.6866, 0.7832, 0.6166],
          [0.9868, 0.7348, 0.... 0.4778, 0.6017],
          [0.5172, 0.8750, 0.2414, 0.6395],
          [0.9965, 0.3663, 0.2991, 0.5236]]]]), (1.5, 2))
test_kwargs = {'interpolation': 'bilinear'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rescale at 0x7fcbc354f6d0>
trace_args = (tensor([[[[0.4593, 0.5876, 0.5917, 0.1229],
          [0.4540, 0.2572, 0.1834, 0.0617],
          [0.8767, 0.9323, 0....1, 0.8873, 0.3677],
          [0.9595, 0.6131, 0.7859, 0.8673],
          [0.5587, 0.5413, 0.4907, 0.9204]]]]), (2, 3))
trace_kwargs = {'interpolation': 'bilinear'}
test_args = (tensor([[[[0.1460, 0.7430, 0.8484, 0.8536],
          [0.3292, 0.6866, 0.7832, 0.6166],
          [0.9868, 0.7348, 0.... 0.4778, 0.6017],
          [0.5172, 0.8750, 0.2414, 0.6395],
          [0.9965, 0.3663, 0.2991, 0.5236]]]]), (1.5, 2))
test_kwargs = {'interpolation': 'bilinear'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rescale at 0x7fcbc354f6d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.affwarp.rescale
____________________________________________________________________________ test_elastic_transform2d[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_elastic_transform2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(1, 2, 5, 5),
        )
        trace_kwargs = {'kernel_size': (63, 63), 'sigma': (32.0, 32.0), 'alpha': (1.0, 1.0)}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(5, 2, 5, 5),
        )
        test_kwargs = {'kernel_size': (31, 31), 'sigma': (16.0, 16.0), 'alpha': (0.5, 0.5)}
>       _test_function(
            kornia.geometry.transform.elastic_transform2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=5e-2,
            mode=mode,
        )

kornia/geometry/test_transform.py:496: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function elastic_transform2d at 0x7fcbc35609d0>
trace_args = (tensor([[[[0.7433, 0.8941, 0.7516, 0.9055, 0.2646],
          [0.3197, 0.6882, 0.3425, 0.1356, 0.4749],
          [0....8, 0.9772],
          [0.0386, 0.2364, 0.1007, 0.9536, 0.8615],
          [0.9792, 0.9262, 0.4659, 0.5795, 0.3940]]]]))
trace_kwargs = {'alpha': (1.0, 1.0), 'kernel_size': (63, 63), 'sigma': (32.0, 32.0)}
test_args = (tensor([[[[0.3669, 0.7090, 0.4755, 0.2575, 0.3377],
          [0.2384, 0.4500, 0.0426, 0.3065, 0.7457],
          [0....9e-01, 9.2204e-01, 3.9434e-01, 3.8374e-01],
          [8.0963e-01, 4.5172e-01, 1.8530e-01, 7.7296e-01, 3.8978e-01]]]]))
test_kwargs = {'alpha': (0.5, 0.5), 'kernel_size': (31, 31), 'sigma': (16.0, 16.0)}, target = 'tensorflow', backend_compile = False, tolerance = 0.05, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function elastic_transform2d at 0x7fcbc35609d0>
trace_args = (tensor([[[[0.7433, 0.8941, 0.7516, 0.9055, 0.2646],
          [0.3197, 0.6882, 0.3425, 0.1356, 0.4749],
          [0....8, 0.9772],
          [0.0386, 0.2364, 0.1007, 0.9536, 0.8615],
          [0.9792, 0.9262, 0.4659, 0.5795, 0.3940]]]]))
trace_kwargs = {'alpha': (1.0, 1.0), 'kernel_size': (63, 63), 'sigma': (32.0, 32.0)}
test_args = (tensor([[[[0.3669, 0.7090, 0.4755, 0.2575, 0.3377],
          [0.2384, 0.4500, 0.0426, 0.3065, 0.7457],
          [0....9e-01, 9.2204e-01, 3.9434e-01, 3.8374e-01],
          [8.0963e-01, 4.5172e-01, 1.8530e-01, 7.7296e-01, 3.8978e-01]]]]))
test_kwargs = {'alpha': (0.5, 0.5), 'kernel_size': (31, 31), 'sigma': (16.0, 16.0)}, target = 'tensorflow', backend_compile = False, tolerance = 0.05, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function elastic_transform2d at 0x7fcbc35609d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.elastic_transform.elastic_transform2d
__________________________________________________________________________________ test_pyrdown[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_pyrdown(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 4, 4),
        )
        trace_kwargs = {'border_type': 'reflect', 'align_corners': False, 'factor': 2.0}
        test_args = (
            torch.rand(5, 1, 8, 8),
        )
        test_kwargs = {'border_type': 'reflect', 'align_corners': False, 'factor': 2.0}
>       _test_function(
            kornia.geometry.transform.pyrdown,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:520: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function pyrdown at 0x7fcbc3561b40>
trace_args = (tensor([[[[0.8561, 0.3410, 0.1811, 0.9425],
          [0.9331, 0.7560, 0.9984, 0.3886],
          [0.6269, 0.0699, 0.9100, 0.0767],
          [0.6575, 0.2805, 0.6068, 0.5794]]]]),)
trace_kwargs = {'align_corners': False, 'border_type': 'reflect', 'factor': 2.0}
test_args = (tensor([[[[0.1009, 0.0937, 0.7214, 0.8844, 0.7970, 0.4413, 0.6314, 0.3035],
          [0.8033, 0.2930, 0.3611, 0.2921...0830, 0.7079, 0.6501, 0.4265, 0.0755],
          [0.8228, 0.1387, 0.0593, 0.6549, 0.4667, 0.0596, 0.4452, 0.5184]]]]),)
test_kwargs = {'align_corners': False, 'border_type': 'reflect', 'factor': 2.0}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function pyrdown at 0x7fcbc3561b40>
trace_args = (tensor([[[[0.8561, 0.3410, 0.1811, 0.9425],
          [0.9331, 0.7560, 0.9984, 0.3886],
          [0.6269, 0.0699, 0.9100, 0.0767],
          [0.6575, 0.2805, 0.6068, 0.5794]]]]),)
trace_kwargs = {'align_corners': False, 'border_type': 'reflect', 'factor': 2.0}
test_args = (tensor([[[[0.1009, 0.0937, 0.7214, 0.8844, 0.7970, 0.4413, 0.6314, 0.3035],
          [0.8033, 0.2930, 0.3611, 0.2921...0830, 0.7079, 0.6501, 0.4265, 0.0755],
          [0.8228, 0.1387, 0.0593, 0.6549, 0.4667, 0.0596, 0.4452, 0.5184]]]]),)
test_kwargs = {'align_corners': False, 'border_type': 'reflect', 'factor': 2.0}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function pyrdown at 0x7fcbc3561b40>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.pyramid.pyrdown
___________________________________________________________________________________ test_pyrup[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_pyrup(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 2, 2),
        )
        trace_kwargs = {'border_type': 'reflect', 'align_corners': False}
        test_args = (
            torch.rand(5, 1, 4, 4),
        )
        test_kwargs = {'border_type': 'reflect', 'align_corners': False}
>       _test_function(
            kornia.geometry.transform.pyrup,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function pyrup at 0x7fcbc35620e0>, trace_args = (tensor([[[[0.9020, 0.6945],
          [0.7288, 0.1550]]]]),), trace_kwargs = {'align_corners': False, 'border_type': 'reflect'}
test_args = (tensor([[[[0.4317, 0.6495, 0.4802, 0.2930],
          [0.3917, 0.7588, 0.6024, 0.4366],
          [0.2476, 0.8123, 0...., 0.7544, 0.1612, 0.8520],
          [0.3257, 0.9128, 0.6304, 0.3361],
          [0.6317, 0.0605, 0.2900, 0.1318]]]]),)
test_kwargs = {'align_corners': False, 'border_type': 'reflect'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function pyrup at 0x7fcbc35620e0>, trace_args = (tensor([[[[0.9020, 0.6945],
          [0.7288, 0.1550]]]]),), trace_kwargs = {'align_corners': False, 'border_type': 'reflect'}
test_args = (tensor([[[[0.4317, 0.6495, 0.4802, 0.2930],
          [0.3917, 0.7588, 0.6024, 0.4366],
          [0.2476, 0.8123, 0...., 0.7544, 0.1612, 0.8520],
          [0.3257, 0.9128, 0.6304, 0.3361],
          [0.6317, 0.0605, 0.2900, 0.1318]]]]),)
test_kwargs = {'align_corners': False, 'border_type': 'reflect'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function pyrup at 0x7fcbc35620e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.pyramid.pyrup
_______________________________________________________________________________ test_build_pyramid[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_build_pyramid(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 8, 8),
            3,
        )
        trace_kwargs = {'border_type': 'reflect', 'align_corners': False}
        test_args = (
            torch.rand(5, 3, 16, 16),
            4,
        )
        test_kwargs = {'border_type': 'reflect', 'align_corners': False}
>       _test_function(
            kornia.geometry.transform.build_pyramid,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:566: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function build_pyramid at 0x7fcbc3562170>
trace_args = (tensor([[[[0.5664, 0.2471, 0.1385, 0.9413, 0.3470, 0.1235, 0.2570, 0.2577],
          [0.0858, 0.1179, 0.3431, 0.6898...20, 0.6932, 0.2154, 0.9259, 0.0644],
          [0.9406, 0.7977, 0.2584, 0.9232, 0.5525, 0.6888, 0.7378, 0.7262]]]]), 3)
trace_kwargs = {'align_corners': False, 'border_type': 'reflect'}
test_args = (tensor([[[[0.1684, 0.3923, 0.3144,  ..., 0.8664, 0.6378, 0.4080],
          [0.9436, 0.0553, 0.5229,  ..., 0.0552, 0....0.1766, 0.8334,  ..., 0.3762, 0.0420, 0.7668],
          [0.7677, 0.0367, 0.3885,  ..., 0.6577, 0.4446, 0.8318]]]]), 4)
test_kwargs = {'align_corners': False, 'border_type': 'reflect'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function build_pyramid at 0x7fcbc3562170>
trace_args = (tensor([[[[0.5664, 0.2471, 0.1385, 0.9413, 0.3470, 0.1235, 0.2570, 0.2577],
          [0.0858, 0.1179, 0.3431, 0.6898...20, 0.6932, 0.2154, 0.9259, 0.0644],
          [0.9406, 0.7977, 0.2584, 0.9232, 0.5525, 0.6888, 0.7378, 0.7262]]]]), 3)
trace_kwargs = {'align_corners': False, 'border_type': 'reflect'}
test_args = (tensor([[[[0.1684, 0.3923, 0.3144,  ..., 0.8664, 0.6378, 0.4080],
          [0.9436, 0.0553, 0.5229,  ..., 0.0552, 0....0.1766, 0.8334,  ..., 0.3762, 0.0420, 0.7668],
          [0.7677, 0.0367, 0.3885,  ..., 0.6577, 0.4446, 0.8318]]]]), 4)
test_kwargs = {'align_corners': False, 'border_type': 'reflect'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function build_pyramid at 0x7fcbc3562170>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.pyramid.build_pyramid
__________________________________________________________________________ test_build_laplacian_pyramid[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_build_laplacian_pyramid(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 8, 8),
            3,
        )
        trace_kwargs = {'border_type': 'reflect', 'align_corners': False}
        test_args = (
            torch.rand(5, 3, 16, 16),
            4,
        )
        test_kwargs = {'border_type': 'reflect', 'align_corners': False}
>       _test_function(
            kornia.geometry.transform.build_laplacian_pyramid,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:590: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function build_laplacian_pyramid at 0x7fcbc3562320>
trace_args = (tensor([[[[0.4185, 0.9817, 0.3836, 0.3483, 0.1848, 0.5153, 0.6171, 0.9771],
          [0.2321, 0.1835, 0.3556, 0.0269...19, 0.3382, 0.4228, 0.2109, 0.7141],
          [0.0830, 0.6067, 0.0973, 0.1129, 0.3027, 0.8624, 0.3199, 0.5715]]]]), 3)
trace_kwargs = {'align_corners': False, 'border_type': 'reflect'}
test_args = (tensor([[[[0.0575, 0.1848, 0.5335,  ..., 0.8447, 0.9872, 0.5022],
          [0.8068, 0.4030, 0.3866,  ..., 0.5301, 0....0.6739, 0.7914,  ..., 0.0529, 0.4178, 0.3171],
          [0.3010, 0.3251, 0.2322,  ..., 0.4637, 0.6422, 0.3856]]]]), 4)
test_kwargs = {'align_corners': False, 'border_type': 'reflect'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function build_laplacian_pyramid at 0x7fcbc3562320>
trace_args = (tensor([[[[0.4185, 0.9817, 0.3836, 0.3483, 0.1848, 0.5153, 0.6171, 0.9771],
          [0.2321, 0.1835, 0.3556, 0.0269...19, 0.3382, 0.4228, 0.2109, 0.7141],
          [0.0830, 0.6067, 0.0973, 0.1129, 0.3027, 0.8624, 0.3199, 0.5715]]]]), 3)
trace_kwargs = {'align_corners': False, 'border_type': 'reflect'}
test_args = (tensor([[[[0.0575, 0.1848, 0.5335,  ..., 0.8447, 0.9872, 0.5022],
          [0.8068, 0.4030, 0.3866,  ..., 0.5301, 0....0.6739, 0.7914,  ..., 0.0529, 0.4178, 0.3171],
          [0.3010, 0.3251, 0.2322,  ..., 0.4637, 0.6422, 0.3856]]]]), 4)
test_kwargs = {'align_corners': False, 'border_type': 'reflect'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function build_laplacian_pyramid at 0x7fcbc3562320>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.pyramid.build_laplacian_pyramid
______________________________________________________________________________ test_upscale_double[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_upscale_double(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 8, 8),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.upscale_double,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:612: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function upscale_double at 0x7fcbc35623b0>
trace_args = (tensor([[[[0.0447, 0.5039, 0.1521, 0.5678],
          [0.7477, 0.2183, 0.4082, 0.9938],
          [0.8652, 0.2477, 0...., 0.5449, 0.7199, 0.7879],
          [0.9129, 0.9935, 0.0556, 0.1722],
          [0.5823, 0.5330, 0.2766, 0.0862]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[1.3682e-01, 9.6764e-01, 6.1879e-01, 3.1703e-01, 8.5108e-01,
           1.3409e-01, 6.8133e-01, 2.0252e-01]...      [7.3825e-01, 8.7272e-01, 6.2168e-01, 5.1115e-01, 9.2115e-01,
           3.4231e-01, 3.6345e-01, 5.5632e-02]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function upscale_double at 0x7fcbc35623b0>
trace_args = (tensor([[[[0.0447, 0.5039, 0.1521, 0.5678],
          [0.7477, 0.2183, 0.4082, 0.9938],
          [0.8652, 0.2477, 0...., 0.5449, 0.7199, 0.7879],
          [0.9129, 0.9935, 0.0556, 0.1722],
          [0.5823, 0.5330, 0.2766, 0.0862]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[1.3682e-01, 9.6764e-01, 6.1879e-01, 3.1703e-01, 8.5108e-01,
           1.3409e-01, 6.8133e-01, 2.0252e-01]...      [7.3825e-01, 8.7272e-01, 6.2168e-01, 5.1115e-01, 9.2115e-01,
           3.4231e-01, 3.6345e-01, 5.5632e-02]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function upscale_double at 0x7fcbc35623b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.pyramid.upscale_double
_________________________________________________________________________ test_get_perspective_transform[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_perspective_transform(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[[0., 0.], [1., 0.], [1., 1.], [0., 1.]]]),
            torch.tensor([[[1., 0.], [0., 0.], [0., 1.], [1., 1.]]])
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[[0., 0.], [2., 0.], [2., 2.], [0., 2.]]]),
            torch.tensor([[[2., 0.], [0., 0.], [0., 2.], [2., 2.]]])
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_perspective_transform,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:636: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_perspective_transform at 0x7fcbc354e050>
trace_args = (tensor([[[0., 0.],
         [1., 0.],
         [1., 1.],
         [0., 1.]]]), tensor([[[1., 0.],
         [0., 0.],
         [0., 1.],
         [1., 1.]]])), trace_kwargs = {}
test_args = (tensor([[[0., 0.],
         [2., 0.],
         [2., 2.],
         [0., 2.]]]), tensor([[[2., 0.],
         [0., 0.],
         [0., 2.],
         [2., 2.]]])), test_kwargs = {}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_perspective_transform at 0x7fcbc354e050>
trace_args = (tensor([[[0., 0.],
         [1., 0.],
         [1., 1.],
         [0., 1.]]]), tensor([[[1., 0.],
         [0., 0.],
         [0., 1.],
         [1., 1.]]])), trace_kwargs = {}
test_args = (tensor([[[0., 0.],
         [2., 0.],
         [2., 2.],
         [0., 2.]]]), tensor([[[2., 0.],
         [0., 0.],
         [0., 2.],
         [2., 2.]]])), test_kwargs = {}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_perspective_transform at 0x7fcbc354e050>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.get_perspective_transform
________________________________________________________________________ test_get_perspective_transform3d[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_perspective_transform3d(target_framework, mode, backend_compile):
        src = torch.tensor([[
            [0.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 1.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 0.0, 1.0],
            [1.0, 0.0, 1.0],
            [1.0, 1.0, 1.0],
            [0.0, 1.0, 1.0]
        ]])
        dst = torch.tensor([[
            [0.1, 0.1, 0.0],
            [1.1, 0.0, 0.0],
            [1.0, 1.1, 0.0],
            [0.0, 1.0, 0.1],
            [0.1, 0.0, 1.1],
            [1.0, 0.1, 1.0],
            [1.1, 1.1, 1.0],
            [0.0, 1.1, 1.1]
        ]])
        trace_args = (src, dst)
        trace_kwargs = {}
        src = torch.tensor([
            [
                [0.0, 0.0, 0.0],
                [2.0, 0.0, 0.0],
                [2.0, 2.0, 0.0],
                [0.0, 2.0, 0.0],
                [0.0, 0.0, 2.0],
                [2.0, 0.0, 2.0],
                [2.0, 2.0, 2.0],
                [0.0, 2.0, 2.0]
            ],
            [
                [1.0, 1.0, 0.0],
                [3.0, 1.0, 0.0],
                [3.0, 3.0, 0.0],
                [1.0, 3.0, 0.0],
                [1.0, 1.0, 2.0],
                [3.0, 1.0, 2.0],
                [3.0, 3.0, 2.0],
                [1.0, 3.0, 2.0]
            ]
        ])
        dst = torch.tensor([
            [
                [0.0, 0.0, 0.1],
                [2.1, 0.0, 0.0],
                [2.0, 2.1, 0.0],
                [0.1, 2.0, 0.0],
                [0.0, 0.0, 2.1],
                [2.1, 0.1, 2.0],
                [2.0, 2.1, 2.1],
                [0.1, 2.0, 2.0]
            ],
            [
                [1.1, 1.1, 0.0],
                [3.0, 1.1, 0.0],
                [3.1, 3.0, 0.0],
                [1.0, 3.1, 0.0],
                [1.1, 1.1, 2.0],
                [3.1, 1.0, 2.1],
                [3.0, 3.1, 2.0],
                [1.0, 3.0, 2.1]
            ]
        ])
        test_args = (src, dst)
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_perspective_transform3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_perspective_transform3d at 0x7fcbc354e7a0>
trace_args = (tensor([[[0., 0., 0.],
         [1., 0., 0.],
         [1., 1., 0.],
         [0., 1., 0.],
         [0., 0., 1.],
  ...0, 1.1000],
         [1.0000, 0.1000, 1.0000],
         [1.1000, 1.1000, 1.0000],
         [0.0000, 1.1000, 1.1000]]]))
trace_kwargs = {}
test_args = (tensor([[[0., 0., 0.],
         [2., 0., 0.],
         [2., 2., 0.],
         [0., 2., 0.],
         [0., 0., 2.],
  ...0, 2.0000],
         [3.1000, 1.0000, 2.1000],
         [3.0000, 3.1000, 2.0000],
         [1.0000, 3.0000, 2.1000]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_perspective_transform3d at 0x7fcbc354e7a0>
trace_args = (tensor([[[0., 0., 0.],
         [1., 0., 0.],
         [1., 1., 0.],
         [0., 1., 0.],
         [0., 0., 1.],
  ...0, 1.1000],
         [1.0000, 0.1000, 1.0000],
         [1.1000, 1.1000, 1.0000],
         [0.0000, 1.1000, 1.1000]]]))
trace_kwargs = {}
test_args = (tensor([[[0., 0., 0.],
         [2., 0., 0.],
         [2., 2., 0.],
         [0., 2., 0.],
         [0., 0., 2.],
  ...0, 2.0000],
         [3.1000, 1.0000, 2.1000],
         [3.0000, 3.1000, 2.0000],
         [1.0000, 3.0000, 2.1000]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_perspective_transform3d at 0x7fcbc354e7a0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.get_perspective_transform3d
_________________________________________________________________________ test_get_projective_transform[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_projective_transform(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[0., 0., 0.]]),
            torch.tensor([[30., 45., 60.]]),
            torch.tensor([[1., 1., 1.]])
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[1., 1., 1.]]),
            torch.tensor([[45., 60., 75.]]),
            torch.tensor([[1.5, 1.5, 1.5]])
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_projective_transform,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:744: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_projective_transform at 0x7fcbc354e710>, trace_args = (tensor([[0., 0., 0.]]), tensor([[30., 45., 60.]]), tensor([[1., 1., 1.]])), trace_kwargs = {}
test_args = (tensor([[1., 1., 1.]]), tensor([[45., 60., 75.]]), tensor([[1.5000, 1.5000, 1.5000]])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s'
skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_projective_transform at 0x7fcbc354e710>, trace_args = (tensor([[0., 0., 0.]]), tensor([[30., 45., 60.]]), tensor([[1., 1., 1.]])), trace_kwargs = {}
test_args = (tensor([[1., 1., 1.]]), tensor([[45., 60., 75.]]), tensor([[1.5000, 1.5000, 1.5000]])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_projective_transform at 0x7fcbc354e710>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.get_projective_transform
___________________________________________________________________________ test_get_rotation_matrix2d[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_rotation_matrix2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 2),
            45. * torch.ones(1),
            torch.rand(1, 2)
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(1, 2),
            90. * torch.ones(1),
            2.0 * torch.ones(1, 2)
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_rotation_matrix2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:770: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_rotation_matrix2d at 0x7fcbc354e0e0>, trace_args = (tensor([[0.2290, 0.9768]]), tensor([45.]), tensor([[0.0685, 0.2818]])), trace_kwargs = {}
test_args = (tensor([[0.9688, 0.5005]]), tensor([90.]), tensor([[2., 2.]])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_rotation_matrix2d at 0x7fcbc354e0e0>, trace_args = (tensor([[0.2290, 0.9768]]), tensor([45.]), tensor([[0.0685, 0.2818]])), trace_kwargs = {}
test_args = (tensor([[0.9688, 0.5005]]), tensor([90.]), tensor([[2., 2.]])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_rotation_matrix2d at 0x7fcbc354e0e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.get_rotation_matrix2d
____________________________________________________________________________ test_get_shear_matrix2d[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_shear_matrix2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[0., 0.]]),
            torch.tensor([1.0]),
            torch.tensor([0.5])
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[1., 1.]]),
            torch.tensor([1.5]),
            torch.tensor([0.75])
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_shear_matrix2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_shear_matrix2d at 0x7fcbc354e3b0>, trace_args = (tensor([[0., 0.]]), tensor([1.]), tensor([0.5000])), trace_kwargs = {}
test_args = (tensor([[1., 1.]]), tensor([1.5000]), tensor([0.7500])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_shear_matrix2d at 0x7fcbc354e3b0>, trace_args = (tensor([[0., 0.]]), tensor([1.]), tensor([0.5000])), trace_kwargs = {}
test_args = (tensor([[1., 1.]]), tensor([1.5000]), tensor([0.7500])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_shear_matrix2d at 0x7fcbc354e3b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.get_shear_matrix2d
____________________________________________________________________________ test_get_shear_matrix3d[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_shear_matrix3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[0., 0., 0.]]),
            torch.tensor([1.0]),
            torch.tensor([0.5]),
            torch.tensor([0.2]),
            torch.tensor([0.3]),
            torch.tensor([0.4]),
            torch.tensor([0.6])
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[1., 1., 1.]]),
            torch.tensor([1.5]),
            torch.tensor([0.75]),
            torch.tensor([0.4]),
            torch.tensor([0.5]),
            torch.tensor([0.6]),
            torch.tensor([0.8])
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_shear_matrix3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:830: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_shear_matrix3d at 0x7fcbc354e4d0>, trace_args = (tensor([[0., 0., 0.]]), tensor([1.]), tensor([0.5000]), tensor([0.2000]), tensor([0.3000]), tensor([0.4000]), ...)
trace_kwargs = {}, test_args = (tensor([[1., 1., 1.]]), tensor([1.5000]), tensor([0.7500]), tensor([0.4000]), tensor([0.5000]), tensor([0.6000]), ...), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_shear_matrix3d at 0x7fcbc354e4d0>, trace_args = (tensor([[0., 0., 0.]]), tensor([1.]), tensor([0.5000]), tensor([0.2000]), tensor([0.3000]), tensor([0.4000]), ...)
trace_kwargs = {}, test_args = (tensor([[1., 1., 1.]]), tensor([1.5000]), tensor([0.7500]), tensor([0.4000]), tensor([0.5000]), tensor([0.6000]), ...), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_shear_matrix3d at 0x7fcbc354e4d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.get_shear_matrix3d
____________________________________________________________________________ test_get_affine_matrix2d[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_affine_matrix2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[0., 0.]]),
            torch.tensor([[0., 0.]]),
            torch.ones(1, 2),
            45. * torch.ones(1),
            torch.tensor([1.0]),
            torch.tensor([0.5])
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[1., 1.]]),
            torch.tensor([[1., 1.]]),
            2.0 * torch.ones(1, 2),
            90. * torch.ones(1),
            torch.tensor([1.5]),
            torch.tensor([0.75])
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_affine_matrix2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:862: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_affine_matrix2d at 0x7fcbc354e290>, trace_args = (tensor([[0., 0.]]), tensor([[0., 0.]]), tensor([[1., 1.]]), tensor([45.]), tensor([1.]), tensor([0.5000])), trace_kwargs = {}
test_args = (tensor([[1., 1.]]), tensor([[1., 1.]]), tensor([[2., 2.]]), tensor([90.]), tensor([1.5000]), tensor([0.7500])), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_affine_matrix2d at 0x7fcbc354e290>, trace_args = (tensor([[0., 0.]]), tensor([[0., 0.]]), tensor([[1., 1.]]), tensor([45.]), tensor([1.]), tensor([0.5000])), trace_kwargs = {}
test_args = (tensor([[1., 1.]]), tensor([[1., 1.]]), tensor([[2., 2.]]), tensor([90.]), tensor([1.5000]), tensor([0.7500])), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_affine_matrix2d at 0x7fcbc354e290>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.get_affine_matrix2d
____________________________________________________________________________ test_get_affine_matrix3d[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_affine_matrix3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[0., 0., 0.]]),
            torch.tensor([[0., 0., 0.]]),
            torch.ones(1, 3),
            torch.tensor([[45., 45., 45.]]),
            torch.tensor([1.0]),
            torch.tensor([0.5]),
            torch.tensor([0.2]),
            torch.tensor([0.3]),
            torch.tensor([0.4]),
            torch.tensor([0.6])
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[1., 1., 1.]]),
            torch.tensor([[1., 1., 1.]]),
            2.0 * torch.ones(1, 3),
            torch.tensor([[90., 90., 90.]]),
            torch.tensor([1.5]),
            torch.tensor([0.75]),
            torch.tensor([0.4]),
            torch.tensor([0.5]),
            torch.tensor([0.6]),
            torch.tensor([0.8])
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_affine_matrix3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:902: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_affine_matrix3d at 0x7fcbc354e440>
trace_args = (tensor([[0., 0., 0.]]), tensor([[0., 0., 0.]]), tensor([[1., 1., 1.]]), tensor([[45., 45., 45.]]), tensor([1.]), tensor([0.5000]), ...), trace_kwargs = {}
test_args = (tensor([[1., 1., 1.]]), tensor([[1., 1., 1.]]), tensor([[2., 2., 2.]]), tensor([[90., 90., 90.]]), tensor([1.5000]), tensor([0.7500]), ...), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_affine_matrix3d at 0x7fcbc354e440>
trace_args = (tensor([[0., 0., 0.]]), tensor([[0., 0., 0.]]), tensor([[1., 1., 1.]]), tensor([[45., 45., 45.]]), tensor([1.]), tensor([0.5000]), ...), trace_kwargs = {}
test_args = (tensor([[1., 1., 1.]]), tensor([[1., 1., 1.]]), tensor([[2., 2., 2.]]), tensor([[90., 90., 90.]]), tensor([1.5000]), tensor([0.7500]), ...), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_affine_matrix3d at 0x7fcbc354e440>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.get_affine_matrix3d
__________________________________________________________________________ test_invert_affine_transform[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_invert_affine_transform(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 2, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 2, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.invert_affine_transform,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:924: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function invert_affine_transform at 0x7fcbc354e200>, trace_args = (tensor([[[0.8379, 0.7916, 0.9140],
         [0.3128, 0.1359, 0.8705]]]),), trace_kwargs = {}
test_args = (tensor([[[0.4822, 0.6488, 0.7340],
         [0.9951, 0.3367, 0.4438]],

        [[0.3532, 0.2716, 0.6592],
         [...0.6737],
         [0.0321, 0.0851, 0.9542]],

        [[0.5455, 0.9905, 0.9790],
         [0.3071, 0.1550, 0.3531]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function invert_affine_transform at 0x7fcbc354e200>, trace_args = (tensor([[[0.8379, 0.7916, 0.9140],
         [0.3128, 0.1359, 0.8705]]]),), trace_kwargs = {}
test_args = (tensor([[[0.4822, 0.6488, 0.7340],
         [0.9951, 0.3367, 0.4438]],

        [[0.3532, 0.2716, 0.6592],
         [...0.6737],
         [0.0321, 0.0851, 0.9542]],

        [[0.5455, 0.9905, 0.9790],
         [0.3071, 0.1550, 0.3531]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function invert_affine_transform at 0x7fcbc354e200>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.invert_affine_transform
____________________________________________________________________________ test_projection_from_Rt[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_projection_from_Rt(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 3),
            torch.rand(1, 3, 1),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 3),
            torch.rand(5, 3, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.projection_from_Rt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function projection_from_Rt at 0x7fcbc354e680>
trace_args = (tensor([[[0.1651, 0.1006, 0.1126],
         [0.1970, 0.4505, 0.1629],
         [0.3433, 0.2683, 0.3668]]]), tensor([[[0.4916],
         [0.5017],
         [0.2560]]])), trace_kwargs = {}
test_args = (tensor([[[0.0800, 0.9675, 0.7429],
         [0.8180, 0.0881, 0.4680],
         [0.3720, 0.5338, 0.4879]],

        [[...
        [[0.6351],
         [0.7518],
         [0.4666]],

        [[0.2784],
         [0.7581],
         [0.2528]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function projection_from_Rt at 0x7fcbc354e680>
trace_args = (tensor([[[0.1651, 0.1006, 0.1126],
         [0.1970, 0.4505, 0.1629],
         [0.3433, 0.2683, 0.3668]]]), tensor([[[0.4916],
         [0.5017],
         [0.2560]]])), trace_kwargs = {}
test_args = (tensor([[[0.0800, 0.9675, 0.7429],
         [0.8180, 0.0881, 0.4680],
         [0.3720, 0.5338, 0.4879]],

        [[...
        [[0.6351],
         [0.7518],
         [0.4666]],

        [[0.2784],
         [0.7581],
         [0.2528]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function projection_from_Rt at 0x7fcbc354e680>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.imgwarp.projection_from_Rt
_____________________________________________________________________________ test_get_tps_transform[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_tps_transform(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 5, 2),
            torch.rand(1, 5, 2),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 5, 2),
            torch.rand(5, 5, 2),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.get_tps_transform,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=3e-1,
            mode=mode,
        )

kornia/geometry/test_transform.py:972: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_tps_transform at 0x7fcbc3563130>
trace_args = (tensor([[[0.6796, 0.3986],
         [0.4386, 0.0070],
         [0.7234, 0.8625],
         [0.6642, 0.7589],
         ...0.7474],
         [0.9374, 0.5045],
         [0.1902, 0.3010],
         [0.8960, 0.2073],
         [0.2588, 0.9964]]]))
trace_kwargs = {}
test_args = (tensor([[[0.2902, 0.5052],
         [0.7159, 0.6262],
         [0.5046, 0.1810],
         [0.6506, 0.9585],
         ...0.3487],
         [0.2296, 0.0549],
         [0.9921, 0.5908],
         [0.2545, 0.5252],
         [0.1978, 0.8973]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.3, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_tps_transform at 0x7fcbc3563130>
trace_args = (tensor([[[0.6796, 0.3986],
         [0.4386, 0.0070],
         [0.7234, 0.8625],
         [0.6642, 0.7589],
         ...0.7474],
         [0.9374, 0.5045],
         [0.1902, 0.3010],
         [0.8960, 0.2073],
         [0.2588, 0.9964]]]))
trace_kwargs = {}
test_args = (tensor([[[0.2902, 0.5052],
         [0.7159, 0.6262],
         [0.5046, 0.1810],
         [0.6506, 0.9585],
         ...0.3487],
         [0.2296, 0.0549],
         [0.9921, 0.5908],
         [0.2545, 0.5252],
         [0.1978, 0.8973]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.3, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_tps_transform at 0x7fcbc3563130>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.thin_plate_spline.get_tps_transform
_______________________________________________________________________________ test_crop_by_boxes[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_crop_by_boxes(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3, 64, 64),
            torch.tensor([[[10, 10], [50, 10], [50, 50], [10, 50]]], dtype=torch.float32),
            torch.tensor([[[0, 0], [40, 0], [40, 40], [0, 40]]], dtype=torch.float32),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 64, 64),
            torch.tensor([[[10, 10], [50, 10], [50, 50], [10, 50]]]*5, dtype=torch.float32),
            torch.tensor([[[0, 0], [40, 0], [40, 40], [0, 40]]]*5, dtype=torch.float32),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.transform.crop_by_boxes,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_transform.py:1022: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function crop_by_boxes at 0x7fcbc3560310>
trace_args = (tensor([[[[8.8821e-01, 4.3065e-01, 5.7612e-01,  ..., 1.8394e-01,
           2.9286e-01, 5.8262e-01],
          [8.199...., 50.],
         [10., 50.]]]), tensor([[[ 0.,  0.],
         [40.,  0.],
         [40., 40.],
         [ 0., 40.]]]))
trace_kwargs = {}
test_args = (tensor([[[[7.6607e-01, 5.1741e-01, 4.7976e-01,  ..., 5.6764e-01,
           5.3581e-01, 4.4520e-01],
          [9.614...0., 40.],
         [ 0., 40.]],

        [[ 0.,  0.],
         [40.,  0.],
         [40., 40.],
         [ 0., 40.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function crop_by_boxes at 0x7fcbc3560310>
trace_args = (tensor([[[[8.8821e-01, 4.3065e-01, 5.7612e-01,  ..., 1.8394e-01,
           2.9286e-01, 5.8262e-01],
          [8.199...., 50.],
         [10., 50.]]]), tensor([[[ 0.,  0.],
         [40.,  0.],
         [40., 40.],
         [ 0., 40.]]]))
trace_kwargs = {}
test_args = (tensor([[[[7.6607e-01, 5.1741e-01, 4.7976e-01,  ..., 5.6764e-01,
           5.3581e-01, 4.4520e-01],
          [9.614...0., 40.],
         [ 0., 40.]],

        [[ 0.,  0.],
         [40.,  0.],
         [40., 40.],
         [ 0., 40.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function crop_by_boxes at 0x7fcbc3560310>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.crop2d.crop_by_boxes
_________________________________________________________________________________ test_Translate[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Translate(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.Translate")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledTranslate = ivy.transpile(kornia.geometry.transform.Translate, source="torch", target=target_framework)

kornia/geometry/test_transform.py:1110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.transform.affwarp.Translate'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.Translate
___________________________________________________________________________________ test_Shear[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Shear(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.Shear")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledShear = ivy.transpile(kornia.geometry.transform.Shear, source="torch", target=target_framework)
    
        x = torch.rand(2, 3, 4, 4)
        shear = torch.tensor([[0.5, 0.0], [0.0, 0.5]])
        torch_out = kornia.geometry.transform.Shear(shear)(x)
    
        transpiled_x = _nest_torch_tensor_to_new_framework(x, target_framework)
        transpiled_shear = _nest_torch_tensor_to_new_framework(shear, target_framework)
>       transpiled_out = TranspiledShear(transpiled_shear)(transpiled_x)

kornia/geometry/test_transform.py:1156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Shear()
args = (<tf.Tensor: shape=(2, 3, 4, 4), dtype=float32, numpy=
array([[[[0.70748186, 0.8076822 , 0.48968703, 0.95915234],
    ...983921 , 0.964077  , 0.19448984],
         [0.12815374, 0.68339336, 0.40818614, 0.813222  ]]]],
      dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x56269d03f6f0, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...ode_context=['        return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_Shear(), <tf.Tensor: shape=(2, 3, 4, 4), dtype=float32, numpy=
array([[[[0.70748186, 0.8076822 , 0.4896870...8983921 , 0.964077  , 0.19448984],
         [0.12815374, 0.68339336, 0.40818614, 0.813222  ]]]],
      dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Shear(), v = None, buffers = None
args = (<tf.Tensor: shape=(2, 3, 4, 4), dtype=float32, numpy=
array([[[[0.70748186, 0.8076822 , 0.48968703, 0.95915234],
    ...983921 , 0.964077  , 0.19448984],
         [0.12815374, 0.68339336, 0.40818614, 0.813222  ]]]],
      dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:1666: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_Shear(), <tf.Tensor: shape=(2, 3, 4, 4), dtype=float32, numpy=
array([[[[0.70748186, 0.8076822 , 0.4896870...8983921 , 0.964077  , 0.19448984],
         [0.12815374, 0.68339336, 0.40818614, 0.813222  ]]]],
      dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Shear(), v = None, buffers = None
args = (<tf.Tensor: shape=(2, 3, 4, 4), dtype=float32, numpy=
array([[[[0.70748186, 0.8076822 , 0.48968703, 0.95915234],
    ...983921 , 0.964077  , 0.19448984],
         [0.12815374, 0.68339336, 0.40818614, 0.813222  ]]]],
      dtype=float32)>,)
kwargs = {}
first_arr = <tf.Tensor: shape=(2, 3, 4, 4), dtype=float32, numpy=
array([[[[0.70748186, 0.8076822 , 0.48968703, 0.95915234],
     ....8983921 , 0.964077  , 0.19448984],
         [0.12815374, 0.68339336, 0.40818614, 0.813222  ]]]],
      dtype=float32)>
replace_v = False, replace_buffers = False, call_signature = <Signature (input)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Model, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Model, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Model, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:1438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_Shear(),)
kwargs = {'input': <tf.Tensor: shape=(2, 3, 4, 4), dtype=float32, numpy=
array([[[[0.70748186, 0.8076822 , 0.48968703, 0.959152...8983921 , 0.964077  , 0.19448984],
         [0.12815374, 0.68339336, 0.40818614, 0.813222  ]]]],
      dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Shear()
input = <tf.Tensor: shape=(2, 3, 4, 4), dtype=float32, numpy=
array([[[[0.70748186, 0.8076822 , 0.48968703, 0.95915234],
     ....8983921 , 0.964077  , 0.19448984],
         [0.12815374, 0.68339336, 0.40818614, 0.813222  ]]]],
      dtype=float32)>

    def call(self, input):
>       return shear(
            input, self.shear, self.mode, self.padding_mode, self.align_corners
        )
E       NameError: Exception encountered when calling tensorflow_Shear.call().
E       
E       [1mname 'shear' is not defined[0m
E       
E       Arguments received by tensorflow_Shear.call():
E          input=tf.Tensor(shape=(2, 3, 4, 4), dtype=float32)

Translated_Outputs/tensorflow_outputs/kornia/geometry/transform/affwarp.py:1083: NameError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.Shear

Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Shear from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
                                                                                                                                
Transpilation of Shear complete.
___________________________________________________________________________________ test_PyrUp[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PyrUp(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.PyrUp")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledPyrUp = ivy.transpile(kornia.geometry.transform.PyrUp, source="torch", target=target_framework)

kornia/geometry/test_transform.py:1184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.transform.pyramid.PyrUp'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.PyrUp
_______________________________________________________________________________ test_ScalePyramid[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ScalePyramid(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.ScalePyramid")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledScalePyramid = ivy.transpile(kornia.geometry.transform.ScalePyramid, source="torch", target=target_framework)

kornia/geometry/test_transform.py:1201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.transform.pyramid.ScalePyramid'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.ScalePyramid
___________________________________________________________________________________ test_Vflip[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Vflip(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.Vflip")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledVflip = ivy.transpile(kornia.geometry.transform.Vflip, source="torch", target=target_framework)

kornia/geometry/test_transform.py:1235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.transform.flips.Vflip'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.Vflip
__________________________________________________________________________________ test_Rot180[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Rot180(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.Rot180")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledRot180 = ivy.transpile(kornia.geometry.transform.Rot180, source="torch", target=target_framework)

kornia/geometry/test_transform.py:1252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.transform.flips.Rot180'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.Rot180
__________________________________________________________________________________ test_Rescale[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Rescale(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.Rescale")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledRescale = ivy.transpile(kornia.geometry.transform.Rescale, source="torch", target=target_framework)
    
        x = torch.rand(1, 3, 4, 4)
        torch_out = kornia.geometry.transform.Rescale((2.0, 3.0))(x)
    
        transpiled_x = _nest_torch_tensor_to_new_framework(x, target_framework)
        transpiled_out = TranspiledRescale((2.0, 3.0))(transpiled_x)
    
>       _to_numpy_and_allclose(torch_out, transpiled_out)

kornia/geometry/test_transform.py:1294: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0.7835, 0.7394, 0.6954, 0.6514, 0.6131, 0.5864, 0.5596, 0.5329,
           0.5933, 0.6973, 0.8013, 0.9053],...        [0.7926, 0.6374, 0.4821, 0.3268, 0.2197, 0.2089, 0.1980, 0.1872,
           0.2043, 0.2353, 0.2663, 0.2973]]]])
transpiled_x = <tf.Tensor: shape=(1, 3, 8, 12), dtype=float32, numpy=
array([[[[0.78346103, 0.78346103, 0.7296408 , 0.6758205 , 0.622...      0.21005268, 0.1968427 , 0.18363273, 0.22151674, 0.25940073,
          0.29728472, 0.29728472]]]], dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0.78346103, 0.7394263 , 0.69539154, 0.65135676, 0.6130908 ,
          0.5863625 , 0.55963415, 0.5329058 , 0....       0.20885178, 0.19804361, 0.18723544, 0.20429674, 0.23529273,
          0.26628873, 0.29728472]]]], dtype=float32)
y = array([[[[0.78346103, 0.78346103, 0.7296408 , 0.6758205 , 0.6220003 ,
          0.58933234, 0.55666435, 0.5239964 , 0....       0.21005268, 0.1968427 , 0.18363273, 0.22151674, 0.25940073,
          0.29728472, 0.29728472]]]], dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.Rescale

Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Rescale from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                  
Transpilation of Rescale complete.
________________________________________________________________________________ test_Homography[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Homography(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.Homography")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledHomography = ivy.transpile(
            kornia.geometry.transform.image_registrator.Homography, source="torch", target=target_framework
        )
    
        torch_out = kornia.geometry.transform.image_registrator.Homography()()
>       transpiled_out = TranspiledHomography()()

kornia/geometry/test_transform.py:1354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Homography(<tf.Variable 'Variable:0' shape=(3, 3) dtype=float32, numpy=
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]], dtype=float32)>), args = (), kwargs = {}
stack = [FrameInfo(frame=<frame at 0x56269e879020, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...ode_context=['        return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_Homography(<tf.Variable 'Variable:0' shape=(3, 3) dtype=float32, numpy=
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]], dtype=float32)>),), kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Homography(<tf.Variable 'Variable:0' shape=(3, 3) dtype=float32, numpy=
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]], dtype=float32)>), v = None, buffers = None
args = (), kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_Homography(<tf.Variable 'Variable:0' shape=(3, 3) dtype=float32, numpy=
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]], dtype=float32)>),)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Homography(<tf.Variable 'Variable:0' shape=(3, 3) dtype=float32, numpy=
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]], dtype=float32)>), v = None, buffers = None
args = (), kwargs = {}, first_arr = None, replace_v = False, replace_buffers = False, call_signature = <Signature ()>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_Homography(<tf.Variable 'Variable:0' shape=(3, 3) dtype=float32, numpy=
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]], dtype=float32)>),), kwargs = {}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <keras.src.layers.layer.CallSpec object at 0x7fcbbc850fd0>, signature = <Signature ()>, args = (), kwargs = {}

    def __init__(self, signature, args, kwargs):
        # `training` and `mask` are special kwargs that are always available in
        # a layer, if user specifies them in their call without adding to spec,
        # we remove them to be able to bind variables. User is not using
        # `training` anyway so we can ignore.
        # TODO: If necessary use workaround for `mask`
        if "training" in kwargs and "training" not in signature.parameters:
            kwargs.pop("training")
            bound_args = signature.bind(*args, **kwargs)
        else:
            bound_args = signature.bind(*args, **kwargs)
        self.user_arguments_dict = {
            k: v for k, v in bound_args.arguments.items()
        }
        bound_args.apply_defaults()
        arg_dict = {}
        arg_names = []
        tensor_arg_dict = {}
        tensor_args = []
        tensor_arg_names = []
        nested_tensor_arg_names = []
        for name, value in bound_args.arguments.items():
            arg_dict[name] = value
            arg_names.append(name)
            if is_backend_tensor_or_symbolic(value):
                tensor_args.append(value)
                tensor_arg_names.append(name)
                tensor_arg_dict[name] = value
            elif tree.is_nested(value) and len(value) > 0:
                flat_values = tree.flatten(value)
                if all(
                    is_backend_tensor_or_symbolic(x, allow_none=True)
                    for x in flat_values
                ):
                    tensor_args.append(value)
                    tensor_arg_names.append(name)
                    tensor_arg_dict[name] = value
                    nested_tensor_arg_names.append(name)
                elif any(is_backend_tensor_or_symbolic(x) for x in flat_values):
                    raise ValueError(
                        "In a nested call() argument, "
                        "you cannot mix tensors and non-tensors. "
                        "Received invalid mixed argument: "
                        f"{name}={value}"
                    )
        self.arguments_dict = arg_dict
        self.argument_names = arg_names
        self.tensor_arguments_dict = tensor_arg_dict
        self.tensor_arguments_names = tensor_arg_names
        self.nested_tensor_argument_names = nested_tensor_arg_names
>       self.first_arg = arg_dict[arg_names[0]]
E       IndexError: list index out of range

/opt/fw/tensorflow/keras/src/layers/layer.py:1614: IndexError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.Homography

Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Homography from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
                                                                                                                                     
Transpilation of Homography complete.
_____________________________________________________________________________ test_ImageRegistrator[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ImageRegistrator(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.ImageRegistrator")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledImageRegistrator = ivy.transpile(
            kornia.geometry.transform.ImageRegistrator, source="torch", target=target_framework
        )

kornia/geometry/test_transform.py:1365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.transform.image_registrator.ImageRegistrator'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.ImageRegistrator
________________________________________________________________________________ test_Similarity[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Similarity(target_framework, mode, backend_compile):
        print("kornia.geometry.transform.Similarity")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSimilarity = ivy.transpile(
            kornia.geometry.transform.image_registrator.Similarity, source="torch", target=target_framework
        )

kornia/geometry/test_transform.py:1386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.transform.image_registrator.Similarity'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.transform.Similarity
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_transform.py::test_warp_perspective[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/geometry/test_transform.py::test_warp_perspective3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensur...
FAILED kornia/geometry/test_transform.py::test_warp_points_tps[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure y...
FAILED kornia/geometry/test_transform.py::test_warp_grid[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/geometry/test_transform.py::test_rotate[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/geometry/test_transform.py::test_shear[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/geometry/test_transform.py::test_hflip[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/geometry/test_transform.py::test_rot180[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/geometry/test_transform.py::test_resize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/geometry/test_transform.py::test_rescale[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
FAILED kornia/geometry/test_transform.py::test_elastic_transform2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/geometry/test_transform.py::test_pyrdown[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
FAILED kornia/geometry/test_transform.py::test_pyrup[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/geometry/test_transform.py::test_build_pyramid[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/geometry/test_transform.py::test_build_laplacian_pyramid[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/geometry/test_transform.py::test_upscale_double[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/geometry/test_transform.py::test_get_perspective_transform[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key...
FAILED kornia/geometry/test_transform.py::test_get_perspective_transform3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api k...
FAILED kornia/geometry/test_transform.py::test_get_projective_transform[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key,...
FAILED kornia/geometry/test_transform.py::test_get_rotation_matrix2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, en...
FAILED kornia/geometry/test_transform.py::test_get_shear_matrix2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensur...
FAILED kornia/geometry/test_transform.py::test_get_shear_matrix3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensur...
FAILED kornia/geometry/test_transform.py::test_get_affine_matrix2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/geometry/test_transform.py::test_get_affine_matrix3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/geometry/test_transform.py::test_invert_affine_transform[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/geometry/test_transform.py::test_projection_from_Rt[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensur...
FAILED kornia/geometry/test_transform.py::test_get_tps_transform[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/geometry/test_transform.py::test_crop_by_boxes[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/geometry/test_transform.py::test_Translate[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/geometry/test_transform.py::test_Shear[tensorflow-s2s-False] - NameError: Exception encountered when calling tensorflow_Shear.call().
FAILED kornia/geometry/test_transform.py::test_PyrUp[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/geometry/test_transform.py::test_ScalePyramid[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you ...
FAILED kornia/geometry/test_transform.py::test_Vflip[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/geometry/test_transform.py::test_Rot180[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/geometry/test_transform.py::test_Rescale[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/geometry/test_transform.py::test_Homography[tensorflow-s2s-False] - IndexError: list index out of range
FAILED kornia/geometry/test_transform.py::test_ImageRegistrator[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/geometry/test_transform.py::test_Similarity[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do...
============================================================================== 38 failed, 19 passed in 588.54s (0:09:48) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 39 items

kornia/test_enhance.py F.FFFFF.F...F.F.F.FFFFFF.FFFFFFF...F.FF                                                                                                                                   [100%]

=============================================================================================== FAILURES ===============================================================================================
_______________________________________________________________________________ test_add_weighted[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_add_weighted(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 5, 5),
            0.5,
            torch.rand(1, 1, 5, 5),
            0.5,
            1.0,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 5, 5),
            0.7,
            torch.rand(5, 1, 5, 5),
            0.8,
            0.8,
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.add_weighted,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function add_weighted at 0x7f042f2f0550>
trace_args = (tensor([[[[0.6282, 0.5548, 0.6492, 0.7105, 0.5422],
          [0.4822, 0.4076, 0.8832, 0.9259, 0.7809],
          [0....,
          [0.7385, 0.8509, 0.1035, 0.7383, 0.4125],
          [0.0226, 0.8331, 0.1334, 0.4641, 0.4899]]]]), 0.5, 1.0)
trace_kwargs = {}
test_args = (tensor([[[[0.5699, 0.6063, 0.6838, 0.2844, 0.0124],
          [0.1332, 0.9801, 0.2375, 0.7211, 0.3443],
          [0....,
          [0.5245, 0.4305, 0.7246, 0.6887, 0.8730],
          [0.1656, 0.6382, 0.6781, 0.5763, 0.2172]]]]), 0.8, 0.8)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function add_weighted at 0x7f042f2f0550>
trace_args = (tensor([[[[0.6282, 0.5548, 0.6492, 0.7105, 0.5422],
          [0.4822, 0.4076, 0.8832, 0.9259, 0.7809],
          [0....,
          [0.7385, 0.8509, 0.1035, 0.7383, 0.4125],
          [0.0226, 0.8331, 0.1334, 0.4641, 0.4899]]]]), 0.5, 1.0)
trace_kwargs = {}
test_args = (tensor([[[[0.5699, 0.6063, 0.6838, 0.2844, 0.0124],
          [0.1332, 0.9801, 0.2375, 0.7211, 0.3443],
          [0....,
          [0.5245, 0.4305, 0.7246, 0.6887, 0.8730],
          [0.1656, 0.6382, 0.6781, 0.5763, 0.2172]]]]), 0.8, 0.8)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function add_weighted at 0x7f042f2f0550>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.core.add_weighted
______________________________________________________________________________ test_adjust_contrast[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_adjust_contrast(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 2, 2),
            2.0,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 2, 2),
            0.5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.adjust_contrast,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_contrast at 0x7f042f2d6a70>, trace_args = (tensor([[[[0.0406, 0.3860],
          [0.8202, 0.6903]]]]), 2.0), trace_kwargs = {}
test_args = (tensor([[[[0.6727, 0.8721],
          [0.5772, 0.7296]]],


        [[[0.9169, 0.3469],
          [0.9877, 0.0903]]],...   [[[0.6563, 0.4478],
          [0.3573, 0.9750]]],


        [[[0.6433, 0.4558],
          [0.2716, 0.4448]]]]), 0.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_contrast at 0x7f042f2d6a70>, trace_args = (tensor([[[[0.0406, 0.3860],
          [0.8202, 0.6903]]]]), 2.0), trace_kwargs = {}
test_args = (tensor([[[[0.6727, 0.8721],
          [0.5772, 0.7296]]],


        [[[0.9169, 0.3469],
          [0.9877, 0.0903]]],...   [[[0.6563, 0.4478],
          [0.3573, 0.9750]]],


        [[[0.6433, 0.4558],
          [0.2716, 0.4448]]]]), 0.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function adjust_contrast at 0x7f042f2d6a70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.adjust.adjust_contrast
___________________________________________________________________ test_adjust_contrast_with_mean_subtraction[tensorflow-s2s-False] ___________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_adjust_contrast_with_mean_subtraction(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 2, 2),
            2.0,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 2, 2),
            0.5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.adjust_contrast_with_mean_subtraction,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_contrast_with_mean_subtraction at 0x7f042f2d6b00>, trace_args = (tensor([[[[0.1849, 0.6825],
          [0.5260, 0.5794]]]]), 2.0), trace_kwargs = {}
test_args = (tensor([[[[0.5260, 0.5847],
          [0.5660, 0.0153]]],


        [[[0.6720, 0.5411],
          [0.9559, 0.3125]]],...   [[[0.3200, 0.8708],
          [0.9933, 0.5257]]],


        [[[0.5354, 0.0694],
          [0.0181, 0.5455]]]]), 0.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_contrast_with_mean_subtraction at 0x7f042f2d6b00>, trace_args = (tensor([[[[0.1849, 0.6825],
          [0.5260, 0.5794]]]]), 2.0), trace_kwargs = {}
test_args = (tensor([[[[0.5260, 0.5847],
          [0.5660, 0.0153]]],


        [[[0.6720, 0.5411],
          [0.9559, 0.3125]]],...   [[[0.3200, 0.8708],
          [0.9933, 0.5257]]],


        [[[0.5354, 0.0694],
          [0.0181, 0.5455]]]]), 0.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function adjust_contrast_with_mean_subtraction at 0x7f042f2d6b00>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.adjust.adjust_contrast_with_mean_subtraction
_______________________________________________________________________________ test_adjust_gamma[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_adjust_gamma(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 2, 2),
            2.2,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 2, 2),
            0.4,
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.adjust_gamma,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_gamma at 0x7f042f2d69e0>, trace_args = (tensor([[[[0.1257, 0.8003],
          [0.7453, 0.8415]]]]), 2.2), trace_kwargs = {}
test_args = (tensor([[[[0.9989, 0.9169],
          [0.1133, 0.8864]]],


        [[[0.7938, 0.2761],
          [0.3864, 0.2261]]],...   [[[0.2057, 0.8221],
          [0.6649, 0.2711]]],


        [[[0.9353, 0.3158],
          [0.2816, 0.0200]]]]), 0.4)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_gamma at 0x7f042f2d69e0>, trace_args = (tensor([[[[0.1257, 0.8003],
          [0.7453, 0.8415]]]]), 2.2), trace_kwargs = {}
test_args = (tensor([[[[0.9989, 0.9169],
          [0.1133, 0.8864]]],


        [[[0.7938, 0.2761],
          [0.3864, 0.2261]]],...   [[[0.2057, 0.8221],
          [0.6649, 0.2711]]],


        [[[0.9353, 0.3158],
          [0.2816, 0.0200]]]]), 0.4)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function adjust_gamma at 0x7f042f2d69e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.adjust.adjust_gamma
________________________________________________________________________________ test_adjust_hue[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_adjust_hue(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 2, 2),
            0.5,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 2, 2),
            -0.2,
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.adjust_hue,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_hue at 0x7f042f2d6950>
trace_args = (tensor([[[[0.5897, 0.6468],
          [0.1530, 0.5222]],

         [[0.9884, 0.0133],
          [0.0569, 0.6605]],

         [[0.3835, 0.2762],
          [0.5330, 0.5179]]]]), 0.5)
trace_kwargs = {}
test_args = (tensor([[[[0.0155, 0.7620],
          [0.7609, 0.1453]],

         [[0.5813, 0.3932],
          [0.1571, 0.3329]],

 ...     [[0.7511, 0.8197],
          [0.5717, 0.1482]],

         [[0.1261, 0.3992],
          [0.2643, 0.5114]]]]), -0.2)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_hue at 0x7f042f2d6950>
trace_args = (tensor([[[[0.5897, 0.6468],
          [0.1530, 0.5222]],

         [[0.9884, 0.0133],
          [0.0569, 0.6605]],

         [[0.3835, 0.2762],
          [0.5330, 0.5179]]]]), 0.5)
trace_kwargs = {}
test_args = (tensor([[[[0.0155, 0.7620],
          [0.7609, 0.1453]],

         [[0.5813, 0.3932],
          [0.1571, 0.3329]],

 ...     [[0.7511, 0.8197],
          [0.5717, 0.1482]],

         [[0.1261, 0.3992],
          [0.2643, 0.5114]]]]), -0.2)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function adjust_hue at 0x7f042f2d6950>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.adjust.adjust_hue
_____________________________________________________________________________ test_adjust_saturation[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_adjust_saturation(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 2, 2),
            0.5,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 2, 2),
            1.5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.adjust_saturation,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_saturation at 0x7f042f2d6830>
trace_args = (tensor([[[[0.2859, 0.6228],
          [0.2907, 0.9364]],

         [[0.6859, 0.6140],
          [0.8791, 0.3657]],

         [[0.6472, 0.2757],
          [0.4755, 0.7787]]]]), 0.5)
trace_kwargs = {}
test_args = (tensor([[[[0.0350, 0.5421],
          [0.2454, 0.8714]],

         [[0.8533, 0.9361],
          [0.3379, 0.5276]],

 ...      [[0.2300, 0.2440],
          [0.7756, 0.8552]],

         [[0.3249, 0.8156],
          [0.2500, 0.5033]]]]), 1.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_saturation at 0x7f042f2d6830>
trace_args = (tensor([[[[0.2859, 0.6228],
          [0.2907, 0.9364]],

         [[0.6859, 0.6140],
          [0.8791, 0.3657]],

         [[0.6472, 0.2757],
          [0.4755, 0.7787]]]]), 0.5)
trace_kwargs = {}
test_args = (tensor([[[[0.0350, 0.5421],
          [0.2454, 0.8714]],

         [[0.8533, 0.9361],
          [0.3379, 0.5276]],

 ...      [[0.2300, 0.2440],
          [0.7756, 0.8552]],

         [[0.3249, 0.8156],
          [0.2500, 0.5033]]]]), 1.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function adjust_saturation at 0x7f042f2d6830>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.adjust.adjust_saturation
________________________________________________________________________________ test_adjust_log[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_adjust_log(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 2, 2),
            0.5,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 2, 2),
            1.2,
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.adjust_log,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_log at 0x7f042f2d6d40>, trace_args = (tensor([[[[0.8555, 0.2128],
          [0.8068, 0.0148]]]]), 0.5), trace_kwargs = {}
test_args = (tensor([[[[0.4555, 0.8945],
          [0.7685, 0.4384]]],


        [[[0.3055, 0.7324],
          [0.6789, 0.9195]]],...   [[[0.2134, 0.4034],
          [0.6003, 0.8160]]],


        [[[0.6797, 0.1480],
          [0.8332, 0.7551]]]]), 1.2)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function adjust_log at 0x7f042f2d6d40>, trace_args = (tensor([[[[0.8555, 0.2128],
          [0.8068, 0.0148]]]]), 0.5), trace_kwargs = {}
test_args = (tensor([[[[0.4555, 0.8945],
          [0.7685, 0.4384]]],


        [[[0.3055, 0.7324],
          [0.6789, 0.9195]]],...   [[[0.2134, 0.4034],
          [0.6003, 0.8160]]],


        [[[0.6797, 0.1480],
          [0.8332, 0.7551]]]]), 1.2)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function adjust_log at 0x7f042f2d6d40>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.adjust.adjust_log
_________________________________________________________________________________ test_solarize[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_solarize(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 2, 2),
            0.5,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 2, 2),
            0.7,
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.solarize,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function solarize at 0x7f042f2d6e60>, trace_args = (tensor([[[[0.7498, 0.7621],
          [0.1381, 0.9371]]]]), 0.5), trace_kwargs = {}
test_args = (tensor([[[[0.5573, 0.2312],
          [0.8145, 0.2665]]],


        [[[0.9424, 0.8902],
          [0.9984, 0.6960]]],...   [[[0.3682, 0.9366],
          [0.2075, 0.2953]]],


        [[[0.0291, 0.6628],
          [0.4036, 0.0731]]]]), 0.7)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function solarize at 0x7f042f2d6e60>, trace_args = (tensor([[[[0.7498, 0.7621],
          [0.1381, 0.9371]]]]), 0.5), trace_kwargs = {}
test_args = (tensor([[[[0.5573, 0.2312],
          [0.8145, 0.2665]]],


        [[[0.9424, 0.8902],
          [0.9984, 0.6960]]],...   [[[0.3682, 0.9366],
          [0.2075, 0.2953]]],


        [[[0.0291, 0.6628],
          [0.4036, 0.0731]]]]), 0.7)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function solarize at 0x7f042f2d6e60>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.adjust.solarize
______________________________________________________________________________ test_equalize_clahe[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_equalize_clahe(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 10, 20),)
        trace_kwargs = {
            "clip_limit": 40.0,
            "grid_size": (8, 8),
            "slow_and_differentiable": False,
        }
        test_args = (torch.rand(2, 3, 10, 20),)
        test_kwargs = {
            "clip_limit": 20.0,
            "grid_size": (4, 4),
            "slow_and_differentiable": False,
        }
>       _test_function(
            kornia.enhance.equalize_clahe,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            skip=True,
        )

kornia/test_enhance.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function equalize_clahe at 0x7f042f2f1360>
trace_args = (tensor([[[2.9321e-01, 1.0465e-01, 3.3161e-01, 1.6930e-02, 8.6774e-02,
          2.3040e-01, 6.9806e-01, 7.9366e-01, 2...965e-01, 8.3457e-01, 8.7166e-01, 7.2780e-01,
          6.1915e-01, 8.5334e-01, 9.1864e-02, 8.9938e-01, 1.6026e-01]]]),)
trace_kwargs = {'clip_limit': 40.0, 'grid_size': (8, 8), 'slow_and_differentiable': False}
test_args = (tensor([[[[0.8802, 0.5225, 0.2227,  ..., 0.0822, 0.2843, 0.8434],
          [0.8682, 0.7177, 0.5875,  ..., 0.9752, 0...., 0.5351, 0.4620,  ..., 0.1995, 0.2286, 0.1223],
          [0.8763, 0.4990, 0.8017,  ..., 0.4976, 0.4076, 0.8558]]]]),)
test_kwargs = {'clip_limit': 20.0, 'grid_size': (4, 4), 'slow_and_differentiable': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = True
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function equalize_clahe at 0x7f042f2f1360>
trace_args = (tensor([[[2.9321e-01, 1.0465e-01, 3.3161e-01, 1.6930e-02, 8.6774e-02,
          2.3040e-01, 6.9806e-01, 7.9366e-01, 2...965e-01, 8.3457e-01, 8.7166e-01, 7.2780e-01,
          6.1915e-01, 8.5334e-01, 9.1864e-02, 8.9938e-01, 1.6026e-01]]]),)
trace_kwargs = {'clip_limit': 40.0, 'grid_size': (8, 8), 'slow_and_differentiable': False}
test_args = (tensor([[[[0.8802, 0.5225, 0.2227,  ..., 0.0822, 0.2843, 0.8434],
          [0.8682, 0.7177, 0.5875,  ..., 0.9752, 0...., 0.5351, 0.4620,  ..., 0.1995, 0.2286, 0.1223],
          [0.8763, 0.4990, 0.8017,  ..., 0.4976, 0.4076, 0.8558]]]]),)
test_kwargs = {'clip_limit': 20.0, 'grid_size': (4, 4), 'slow_and_differentiable': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function equalize_clahe at 0x7f042f2f1360>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.equalization.equalize_clahe
_________________________________________________________________________________ test_histogram[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_histogram(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 10),
            torch.linspace(0, 255, 128),
            torch.tensor(0.9),
        )
        trace_kwargs = {"epsilon": 1e-10}
        test_args = (
            torch.rand(5, 10),
            torch.linspace(0, 255, 128),
            torch.tensor(0.9),
        )
        test_kwargs = {"epsilon": 1e-10}
>       _test_function(
            kornia.enhance.histogram,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function histogram at 0x7f042f2f0dc0>
trace_args = (tensor([[0.3627, 0.4365, 0.7962, 0.4736, 0.0763, 0.7398, 0.2994, 0.0615, 0.4784,
         0.4696]]), tensor([  0.0000...    238.9370, 240.9449, 242.9528, 244.9606, 246.9685, 248.9764, 250.9843,
        252.9921, 255.0000]), tensor(0.9000))
trace_kwargs = {'epsilon': 1e-10}
test_args = (tensor([[0.0173, 0.1210, 0.6408, 0.4188, 0.1225, 0.2115, 0.6171, 0.3006, 0.5116,
         0.6839],
        [0.7098, 0...    238.9370, 240.9449, 242.9528, 244.9606, 246.9685, 248.9764, 250.9843,
        252.9921, 255.0000]), tensor(0.9000))
test_kwargs = {'epsilon': 1e-10}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function histogram at 0x7f042f2f0dc0>
trace_args = (tensor([[0.3627, 0.4365, 0.7962, 0.4736, 0.0763, 0.7398, 0.2994, 0.0615, 0.4784,
         0.4696]]), tensor([  0.0000...    238.9370, 240.9449, 242.9528, 244.9606, 246.9685, 248.9764, 250.9843,
        252.9921, 255.0000]), tensor(0.9000))
trace_kwargs = {'epsilon': 1e-10}
test_args = (tensor([[0.0173, 0.1210, 0.6408, 0.4188, 0.1225, 0.2115, 0.6171, 0.3006, 0.5116,
         0.6839],
        [0.7098, 0...    238.9370, 240.9449, 242.9528, 244.9606, 246.9685, 248.9764, 250.9843,
        252.9921, 255.0000]), tensor(0.9000))
test_kwargs = {'epsilon': 1e-10}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function histogram at 0x7f042f2f0dc0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.histogram.histogram
_____________________________________________________________________________ test_image_histogram2d[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_image_histogram2d(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 1, 10, 10),)
        trace_kwargs = {
            "min": 0.0,
            "max": 255.0,
            "n_bins": 256,
            "bandwidth": None,
            "centers": None,
            "return_pdf": False,
            "kernel": "triangular",
            "eps": 1e-10,
        }
        test_args = (torch.rand(5, 1, 10, 10),)
        test_kwargs = {
            "min": 0.0,
            "max": 255.0,
            "n_bins": 256,
            "bandwidth": None,
            "centers": None,
            "return_pdf": False,
            "kernel": "triangular",
            "eps": 1e-10,
        }
>       _test_function(
            kornia.enhance.image_histogram2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:474: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function image_histogram2d at 0x7f042f2f0f70>
trace_args = (tensor([[[[0.9611, 0.1339, 0.3429, 0.5649, 0.2569, 0.8017, 0.4945, 0.5550,
           0.8599, 0.7584],
          [0.3...4, 0.0394],
          [0.8509, 0.1566, 0.3772, 0.7422, 0.4904, 0.0807, 0.3174, 0.9484,
           0.3495, 0.0073]]]]),)
trace_kwargs = {'bandwidth': None, 'centers': None, 'eps': 1e-10, 'kernel': 'triangular', ...}
test_args = (tensor([[[[0.7412, 0.5649, 0.4558, 0.9400, 0.1863, 0.8177, 0.3444, 0.4632,
           0.5010, 0.9359],
          [0.5...0, 0.6703],
          [0.2781, 0.3357, 0.7954, 0.0038, 0.9408, 0.2643, 0.5505, 0.0412,
           0.7253, 0.0510]]]]),)
test_kwargs = {'bandwidth': None, 'centers': None, 'eps': 1e-10, 'kernel': 'triangular', ...}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function image_histogram2d at 0x7f042f2f0f70>
trace_args = (tensor([[[[0.9611, 0.1339, 0.3429, 0.5649, 0.2569, 0.8017, 0.4945, 0.5550,
           0.8599, 0.7584],
          [0.3...4, 0.0394],
          [0.8509, 0.1566, 0.3772, 0.7422, 0.4904, 0.0807, 0.3174, 0.9484,
           0.3495, 0.0073]]]]),)
trace_kwargs = {'bandwidth': None, 'centers': None, 'eps': 1e-10, 'kernel': 'triangular', ...}
test_args = (tensor([[[[0.7412, 0.5649, 0.4558, 0.9400, 0.1863, 0.8177, 0.3444, 0.4632,
           0.5010, 0.9359],
          [0.5...0, 0.6703],
          [0.2781, 0.3357, 0.7954, 0.0038, 0.9408, 0.2643, 0.5505, 0.0412,
           0.7253, 0.0510]]]]),)
test_kwargs = {'bandwidth': None, 'centers': None, 'eps': 1e-10, 'kernel': 'triangular', ...}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function image_histogram2d at 0x7f042f2f0f70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.histogram.image_histogram2d
_________________________________________________________________________________ test_normalize[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_normalize(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
            torch.tensor([0.5, 0.5, 0.5]),
            torch.tensor([0.5, 0.5, 0.5]),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 4),
            torch.tensor([0.4, 0.4, 0.4]),
            torch.tensor([0.6, 0.6, 0.6]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.normalize,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:500: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function normalize at 0x7f042f2f2a70>
trace_args = (tensor([[[[0.6312, 0.3979, 0.8126, 0.7629],
          [0.5506, 0.8813, 0.3587, 0.3450],
          [0.3584, 0.3329, 0....3],
          [0.3033, 0.6758, 0.6834, 0.4539]]]]), tensor([0.5000, 0.5000, 0.5000]), tensor([0.5000, 0.5000, 0.5000]))
trace_kwargs = {}
test_args = (tensor([[[[0.1448, 0.3381, 0.9605, 0.0027],
          [0.8894, 0.1204, 0.0395, 0.3726],
          [0.2000, 0.2876, 0....6],
          [0.6931, 0.5302, 0.4918, 0.2827]]]]), tensor([0.4000, 0.4000, 0.4000]), tensor([0.6000, 0.6000, 0.6000]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function normalize at 0x7f042f2f2a70>
trace_args = (tensor([[[[0.6312, 0.3979, 0.8126, 0.7629],
          [0.5506, 0.8813, 0.3587, 0.3450],
          [0.3584, 0.3329, 0....3],
          [0.3033, 0.6758, 0.6834, 0.4539]]]]), tensor([0.5000, 0.5000, 0.5000]), tensor([0.5000, 0.5000, 0.5000]))
trace_kwargs = {}
test_args = (tensor([[[[0.1448, 0.3381, 0.9605, 0.0027],
          [0.8894, 0.1204, 0.0395, 0.3726],
          [0.2000, 0.2876, 0....6],
          [0.6931, 0.5302, 0.4918, 0.2827]]]]), tensor([0.4000, 0.4000, 0.4000]), tensor([0.6000, 0.6000, 0.6000]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function normalize at 0x7f042f2f2a70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.normalize.normalize
_____________________________________________________________________________ test_normalize_min_max[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_normalize_min_max(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 3, 4, 4), 0.0, 1.0)
        trace_kwargs = {}
        test_args = (torch.rand(5, 3, 4, 4), -1.0, 1.0)
        test_kwargs = {}
>       _test_function(
            kornia.enhance.normalize_min_max,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function normalize_min_max at 0x7f042f2f2ef0>
trace_args = (tensor([[[[0.2857, 0.6732, 0.7227, 0.8019],
          [0.4039, 0.4635, 0.6105, 0.1840],
          [0.1634, 0.6111, 0.... 0.7113, 0.7022],
          [0.9477, 0.1059, 0.1913, 0.0319],
          [0.9931, 0.7653, 0.8240, 0.1321]]]]), 0.0, 1.0)
trace_kwargs = {}
test_args = (tensor([[[[0.9495, 0.1222, 0.6392, 0.6514],
          [0.8874, 0.1301, 0.2464, 0.3034],
          [0.2319, 0.5626, 0....0.8205, 0.4051],
          [0.8056, 0.9050, 0.1750, 0.1648],
          [0.2832, 0.3833, 0.2779, 0.2062]]]]), -1.0, 1.0)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function normalize_min_max at 0x7f042f2f2ef0>
trace_args = (tensor([[[[0.2857, 0.6732, 0.7227, 0.8019],
          [0.4039, 0.4635, 0.6105, 0.1840],
          [0.1634, 0.6111, 0.... 0.7113, 0.7022],
          [0.9477, 0.1059, 0.1913, 0.0319],
          [0.9931, 0.7653, 0.8240, 0.1321]]]]), 0.0, 1.0)
trace_kwargs = {}
test_args = (tensor([[[[0.9495, 0.1222, 0.6392, 0.6514],
          [0.8874, 0.1301, 0.2464, 0.3034],
          [0.2319, 0.5626, 0....0.8205, 0.4051],
          [0.8056, 0.9050, 0.1750, 0.1648],
          [0.2832, 0.3833, 0.2779, 0.2062]]]]), -1.0, 1.0)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function normalize_min_max at 0x7f042f2f2ef0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.normalize.normalize_min_max
________________________________________________________________________________ test_denormalize[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_denormalize(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
            torch.tensor([0.5, 0.5, 0.5]),
            torch.tensor([0.5, 0.5, 0.5]),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 4),
            torch.tensor([0.4, 0.4, 0.4]),
            torch.tensor([0.6, 0.6, 0.6]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.enhance.denormalize,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:544: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function denormalize at 0x7f042f2f2cb0>
trace_args = (tensor([[[[0.3491, 0.0820, 0.9448, 0.6213],
          [0.2698, 0.1473, 0.7884, 0.3009],
          [0.2744, 0.8607, 0....2],
          [0.7197, 0.5581, 0.3377, 0.0089]]]]), tensor([0.5000, 0.5000, 0.5000]), tensor([0.5000, 0.5000, 0.5000]))
trace_kwargs = {}
test_args = (tensor([[[[0.8864, 0.0065, 0.3471, 0.5323],
          [0.0510, 0.5979, 0.4710, 0.6523],
          [0.6225, 0.7469, 0....1],
          [0.5885, 0.1941, 0.3683, 0.7241]]]]), tensor([0.4000, 0.4000, 0.4000]), tensor([0.6000, 0.6000, 0.6000]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function denormalize at 0x7f042f2f2cb0>
trace_args = (tensor([[[[0.3491, 0.0820, 0.9448, 0.6213],
          [0.2698, 0.1473, 0.7884, 0.3009],
          [0.2744, 0.8607, 0....2],
          [0.7197, 0.5581, 0.3377, 0.0089]]]]), tensor([0.5000, 0.5000, 0.5000]), tensor([0.5000, 0.5000, 0.5000]))
trace_kwargs = {}
test_args = (tensor([[[[0.8864, 0.0065, 0.3471, 0.5323],
          [0.0510, 0.5979, 0.4710, 0.6523],
          [0.6225, 0.7469, 0....1],
          [0.5885, 0.1941, 0.3683, 0.7241]]]]), tensor([0.4000, 0.4000, 0.4000]), tensor([0.6000, 0.6000, 0.6000]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function denormalize at 0x7f042f2f2cb0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.normalize.denormalize
_________________________________________________________________________________ test_zca_mean[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_zca_mean(target_framework, mode, backend_compile):
        trace_args = (torch.rand(10, 20),)
        trace_kwargs = {"dim": 0}
        test_args = (torch.rand(5, 10, 20),)
        test_kwargs = {"dim": 0}
>       _test_function(
            kornia.enhance.zca_mean,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1000,
            mode=mode,
        )

kornia/test_enhance.py:563: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function zca_mean at 0x7f042f2f3490>
trace_args = (tensor([[0.6026, 0.6450, 0.6618, 0.0273, 0.5636, 0.4001, 0.1786, 0.0836, 0.9235,
         0.2511, 0.1486, 0.7054, 0.4..., 0.2467,
         0.9467, 0.7004, 0.2546, 0.0747, 0.3021, 0.0120, 0.4620, 0.6471, 0.2001,
         0.1855, 0.6314]]),)
trace_kwargs = {'dim': 0}
test_args = (tensor([[[0.8458, 0.3983, 0.1945, 0.1254, 0.6898, 0.3310, 0.4901, 0.9175,
          0.0935, 0.0188, 0.9668, 0.8548, 0...         0.4007, 0.8705, 0.0793, 0.6920, 0.2584, 0.6345, 0.4930, 0.7727,
          0.9386, 0.0857, 0.8565, 0.1312]]]),)
test_kwargs = {'dim': 0}, target = 'tensorflow', backend_compile = False, tolerance = 1000, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function zca_mean at 0x7f042f2f3490>
trace_args = (tensor([[0.6026, 0.6450, 0.6618, 0.0273, 0.5636, 0.4001, 0.1786, 0.0836, 0.9235,
         0.2511, 0.1486, 0.7054, 0.4..., 0.2467,
         0.9467, 0.7004, 0.2546, 0.0747, 0.3021, 0.0120, 0.4620, 0.6471, 0.2001,
         0.1855, 0.6314]]),)
trace_kwargs = {'dim': 0}
test_args = (tensor([[[0.8458, 0.3983, 0.1945, 0.1254, 0.6898, 0.3310, 0.4901, 0.9175,
          0.0935, 0.0188, 0.9668, 0.8548, 0...         0.4007, 0.8705, 0.0793, 0.6920, 0.2584, 0.6345, 0.4930, 0.7727,
          0.9386, 0.0857, 0.8565, 0.1312]]]),)
test_kwargs = {'dim': 0}, target = 'tensorflow', backend_compile = False, tolerance = 1000, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function zca_mean at 0x7f042f2f3490>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.zca.zca_mean
________________________________________________________________________________ test_zca_whiten[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_zca_whiten(target_framework, mode, backend_compile):
        trace_args = (torch.rand(10, 20),)
        trace_kwargs = {"dim": 0}
        test_args = (torch.rand(5, 10, 20),)
        test_kwargs = {"dim": 0}
>       _test_function(
            kornia.enhance.zca_whiten,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1000,
            mode=mode,
        )

kornia/test_enhance.py:582: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function zca_whiten at 0x7f042f2f3520>
trace_args = (tensor([[0.6187, 0.5756, 0.4138, 0.9301, 0.3012, 0.2029, 0.5978, 0.3019, 0.5288,
         0.4933, 0.7532, 0.7091, 0.0..., 0.4338,
         0.3654, 0.3388, 0.0674, 0.8387, 0.5377, 0.0848, 0.0680, 0.7547, 0.5014,
         0.3713, 0.7295]]),)
trace_kwargs = {'dim': 0}
test_args = (tensor([[[9.3454e-01, 2.6975e-01, 3.4688e-01, 3.9440e-01, 8.8642e-01,
          2.3411e-01, 6.2536e-01, 8.4448e-01, 5...045e-01, 9.8034e-01, 9.8037e-01, 4.9704e-01,
          6.4158e-02, 1.0381e-01, 3.6947e-01, 8.3704e-01, 9.5850e-01]]]),)
test_kwargs = {'dim': 0}, target = 'tensorflow', backend_compile = False, tolerance = 1000, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function zca_whiten at 0x7f042f2f3520>
trace_args = (tensor([[0.6187, 0.5756, 0.4138, 0.9301, 0.3012, 0.2029, 0.5978, 0.3019, 0.5288,
         0.4933, 0.7532, 0.7091, 0.0..., 0.4338,
         0.3654, 0.3388, 0.0674, 0.8387, 0.5377, 0.0848, 0.0680, 0.7547, 0.5014,
         0.3713, 0.7295]]),)
trace_kwargs = {'dim': 0}
test_args = (tensor([[[9.3454e-01, 2.6975e-01, 3.4688e-01, 3.9440e-01, 8.8642e-01,
          2.3411e-01, 6.2536e-01, 8.4448e-01, 5...045e-01, 9.8034e-01, 9.8037e-01, 4.9704e-01,
          6.4158e-02, 1.0381e-01, 3.6947e-01, 8.3704e-01, 9.5850e-01]]]),)
test_kwargs = {'dim': 0}, target = 'tensorflow', backend_compile = False, tolerance = 1000, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function zca_whiten at 0x7f042f2f3520>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.zca.zca_whiten
_________________________________________________________________________ test_jpeg_codec_differentiable[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_jpeg_codec_differentiable(target_framework, mode, backend_compile):
        trace_args = (torch.rand(3, 3, 64, 64), torch.tensor([99.0]))
        trace_kwargs = {}
        test_args = (torch.rand(5, 3, 3, 64, 64), torch.tensor([50.0]))
        test_kwargs = {}
>       _test_function(
            kornia.enhance.jpeg_codec_differentiable,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_enhance.py:626: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function jpeg_codec_differentiable at 0x7f042f2f23b0>
trace_args = (tensor([[[[5.0570e-02, 1.8797e-01, 3.6562e-01,  ..., 8.5878e-01,
           9.4705e-02, 3.6732e-01],
          [4.400...          [9.0718e-01, 7.5987e-01, 5.6207e-01,  ..., 7.6864e-01,
           8.1646e-01, 5.7956e-01]]]]), tensor([99.]))
trace_kwargs = {}
test_args = (tensor([[[[[0.9048, 0.3265, 0.4528,  ..., 0.8983, 0.9505, 0.0513],
           [0.5235, 0.4792, 0.5586,  ..., 0.0602, ...,  ..., 0.7297, 0.5909, 0.9424],
           [0.1559, 0.0702, 0.6809,  ..., 0.0534, 0.6788, 0.9358]]]]]), tensor([50.]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function jpeg_codec_differentiable at 0x7f042f2f23b0>
trace_args = (tensor([[[[5.0570e-02, 1.8797e-01, 3.6562e-01,  ..., 8.5878e-01,
           9.4705e-02, 3.6732e-01],
          [4.400...          [9.0718e-01, 7.5987e-01, 5.6207e-01,  ..., 7.6864e-01,
           8.1646e-01, 5.7956e-01]]]]), tensor([99.]))
trace_kwargs = {}
test_args = (tensor([[[[[0.9048, 0.3265, 0.4528,  ..., 0.8983, 0.9505, 0.0513],
           [0.5235, 0.4792, 0.5586,  ..., 0.0602, ...,  ..., 0.7297, 0.5909, 0.9424],
           [0.1559, 0.0702, 0.6809,  ..., 0.0534, 0.6788, 0.9358]]]]]), tensor([50.]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function jpeg_codec_differentiable at 0x7f042f2f23b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.jpeg.jpeg_codec_differentiable
_________________________________________________________________________________ test_Normalize[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Normalize(target_framework, mode, backend_compile):
        print("kornia.enhance.Normalize")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledNormalize = ivy.transpile(kornia.enhance.Normalize, source="torch", target=target_framework)

kornia/test_enhance.py:645: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.normalize.Normalize'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.Normalize
________________________________________________________________________________ test_Denormalize[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Denormalize(target_framework, mode, backend_compile):
        print("kornia.enhance.Denormalize")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledDenormalize = ivy.transpile(kornia.enhance.Denormalize, source="torch", target=target_framework)

kornia/test_enhance.py:667: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.normalize.Denormalize'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.Denormalize
_______________________________________________________________________________ test_ZCAWhitening[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ZCAWhitening(target_framework, mode, backend_compile):
        print("kornia.enhance.ZCAWhitening")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledZCAWhitening = ivy.transpile(kornia.enhance.ZCAWhitening, source="torch", target=target_framework)

kornia/test_enhance.py:689: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.zca.ZCAWhitening'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.ZCAWhitening
_____________________________________________________________________________ test_AdjustBrightness[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_AdjustBrightness(target_framework, mode, backend_compile):
        print("kornia.enhance.AdjustBrightness")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledAdjustBrightness = ivy.transpile(kornia.enhance.AdjustBrightness, source="torch", target=target_framework)

kornia/test_enhance.py:708: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.adjust.AdjustBrightness'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.AdjustBrightness
______________________________________________________________________________ test_AdjustContrast[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_AdjustContrast(target_framework, mode, backend_compile):
        print("kornia.enhance.AdjustContrast")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledAdjustContrast = ivy.transpile(kornia.enhance.AdjustContrast, source="torch", target=target_framework)

kornia/test_enhance.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.adjust.AdjustContrast'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.AdjustContrast
_____________________________________________________________________________ test_AdjustSaturation[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_AdjustSaturation(target_framework, mode, backend_compile):
        print("kornia.enhance.AdjustSaturation")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledAdjustSaturation = ivy.transpile(kornia.enhance.AdjustSaturation, source="torch", target=target_framework)

kornia/test_enhance.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.adjust.AdjustSaturation'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.AdjustSaturation
_________________________________________________________________________________ test_AdjustLog[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_AdjustLog(target_framework, mode, backend_compile):
        print("kornia.enhance.AdjustLog")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledAdjustLog = ivy.transpile(kornia.enhance.AdjustLog, source="torch", target=target_framework)

kornia/test_enhance.py:823: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.adjust.AdjustLog'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.AdjustLog
__________________________________________________________________________________ test_Invert[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Invert(target_framework, mode, backend_compile):
        print("kornia.enhance.Invert")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledInvert = ivy.transpile(kornia.enhance.Invert, source="torch", target=target_framework)

kornia/test_enhance.py:861: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.adjust.Invert'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.Invert
__________________________________________________________________________ test_JPEGCodecDifferentiable[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_JPEGCodecDifferentiable(target_framework, mode, backend_compile):
        print("kornia.enhance.JPEGCodecDifferentiable")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledJPEGCodecDifferentiable = ivy.transpile(kornia.enhance.JPEGCodecDifferentiable, source="torch", target=target_framework)

kornia/test_enhance.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.enhance.jpeg.JPEGCodecDifferentiable'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.enhance.JPEGCodecDifferentiable
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_enhance.py::test_add_weighted[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_enhance.py::test_adjust_contrast[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
FAILED kornia/test_enhance.py::test_adjust_contrast_with_mean_subtraction[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ke...
FAILED kornia/test_enhance.py::test_adjust_gamma[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_enhance.py::test_adjust_hue[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_enhance.py::test_adjust_saturation[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/test_enhance.py::test_adjust_log[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_enhance.py::test_solarize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_enhance.py::test_equalize_clahe[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_enhance.py::test_histogram[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_enhance.py::test_image_histogram2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/test_enhance.py::test_normalize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_enhance.py::test_normalize_min_max[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/test_enhance.py::test_denormalize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_enhance.py::test_zca_mean[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_enhance.py::test_zca_whiten[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_enhance.py::test_jpeg_codec_differentiable[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/test_enhance.py::test_Normalize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_enhance.py::test_Denormalize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_enhance.py::test_ZCAWhitening[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_enhance.py::test_AdjustBrightness[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/test_enhance.py::test_AdjustContrast[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_enhance.py::test_AdjustSaturation[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_enhance.py::test_AdjustLog[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_enhance.py::test_Invert[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_enhance.py::test_JPEGCodecDifferentiable[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you ...
============================================================================== 26 failed, 13 passed in 266.73s (0:04:26) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 5 items

kornia/geometry/test_solvers.py FFFFF                                                                                                                                                            [100%]

=============================================================================================== FAILURES ===============================================================================================
______________________________________________________________________________ test_solve_quadratic[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_solve_quadratic(target_framework, mode, backend_compile):
        trace_args = (torch.tensor([[1., -3., 2.]]),)
        trace_kwargs = {}
        test_args = (torch.tensor([[1., -2., 1.]]),)
        test_kwargs = {}
>       _test_function(
            kornia.geometry.solvers.solve_quadratic,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_solvers.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function solve_quadratic at 0x7fbc2e7a69e0>, trace_args = (tensor([[ 1., -3.,  2.]]),), trace_kwargs = {}, test_args = (tensor([[ 1., -2.,  1.]]),), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function solve_quadratic at 0x7fbc2e7a69e0>, trace_args = (tensor([[ 1., -3.,  2.]]),), trace_kwargs = {}, test_args = (tensor([[ 1., -2.,  1.]]),), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function solve_quadratic at 0x7fbc2e7a69e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.solvers.polynomial_solver.solve_quadratic
________________________________________________________________________________ test_solve_cubic[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_solve_cubic(target_framework, mode, backend_compile):
        trace_args = (torch.tensor([[1., -6., 11., -6.]]),)
        trace_kwargs = {}
        test_args = (torch.tensor([[1., -4., 6., -4.]]),)
        test_kwargs = {}
>       _test_function(
            kornia.geometry.solvers.solve_cubic,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_solvers.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function solve_cubic at 0x7fbc2e7a6a70>, trace_args = (tensor([[ 1., -6., 11., -6.]]),), trace_kwargs = {}, test_args = (tensor([[ 1., -4.,  6., -4.]]),), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function solve_cubic at 0x7fbc2e7a6a70>, trace_args = (tensor([[ 1., -6., 11., -6.]]),), trace_kwargs = {}, test_args = (tensor([[ 1., -4.,  6., -4.]]),), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function solve_cubic at 0x7fbc2e7a6a70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.solvers.polynomial_solver.solve_cubic
___________________________________________________________________________ test_multiply_deg_one_poly[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_multiply_deg_one_poly(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 9),
            torch.rand(1, 9),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(3, 9),
            torch.rand(3, 9),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.solvers.multiply_deg_one_poly,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_solvers.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function multiply_deg_one_poly at 0x7fbc2e7a6b00>
trace_args = (tensor([[0.9470, 0.2553, 0.6559, 0.8480, 0.4457, 0.1483, 0.9998, 0.5175, 0.7698]]), tensor([[0.3199, 0.1047, 0.6487, 0.9520, 0.7991, 0.2995, 0.9007, 0.8442, 0.0392]])), trace_kwargs = {}
test_args = (tensor([[0.5588, 0.7695, 0.4307, 0.7299, 0.9145, 0.6759, 0.5089, 0.7448, 0.8859],
        [0.9016, 0.6745, 0.2743, 0....3, 0.5680, 0.2463, 0.4946, 0.1996],
        [0.9860, 0.1966, 0.1568, 0.1425, 0.8282, 0.0907, 0.4056, 0.1557, 0.8723]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function multiply_deg_one_poly at 0x7fbc2e7a6b00>
trace_args = (tensor([[0.9470, 0.2553, 0.6559, 0.8480, 0.4457, 0.1483, 0.9998, 0.5175, 0.7698]]), tensor([[0.3199, 0.1047, 0.6487, 0.9520, 0.7991, 0.2995, 0.9007, 0.8442, 0.0392]])), trace_kwargs = {}
test_args = (tensor([[0.5588, 0.7695, 0.4307, 0.7299, 0.9145, 0.6759, 0.5089, 0.7448, 0.8859],
        [0.9016, 0.6745, 0.2743, 0....3, 0.5680, 0.2463, 0.4946, 0.1996],
        [0.9860, 0.1966, 0.1568, 0.1425, 0.8282, 0.0907, 0.4056, 0.1557, 0.8723]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function multiply_deg_one_poly at 0x7fbc2e7a6b00>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.solvers.polynomial_solver.multiply_deg_one_poly
_________________________________________________________________________ test_multiply_deg_two_one_poly[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_multiply_deg_two_one_poly(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 20),
            torch.rand(1, 20),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(3, 20),
            torch.rand(3, 20),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.solvers.multiply_deg_two_one_poly,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_solvers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function multiply_deg_two_one_poly at 0x7fbc2e7a6b90>
trace_args = (tensor([[0.4543, 0.6717, 0.2604, 0.8825, 0.3404, 0.5961, 0.0256, 0.0622, 0.7052,
         0.7166, 0.4819, 0.7434, 0.6...5, 0.9271,
         0.0135, 0.0696, 0.7655, 0.6722, 0.2465, 0.4368, 0.0959, 0.3318, 0.2724,
         0.7571, 0.4963]]))
trace_kwargs = {}
test_args = (tensor([[0.0051, 0.1306, 0.7249, 0.8787, 0.0725, 0.6421, 0.2431, 0.5383, 0.8639,
         0.5017, 0.7736, 0.9614, 0.0...8, 0.4544,
         0.0705, 0.6161, 0.1821, 0.7087, 0.8722, 0.4956, 0.8379, 0.2399, 0.0040,
         0.5851, 0.7508]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function multiply_deg_two_one_poly at 0x7fbc2e7a6b90>
trace_args = (tensor([[0.4543, 0.6717, 0.2604, 0.8825, 0.3404, 0.5961, 0.0256, 0.0622, 0.7052,
         0.7166, 0.4819, 0.7434, 0.6...5, 0.9271,
         0.0135, 0.0696, 0.7655, 0.6722, 0.2465, 0.4368, 0.0959, 0.3318, 0.2724,
         0.7571, 0.4963]]))
trace_kwargs = {}
test_args = (tensor([[0.0051, 0.1306, 0.7249, 0.8787, 0.0725, 0.6421, 0.2431, 0.5383, 0.8639,
         0.5017, 0.7736, 0.9614, 0.0...8, 0.4544,
         0.0705, 0.6161, 0.1821, 0.7087, 0.8722, 0.4956, 0.8379, 0.2399, 0.0040,
         0.5851, 0.7508]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function multiply_deg_two_one_poly at 0x7fbc2e7a6b90>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.solvers.polynomial_solver.multiply_deg_two_one_poly
_________________________________________________________________________ test_determinant_to_polynomial[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_determinant_to_polynomial(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 3, 13),)
        trace_kwargs = {}
        test_args = (torch.rand(5, 3, 13),)
        test_kwargs = {}
>       _test_function(
            kornia.geometry.solvers.determinant_to_polynomial,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_solvers.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function determinant_to_polynomial at 0x7fbc2e7a6c20>
trace_args = (tensor([[[0.4185, 0.2889, 0.7317, 0.0571, 0.9044, 0.0420, 0.9862, 0.9607,
          0.4169, 0.3700, 0.6190, 0.5630, 0...[0.4663, 0.6425, 0.1271, 0.6727, 0.9198, 0.3223, 0.0284, 0.7470,
          0.6509, 0.6106, 0.6569, 0.7450, 0.1502]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.2795, 0.8771, 0.6395, 0.3406, 0.1395, 0.2587, 0.9053, 0.5810,
          0.0519, 0.2425, 0.2461, 0.4779, 0...[0.8053, 0.5812, 0.6541, 0.5368, 0.5135, 0.5187, 0.2767, 0.2331,
          0.2878, 0.9345, 0.1825, 0.1323, 0.9737]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function determinant_to_polynomial at 0x7fbc2e7a6c20>
trace_args = (tensor([[[0.4185, 0.2889, 0.7317, 0.0571, 0.9044, 0.0420, 0.9862, 0.9607,
          0.4169, 0.3700, 0.6190, 0.5630, 0...[0.4663, 0.6425, 0.1271, 0.6727, 0.9198, 0.3223, 0.0284, 0.7470,
          0.6509, 0.6106, 0.6569, 0.7450, 0.1502]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.2795, 0.8771, 0.6395, 0.3406, 0.1395, 0.2587, 0.9053, 0.5810,
          0.0519, 0.2425, 0.2461, 0.4779, 0...[0.8053, 0.5812, 0.6541, 0.5368, 0.5135, 0.5187, 0.2767, 0.2331,
          0.2878, 0.9345, 0.1825, 0.1323, 0.9737]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function determinant_to_polynomial at 0x7fbc2e7a6c20>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.solvers.polynomial_solver.determinant_to_polynomial
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_solvers.py::test_solve_quadratic[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/geometry/test_solvers.py::test_solve_cubic[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/geometry/test_solvers.py::test_multiply_deg_one_poly[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/geometry/test_solvers.py::test_multiply_deg_two_one_poly[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/geometry/test_solvers.py::test_determinant_to_polynomial[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
========================================================================================== 5 failed in 6.64s ===========================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 26 items

kornia/geometry/test_epipolar.py FF.FFF.F.......FFFFFFFFFFF                                                                                                                                      [100%]

=============================================================================================== FAILURES ===============================================================================================
______________________________________________________________________________ test_find_essential[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_find_essential(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 8, 2),
            torch.rand(1, 8, 2),
        )
        trace_kwargs = {'weights': torch.rand(1, 8)}
        test_args = (
            torch.rand(5, 8, 2),
            torch.rand(5, 8, 2),
        )
        test_kwargs = {'weights': torch.rand(5, 8)}
>       _test_function(
            kornia.geometry.epipolar.find_essential,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            # NOTE: numerical instability in svd()/lu() leads to logits not being allclose
            deterministic=False,
        )

kornia/geometry/test_epipolar.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_essential at 0x7ff16af14040>
trace_args = (tensor([[[0.0469, 0.8153],
         [0.9418, 0.2131],
         [0.6901, 0.1724],
         [0.6672, 0.1378],
         ...0.0765],
         [0.6411, 0.1083],
         [0.3969, 0.0683],
         [0.7053, 0.4467],
         [0.9095, 0.9718]]]))
trace_kwargs = {'weights': tensor([[0.2758, 0.2227, 0.0369, 0.3091, 0.4796, 0.5369, 0.5422, 0.2970]])}
test_args = (tensor([[[0.3250, 0.2077],
         [0.4800, 0.4711],
         [0.7308, 0.1511],
         [0.4615, 0.0981],
         ...0.3994],
         [0.3424, 0.6051],
         [0.1129, 0.2664],
         [0.9741, 0.0858],
         [0.8623, 0.2355]]]))
test_kwargs = {'weights': tensor([[0.9182, 0.4102, 0.9303, 0.8552, 0.7490, 0.5697, 0.4678, 0.8332],
        [0.8982, 0.2353, 0.0224,...1, 0.3588, 0.9116, 0.9103, 0.2378, 0.8236],
        [0.4246, 0.9566, 0.6924, 0.3417, 0.5845, 0.6462, 0.0526, 0.9739]])}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_essential at 0x7ff16af14040>
trace_args = (tensor([[[0.0469, 0.8153],
         [0.9418, 0.2131],
         [0.6901, 0.1724],
         [0.6672, 0.1378],
         ...0.0765],
         [0.6411, 0.1083],
         [0.3969, 0.0683],
         [0.7053, 0.4467],
         [0.9095, 0.9718]]]))
trace_kwargs = {'weights': tensor([[0.2758, 0.2227, 0.0369, 0.3091, 0.4796, 0.5369, 0.5422, 0.2970]])}
test_args = (tensor([[[0.3250, 0.2077],
         [0.4800, 0.4711],
         [0.7308, 0.1511],
         [0.4615, 0.0981],
         ...0.3994],
         [0.3424, 0.6051],
         [0.1129, 0.2664],
         [0.9741, 0.0858],
         [0.8623, 0.2355]]]))
test_kwargs = {'weights': tensor([[0.9182, 0.4102, 0.9303, 0.8552, 0.7490, 0.5697, 0.4678, 0.8332],
        [0.8982, 0.2353, 0.0224,...1, 0.3588, 0.9116, 0.9103, 0.2378, 0.8236],
        [0.4246, 0.9566, 0.6924, 0.3417, 0.5845, 0.6462, 0.0526, 0.9739]])}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function find_essential at 0x7ff16af14040>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.essential.find_essential
________________________________________________________________________ test_essential_from_fundamental[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_essential_from_fundamental(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(3, 3),
            torch.rand(3, 3),
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(3, 3),
            torch.rand(3, 3),
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.essential_from_fundamental,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function essential_from_fundamental at 0x7ff16aef7be0>
trace_args = (tensor([[0.6178, 0.3811, 0.1177],
        [0.7386, 0.4293, 0.6264],
        [0.9066, 0.0235, 0.9367]]), tensor([[0.69...801, 0.0915]]), tensor([[0.3580, 0.4756, 0.3456],
        [0.8868, 0.7289, 0.4055],
        [0.7861, 0.3909, 0.7564]]))
trace_kwargs = {}
test_args = (tensor([[0.9562, 0.2778, 0.0661],
        [0.7082, 0.9019, 0.3350],
        [0.7582, 0.0164, 0.2594]]), tensor([[0.15...094, 0.9930]]), tensor([[0.3755, 0.1254, 0.6813],
        [0.3151, 0.1162, 0.6871],
        [0.0491, 0.3896, 0.2745]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function essential_from_fundamental at 0x7ff16aef7be0>
trace_args = (tensor([[0.6178, 0.3811, 0.1177],
        [0.7386, 0.4293, 0.6264],
        [0.9066, 0.0235, 0.9367]]), tensor([[0.69...801, 0.0915]]), tensor([[0.3580, 0.4756, 0.3456],
        [0.8868, 0.7289, 0.4055],
        [0.7861, 0.3909, 0.7564]]))
trace_kwargs = {}
test_args = (tensor([[0.9562, 0.2778, 0.0661],
        [0.7082, 0.9019, 0.3350],
        [0.7582, 0.0164, 0.2594]]), tensor([[0.15...094, 0.9930]]), tensor([[0.3755, 0.1254, 0.6813],
        [0.3151, 0.1162, 0.6871],
        [0.0491, 0.3896, 0.2745]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function essential_from_fundamental at 0x7ff16aef7be0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.essential.essential_from_fundamental
________________________________________________________________________ test_decompose_essential_matrix[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_decompose_essential_matrix(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.decompose_essential_matrix,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            # NOTE: numerical instability in svd()/lu() leads to logits not being allclose
            deterministic=False,
        )

kornia/geometry/test_epipolar.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function decompose_essential_matrix at 0x7ff16aef7c70>, trace_args = (tensor([[0.9486, 0.0269, 0.2334],
        [0.6507, 0.3827, 0.1806],
        [0.0801, 0.2186, 0.0359]]),), trace_kwargs = {}
test_args = (tensor([[0.6260, 0.9300, 0.9460],
        [0.5219, 0.3920, 0.9373],
        [0.2540, 0.1814, 0.3491]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function decompose_essential_matrix at 0x7ff16aef7c70>, trace_args = (tensor([[0.9486, 0.0269, 0.2334],
        [0.6507, 0.3827, 0.1806],
        [0.0801, 0.2186, 0.0359]]),), trace_kwargs = {}
test_args = (tensor([[0.6260, 0.9300, 0.9460],
        [0.5219, 0.3920, 0.9373],
        [0.2540, 0.1814, 0.3491]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
            _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)
        else:
            _to_numpy_and_shape_allclose(orig_out, graph_out, tolerance=tolerance)
    
        # test it works with the test_args as input
        orig_out = fn(*test_args, **test_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(test_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(test_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
            _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)
        else:
>           _to_numpy_and_shape_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = (tensor([[[-0.4401,  0.3199, -0.8390],
         [-0.0210,  0.9305,  0.3658],
         [ 0.8977,  0.1786, -0.4027]]]), ... -0.8408, -0.0845],
         [ 0.7755, -0.4484, -0.4444]]]), tensor([[-0.0590],
        [-0.3146],
        [ 0.9474]]))
transpiled_x = (<tf.Tensor: shape=(1, 3, 3), dtype=float32, numpy=
array([[[ 0.3358061 , -0.30309638,  0.89183354],
        [-0.53463...shape=(3, 1), dtype=float32, numpy=
array([[ 0.05902991],
       [ 0.31459787],
       [-0.94738775]], dtype=float32)>)
tolerance = 0.001

    def _to_numpy_and_shape_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_shape_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = (array([[[-0.44006127,  0.31991202, -0.8390484 ],
        [-0.02098361,  0.9304673 ,  0.36577398],
        [ 0.8977225...8  , -0.44440982]]], dtype=float32), array([[-0.05902993],
       [-0.31459785],
       [ 0.94738775]], dtype=float32))
y = (array([[[ 0.3358061 , -0.30309638,  0.89183354],
        [-0.5346399 , -0.84084886, -0.08445867],
        [ 0.7754962...92 , -0.4027496 ]]], dtype=float32), array([[ 0.05902991],
       [ 0.31459787],
       [-0.94738775]], dtype=float32))
tolerance = 0.001

    def _check_shape_allclose(x, y, tolerance=1e-3):
        """
        Checks that all array shapes are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
            assert np.allclose(x.shape, y.shape, atol=tolerance), "numpy array shapes are not all close"
            return
    
        if isinstance(x, (list, set, tuple)):
>           all([
                _check_allclose(element_x, element_y, tolerance=tolerance) for element_x, element_y in zip(x, y)
            ])

helpers.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <zip object at 0x7ff1644d8140>

    all([
>       _check_allclose(element_x, element_y, tolerance=tolerance) for element_x, element_y in zip(x, y)
    ])

helpers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[-0.44006127,  0.31991202, -0.8390484 ],
        [-0.02098361,  0.9304673 ,  0.36577398],
        [ 0.89772254,  0.1785692 , -0.40274957]]], dtype=float32)
y = array([[[ 0.3358061 , -0.30309638,  0.89183354],
        [-0.5346399 , -0.84084886, -0.08445867],
        [ 0.77549624, -0.448448  , -0.4444096 ]]], dtype=float32), tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.essential.decompose_essential_matrix

Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling decompose_essential_matrix from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
                                                                                                                                                        
Transpilation of decompose_essential_matrix complete.
___________________________________________________________________________ test_motion_from_essential[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_motion_from_essential(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.motion_from_essential,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            deterministic=False,
        )

kornia/geometry/test_epipolar.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function motion_from_essential at 0x7ff16aef7e20>, trace_args = (tensor([[0.2472, 0.0771, 0.0126],
        [0.1624, 0.7483, 0.5636],
        [0.6139, 0.5238, 0.9877]]),), trace_kwargs = {}
test_args = (tensor([[0.5776, 0.5802, 0.8272],
        [0.4025, 0.7034, 0.9249],
        [0.4660, 0.1070, 0.9253]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function motion_from_essential at 0x7ff16aef7e20>, trace_args = (tensor([[0.2472, 0.0771, 0.0126],
        [0.1624, 0.7483, 0.5636],
        [0.6139, 0.5238, 0.9877]]),), trace_kwargs = {}
test_args = (tensor([[0.5776, 0.5802, 0.8272],
        [0.4025, 0.7034, 0.9249],
        [0.4660, 0.1070, 0.9253]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function motion_from_essential at 0x7ff16aef7e20>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.essential.motion_from_essential
___________________________________________________________________ test_motion_from_essential_choose_solution[tensorflow-s2s-False] ___________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_motion_from_essential_choose_solution(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(3, 3),
            torch.rand(3, 3),
            torch.rand(3, 3),
            torch.rand(8, 2),
            torch.rand(8, 2),
        )
        trace_kwargs = {'mask': torch.ones(8).bool()}
        test_args = (
            torch.rand(3, 3),
            torch.rand(3, 3),
            torch.rand(3, 3),
            torch.rand(8, 2),
            torch.rand(8, 2),
        )
        test_kwargs = {'mask': torch.ones(8).bool()}
>       _test_function(
            kornia.geometry.epipolar.motion_from_essential_choose_solution,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            deterministic=False,
        )

kornia/geometry/test_epipolar.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function motion_from_essential_choose_solution at 0x7ff16aef7eb0>
trace_args = (tensor([[0.6909, 0.7057, 0.4827],
        [0.8674, 0.0780, 0.1849],
        [0.2434, 0.5438, 0.7152]]), tensor([[0.50...672, 0.4690],
        [0.1238, 0.8153],
        [0.0589, 0.6909],
        [0.1079, 0.8589],
        [0.5838, 0.3427]]))
trace_kwargs = {'mask': tensor([True, True, True, True, True, True, True, True])}
test_args = (tensor([[0.2268, 0.5961, 0.6624],
        [0.4584, 0.2229, 0.9118],
        [0.6456, 0.9730, 0.4008]]), tensor([[0.14...907, 0.4458],
        [0.9982, 0.3968],
        [0.7150, 0.6005],
        [0.8389, 0.7656],
        [0.8233, 0.2358]]))
test_kwargs = {'mask': tensor([True, True, True, True, True, True, True, True])}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function motion_from_essential_choose_solution at 0x7ff16aef7eb0>
trace_args = (tensor([[0.6909, 0.7057, 0.4827],
        [0.8674, 0.0780, 0.1849],
        [0.2434, 0.5438, 0.7152]]), tensor([[0.50...672, 0.4690],
        [0.1238, 0.8153],
        [0.0589, 0.6909],
        [0.1079, 0.8589],
        [0.5838, 0.3427]]))
trace_kwargs = {'mask': tensor([True, True, True, True, True, True, True, True])}
test_args = (tensor([[0.2268, 0.5961, 0.6624],
        [0.4584, 0.2229, 0.9118],
        [0.6456, 0.9730, 0.4008]]), tensor([[0.14...907, 0.4458],
        [0.9982, 0.3968],
        [0.7150, 0.6005],
        [0.8389, 0.7656],
        [0.8233, 0.2358]]))
test_kwargs = {'mask': tensor([True, True, True, True, True, True, True, True])}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function motion_from_essential_choose_solution at 0x7ff16aef7eb0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.essential.motion_from_essential_choose_solution
_____________________________________________________________________________ test_find_fundamental[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_find_fundamental(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 8, 2),
            torch.rand(2, 8, 2),
        )
        trace_kwargs = {'weights': torch.rand(2, 8), 'method': '8POINT'}
        test_args = (
            torch.rand(5, 8, 2),
            torch.rand(5, 8, 2),
        )
        test_kwargs = {'weights': torch.rand(5, 8), 'method': '8POINT'}
>       _test_function(
            kornia.geometry.epipolar.find_fundamental,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=3e-2,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_fundamental at 0x7ff16af145e0>
trace_args = (tensor([[[0.2780, 0.4403],
         [0.7918, 0.3944],
         [0.5010, 0.2194],
         [0.4779, 0.4666],
         ...0.1421],
         [0.7278, 0.4783],
         [0.7091, 0.6582],
         [0.7539, 0.9593],
         [0.7540, 0.8129]]]))
trace_kwargs = {'method': '8POINT', 'weights': tensor([[0.6400, 0.8469, 0.0919, 0.3856, 0.1845, 0.0318, 0.5507, 0.8942],
        [0.5317, 0.8671, 0.6480, 0.5445, 0.1909, 0.4449, 0.0788, 0.1692]])}
test_args = (tensor([[[0.9497, 0.3140],
         [0.6898, 0.6685],
         [0.8435, 0.6434],
         [0.2188, 0.3528],
         ...0.4883],
         [0.7452, 0.5009],
         [0.0482, 0.0535],
         [0.2075, 0.2818],
         [0.7079, 0.9711]]]))
test_kwargs = {'method': '8POINT', 'weights': tensor([[8.0024e-01, 7.2258e-01, 5.5764e-01, 6.9347e-01, 7.1809e-01, 5.9227e-01,
     ...],
        [8.0397e-01, 8.8234e-01, 6.6283e-01, 7.8646e-01, 1.3038e-01, 7.9485e-01,
         3.7849e-01, 3.1967e-01]])}
target = 'tensorflow', backend_compile = False, tolerance = 0.03, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_fundamental at 0x7ff16af145e0>
trace_args = (tensor([[[0.2780, 0.4403],
         [0.7918, 0.3944],
         [0.5010, 0.2194],
         [0.4779, 0.4666],
         ...0.1421],
         [0.7278, 0.4783],
         [0.7091, 0.6582],
         [0.7539, 0.9593],
         [0.7540, 0.8129]]]))
trace_kwargs = {'method': '8POINT', 'weights': tensor([[0.6400, 0.8469, 0.0919, 0.3856, 0.1845, 0.0318, 0.5507, 0.8942],
        [0.5317, 0.8671, 0.6480, 0.5445, 0.1909, 0.4449, 0.0788, 0.1692]])}
test_args = (tensor([[[0.9497, 0.3140],
         [0.6898, 0.6685],
         [0.8435, 0.6434],
         [0.2188, 0.3528],
         ...0.4883],
         [0.7452, 0.5009],
         [0.0482, 0.0535],
         [0.2075, 0.2818],
         [0.7079, 0.9711]]]))
test_kwargs = {'method': '8POINT', 'weights': tensor([[8.0024e-01, 7.2258e-01, 5.5764e-01, 6.9347e-01, 7.1809e-01, 5.9227e-01,
     ...],
        [8.0397e-01, 8.8234e-01, 6.6283e-01, 7.8646e-01, 1.3038e-01, 7.9485e-01,
         3.7849e-01, 3.1967e-01]])}
target = 'tensorflow', backend_compile = False, tolerance = 0.03, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function find_fundamental at 0x7ff16af145e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.fundamental.find_fundamental
_________________________________________________________________________ test_sampson_epipolar_distance[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_sampson_epipolar_distance(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2),
            torch.rand(1, 4, 2),
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {'squared': True, 'eps': 1e-8}
        test_args = (
            torch.rand(5, 4, 2),
            torch.rand(5, 4, 2),
            torch.rand(5, 3, 3),
        )
        test_kwargs = {'squared': True, 'eps': 1e-8}
>       _test_function(
            kornia.geometry.epipolar.sampson_epipolar_distance,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function sampson_epipolar_distance at 0x7ff16aef63b0>
trace_args = (tensor([[[2.6371e-01, 4.1420e-01],
         [7.6706e-02, 1.6921e-02],
         [1.2268e-01, 4.2450e-04],
         [7....0.6525]]]), tensor([[[0.5549, 0.3452, 0.4604],
         [0.6444, 0.8768, 0.3180],
         [0.9856, 0.2955, 0.4936]]]))
trace_kwargs = {'eps': 1e-08, 'squared': True}
test_args = (tensor([[[0.1559, 0.0985],
         [0.4253, 0.4366],
         [0.6351, 0.3226],
         [0.0025, 0.2534]],

       ... 0.6056]],

        [[0.7706, 0.5223, 0.7411],
         [0.1500, 0.6876, 0.0303],
         [0.2102, 0.2100, 0.3665]]]))
test_kwargs = {'eps': 1e-08, 'squared': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function sampson_epipolar_distance at 0x7ff16aef63b0>
trace_args = (tensor([[[2.6371e-01, 4.1420e-01],
         [7.6706e-02, 1.6921e-02],
         [1.2268e-01, 4.2450e-04],
         [7....0.6525]]]), tensor([[[0.5549, 0.3452, 0.4604],
         [0.6444, 0.8768, 0.3180],
         [0.9856, 0.2955, 0.4936]]]))
trace_kwargs = {'eps': 1e-08, 'squared': True}
test_args = (tensor([[[0.1559, 0.0985],
         [0.4253, 0.4366],
         [0.6351, 0.3226],
         [0.0025, 0.2534]],

       ... 0.6056]],

        [[0.7706, 0.5223, 0.7411],
         [0.1500, 0.6876, 0.0303],
         [0.2102, 0.2100, 0.3665]]]))
test_kwargs = {'eps': 1e-08, 'squared': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function sampson_epipolar_distance at 0x7ff16aef63b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar._metrics.sampson_epipolar_distance
_______________________________________________________________________ test_symmetrical_epipolar_distance[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_symmetrical_epipolar_distance(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2),
            torch.rand(1, 4, 2),
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {'squared': True, 'eps': 1e-8}
        test_args = (
            torch.rand(5, 4, 2),
            torch.rand(5, 4, 2),
            torch.rand(5, 3, 3),
        )
        test_kwargs = {'squared': True, 'eps': 1e-8}
>       _test_function(
            kornia.geometry.epipolar.symmetrical_epipolar_distance,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:426: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function symmetrical_epipolar_distance at 0x7ff16aef64d0>
trace_args = (tensor([[[0.0892, 0.5889],
         [0.0408, 0.8508],
         [0.8982, 0.3833],
         [0.6233, 0.4671]]]), tensor...0.8884]]]), tensor([[[0.0498, 0.7215, 0.4960],
         [0.0924, 0.2961, 0.8518],
         [0.0512, 0.9971, 0.3748]]]))
trace_kwargs = {'eps': 1e-08, 'squared': True}
test_args = (tensor([[[0.4902, 0.5601],
         [0.5438, 0.4027],
         [0.8238, 0.5150],
         [0.3929, 0.8612]],

       ... 0.0310]],

        [[0.5855, 0.3618, 0.4490],
         [0.0078, 0.4455, 0.3096],
         [0.6213, 0.0883, 0.5986]]]))
test_kwargs = {'eps': 1e-08, 'squared': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function symmetrical_epipolar_distance at 0x7ff16aef64d0>
trace_args = (tensor([[[0.0892, 0.5889],
         [0.0408, 0.8508],
         [0.8982, 0.3833],
         [0.6233, 0.4671]]]), tensor...0.8884]]]), tensor([[[0.0498, 0.7215, 0.4960],
         [0.0924, 0.2961, 0.8518],
         [0.0512, 0.9971, 0.3748]]]))
trace_kwargs = {'eps': 1e-08, 'squared': True}
test_args = (tensor([[[0.4902, 0.5601],
         [0.5438, 0.4027],
         [0.8238, 0.5150],
         [0.3929, 0.8612]],

       ... 0.0310]],

        [[0.5855, 0.3618, 0.4490],
         [0.0078, 0.4455, 0.3096],
         [0.6213, 0.0883, 0.5986]]]))
test_kwargs = {'eps': 1e-08, 'squared': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function symmetrical_epipolar_distance at 0x7ff16aef64d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar._metrics.symmetrical_epipolar_distance
______________________________________________________________________ test_left_to_right_epipolar_distance[tensorflow-s2s-False] ______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_left_to_right_epipolar_distance(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2),
            torch.rand(1, 4, 2),
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 4, 2),
            torch.rand(5, 4, 2),
            torch.rand(5, 3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.left_to_right_epipolar_distance,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:452: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function left_to_right_epipolar_distance at 0x7ff16aef6560>
trace_args = (tensor([[[0.7698, 0.9967],
         [0.4492, 0.6657],
         [0.9794, 0.0346],
         [0.2770, 0.3922]]]), tensor...0.3507]]]), tensor([[[0.3673, 0.1437, 0.5106],
         [0.1764, 0.4169, 0.1968],
         [0.2017, 0.4180, 0.0926]]]))
trace_kwargs = {}
test_args = (tensor([[[0.6583, 0.8928],
         [0.1164, 0.4584],
         [0.7134, 0.6912],
         [0.7641, 0.4319]],

       ... 0.6823]],

        [[0.9262, 0.0382, 0.1433],
         [0.7249, 0.1886, 0.7928],
         [0.4950, 0.3626, 0.6020]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function left_to_right_epipolar_distance at 0x7ff16aef6560>
trace_args = (tensor([[[0.7698, 0.9967],
         [0.4492, 0.6657],
         [0.9794, 0.0346],
         [0.2770, 0.3922]]]), tensor...0.3507]]]), tensor([[[0.3673, 0.1437, 0.5106],
         [0.1764, 0.4169, 0.1968],
         [0.2017, 0.4180, 0.0926]]]))
trace_kwargs = {}
test_args = (tensor([[[0.6583, 0.8928],
         [0.1164, 0.4584],
         [0.7134, 0.6912],
         [0.7641, 0.4319]],

       ... 0.6823]],

        [[0.9262, 0.0382, 0.1433],
         [0.7249, 0.1886, 0.7928],
         [0.4950, 0.3626, 0.6020]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function left_to_right_epipolar_distance at 0x7ff16aef6560>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar._metrics.left_to_right_epipolar_distance
______________________________________________________________________ test_right_to_left_epipolar_distance[tensorflow-s2s-False] ______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_right_to_left_epipolar_distance(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2),
            torch.rand(1, 4, 2),
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 4, 2),
            torch.rand(5, 4, 2),
            torch.rand(5, 3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.right_to_left_epipolar_distance,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function right_to_left_epipolar_distance at 0x7ff16aef65f0>
trace_args = (tensor([[[0.5184, 0.3282],
         [0.7878, 0.4105],
         [0.6090, 0.8564],
         [0.8591, 0.5507]]]), tensor...0355e-04, 2.5083e-01],
         [4.3553e-01, 7.2148e-01, 6.5748e-01],
         [1.8823e-01, 1.2259e-01, 9.2528e-01]]]))
trace_kwargs = {}
test_args = (tensor([[[0.7903, 0.6343],
         [0.6815, 0.3172],
         [0.4100, 0.2844],
         [0.7116, 0.5425]],

       ... 0.2096]],

        [[0.0867, 0.7856, 0.6984],
         [0.2555, 0.2710, 0.7967],
         [0.7837, 0.4883, 0.5247]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function right_to_left_epipolar_distance at 0x7ff16aef65f0>
trace_args = (tensor([[[0.5184, 0.3282],
         [0.7878, 0.4105],
         [0.6090, 0.8564],
         [0.8591, 0.5507]]]), tensor...0355e-04, 2.5083e-01],
         [4.3553e-01, 7.2148e-01, 6.5748e-01],
         [1.8823e-01, 1.2259e-01, 9.2528e-01]]]))
trace_kwargs = {}
test_args = (tensor([[[0.7903, 0.6343],
         [0.6815, 0.3172],
         [0.4100, 0.2844],
         [0.7116, 0.5425]],

       ... 0.2096]],

        [[0.0867, 0.7856, 0.6984],
         [0.2555, 0.2710, 0.7967],
         [0.7837, 0.4883, 0.5247]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function right_to_left_epipolar_distance at 0x7ff16aef65f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar._metrics.right_to_left_epipolar_distance
____________________________________________________________________________ test_projection_from_KRt[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_projection_from_KRt(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(3, 3),
            torch.eye(3),
            torch.rand(3, 1),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2, 3, 3),
            torch.stack([torch.eye(3) for _ in range(2)]),
            torch.rand(2, 3, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.projection_from_KRt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function projection_from_KRt at 0x7ff16aef76d0>
trace_args = (tensor([[0.7213, 0.4880, 0.2667],
        [0.2154, 0.3400, 0.1767],
        [0.3491, 0.2573, 0.1885]]), tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]), tensor([[0.3344],
        [0.9303],
        [0.1990]]))
trace_kwargs = {}
test_args = (tensor([[[0.9701, 0.9910, 0.7935],
         [0.0469, 0.9824, 0.6389],
         [0.0907, 0.1630, 0.3998]],

        [[... tensor([[[0.2262],
         [0.3398],
         [0.0480]],

        [[0.9016],
         [0.8166],
         [0.0214]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function projection_from_KRt at 0x7ff16aef76d0>
trace_args = (tensor([[0.7213, 0.4880, 0.2667],
        [0.2154, 0.3400, 0.1767],
        [0.3491, 0.2573, 0.1885]]), tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]), tensor([[0.3344],
        [0.9303],
        [0.1990]]))
trace_kwargs = {}
test_args = (tensor([[[0.9701, 0.9910, 0.7935],
         [0.0469, 0.9824, 0.6389],
         [0.0907, 0.1630, 0.3998]],

        [[... tensor([[[0.2262],
         [0.3398],
         [0.0480]],

        [[0.9016],
         [0.8166],
         [0.0214]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function projection_from_KRt at 0x7ff16aef76d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.projection.projection_from_KRt
_______________________________________________________________________ test_projections_from_fundamental[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_projections_from_fundamental(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 3, 3),)
        trace_kwargs = {}
        test_args = (torch.rand(2, 3, 3),)
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.projections_from_fundamental,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            # NOTE: numerical instability in svd()/lu() leads to logits not being allclose
            deterministic=False,
        )

kornia/geometry/test_epipolar.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function projections_from_fundamental at 0x7ff16aef7910>, trace_args = (tensor([[[0.7028, 0.3482, 0.7732],
         [0.7450, 0.4383, 0.2103],
         [0.7383, 0.0152, 0.1179]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.6553, 0.4943, 0.9457],
         [0.8356, 0.0197, 0.7952],
         [0.7000, 0.0464, 0.4190]],

        [[0.1093, 0.2225, 0.0966],
         [0.1555, 0.0312, 0.6193],
         [0.2916, 0.3220, 0.1217]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function projections_from_fundamental at 0x7ff16aef7910>, trace_args = (tensor([[[0.7028, 0.3482, 0.7732],
         [0.7450, 0.4383, 0.2103],
         [0.7383, 0.0152, 0.1179]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.6553, 0.4943, 0.9457],
         [0.8356, 0.0197, 0.7952],
         [0.7000, 0.0464, 0.4190]],

        [[0.1093, 0.2225, 0.0966],
         [0.1555, 0.0312, 0.6193],
         [0.2916, 0.3220, 0.1217]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function projections_from_fundamental at 0x7ff16aef7910>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.projection.projections_from_fundamental
______________________________________________________________________________ test_intrinsics_like[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_intrinsics_like(target_framework, mode, backend_compile):
        trace_args = (0.5, torch.rand(1, 3, 256, 256))
        trace_kwargs = {}
        test_args = (0.8, torch.rand(2, 3, 256, 256))
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.intrinsics_like,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function intrinsics_like at 0x7ff16aef7520>
trace_args = (0.5, tensor([[[[0.7471, 0.5504, 0.9035,  ..., 0.6736, 0.5205, 0.8752],
          [0.3363, 0.0192, 0.0777,  ..., 0.727...5, 0.9394, 0.2296,  ..., 0.9074, 0.8709, 0.5124],
          [0.7550, 0.1322, 0.9183,  ..., 0.0815, 0.7999, 0.3698]]]]))
trace_kwargs = {}
test_args = (0.8, tensor([[[[0.9508, 0.1829, 0.3922,  ..., 0.2509, 0.2909, 0.3185],
          [0.8051, 0.5999, 0.3944,  ..., 0.551...2, 0.6419, 0.9754,  ..., 0.5217, 0.9859, 0.9249],
          [0.5343, 0.1804, 0.6597,  ..., 0.3455, 0.7300, 0.8795]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function intrinsics_like at 0x7ff16aef7520>
trace_args = (0.5, tensor([[[[0.7471, 0.5504, 0.9035,  ..., 0.6736, 0.5205, 0.8752],
          [0.3363, 0.0192, 0.0777,  ..., 0.727...5, 0.9394, 0.2296,  ..., 0.9074, 0.8709, 0.5124],
          [0.7550, 0.1322, 0.9183,  ..., 0.0815, 0.7999, 0.3698]]]]))
trace_kwargs = {}
test_args = (0.8, tensor([[[[0.9508, 0.1829, 0.3922,  ..., 0.2509, 0.2909, 0.3185],
          [0.8051, 0.5999, 0.3944,  ..., 0.551...2, 0.6419, 0.9754,  ..., 0.5217, 0.9859, 0.9249],
          [0.5343, 0.1804, 0.6597,  ..., 0.3455, 0.7300, 0.8795]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function intrinsics_like at 0x7ff16aef7520>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.projection.intrinsics_like
_____________________________________________________________________________ test_scale_intrinsics[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_scale_intrinsics(target_framework, mode, backend_compile):
        trace_args = (torch.rand(3, 3), 0.5)
        trace_kwargs = {}
        test_args = (torch.rand(2, 3, 3), 1.2)
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.scale_intrinsics,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function scale_intrinsics at 0x7ff16aef7640>, trace_args = (tensor([[0.4136, 0.5674, 0.2280],
        [0.5199, 0.3619, 0.8322],
        [0.9212, 0.9362, 0.0094]]), 0.5), trace_kwargs = {}
test_args = (tensor([[[0.0420, 0.1811, 0.6940],
         [0.3814, 0.4756, 0.7102],
         [0.8829, 0.9875, 0.5933]],

        [[0.7451, 0.6806, 0.5219],
         [0.4512, 0.1661, 0.2518],
         [0.5829, 0.8271, 0.7335]]]), 1.2)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function scale_intrinsics at 0x7ff16aef7640>, trace_args = (tensor([[0.4136, 0.5674, 0.2280],
        [0.5199, 0.3619, 0.8322],
        [0.9212, 0.9362, 0.0094]]), 0.5), trace_kwargs = {}
test_args = (tensor([[[0.0420, 0.1811, 0.6940],
         [0.3814, 0.4756, 0.7102],
         [0.8829, 0.9875, 0.5933]],

        [[0.7451, 0.6806, 0.5219],
         [0.4512, 0.1661, 0.2518],
         [0.5829, 0.8271, 0.7335]]]), 1.2)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function scale_intrinsics at 0x7ff16aef7640>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.projection.scale_intrinsics
_____________________________________________________________________________ test_random_intrinsics[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_random_intrinsics(target_framework, mode, backend_compile):
        trace_args = (0.1, 1.0)
        trace_kwargs = {}
        test_args = (0.2, 2.0)
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.random_intrinsics,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            deterministic=False,
        )

kornia/geometry/test_epipolar.py:578: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function random_intrinsics at 0x7ff16aef75b0>, trace_args = (0.1, 1.0), trace_kwargs = {}, test_args = (0.2, 2.0), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function random_intrinsics at 0x7ff16aef75b0>, trace_args = (0.1, 1.0), trace_kwargs = {}, test_args = (0.2, 2.0), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function random_intrinsics at 0x7ff16aef75b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.projection.random_intrinsics
___________________________________________________________________________ test_cross_product_matrix[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_cross_product_matrix(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 3),)
        trace_kwargs = {}
        test_args = (torch.rand(5, 3),)
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.cross_product_matrix,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_epipolar.py:597: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function cross_product_matrix at 0x7ff16aef7250>, trace_args = (tensor([[0.1669, 0.9810, 0.8268]]),), trace_kwargs = {}
test_args = (tensor([[0.6081, 0.8063, 0.5904],
        [0.4448, 0.0870, 0.6136],
        [0.6710, 0.7469, 0.1505],
        [0.3721, 0.2842, 0.5610],
        [0.9397, 0.2866, 0.0427]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function cross_product_matrix at 0x7ff16aef7250>, trace_args = (tensor([[0.1669, 0.9810, 0.8268]]),), trace_kwargs = {}
test_args = (tensor([[0.6081, 0.8063, 0.5904],
        [0.4448, 0.0870, 0.6136],
        [0.6710, 0.7469, 0.1505],
        [0.3721, 0.2842, 0.5610],
        [0.9397, 0.2866, 0.0427]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function cross_product_matrix at 0x7ff16aef7250>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.numeric.cross_product_matrix
____________________________________________________________________________ test_triangulate_points[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_triangulate_points(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4),
            torch.rand(1, 3, 4),
            torch.rand(1, 10, 2),
            torch.rand(1, 10, 2),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2, 3, 4),
            torch.rand(2, 3, 4),
            torch.rand(2, 20, 2),
            torch.rand(2, 20, 2),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.epipolar.triangulate_points,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            # NOTE: numerical instability in svd()/lu() leads to logits not being allclose
            deterministic=False,
        )

kornia/geometry/test_epipolar.py:625: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function triangulate_points at 0x7ff16aef7a30>
trace_args = (tensor([[[0.3577, 0.3874, 0.6287, 0.8795],
         [0.3994, 0.5174, 0.0827, 0.5995],
         [0.3826, 0.4533, 0.767...0.1636],
         [0.0135, 0.4098],
         [0.1890, 0.9408],
         [0.0502, 0.8855],
         [0.1910, 0.0887]]]))
trace_kwargs = {}
test_args = (tensor([[[0.2905, 0.1956, 0.6772, 0.8700],
         [0.8545, 0.9379, 0.9263, 0.7723],
         [0.7912, 0.7079, 0.216...0.0992],
         [0.8472, 0.5552],
         [0.5444, 0.4156],
         [0.8432, 0.8716],
         [0.6868, 0.2406]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function triangulate_points at 0x7ff16aef7a30>
trace_args = (tensor([[[0.3577, 0.3874, 0.6287, 0.8795],
         [0.3994, 0.5174, 0.0827, 0.5995],
         [0.3826, 0.4533, 0.767...0.1636],
         [0.0135, 0.4098],
         [0.1890, 0.9408],
         [0.0502, 0.8855],
         [0.1910, 0.0887]]]))
trace_kwargs = {}
test_args = (tensor([[[0.2905, 0.1956, 0.6772, 0.8700],
         [0.8545, 0.9379, 0.9263, 0.7723],
         [0.7912, 0.7079, 0.216...0.0992],
         [0.8472, 0.5552],
         [0.5444, 0.4156],
         [0.8432, 0.8716],
         [0.6868, 0.2406]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function triangulate_points at 0x7ff16aef7a30>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.epipolar.triangulation.triangulate_points
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_epipolar.py::test_find_essential[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet con...
FAILED kornia/geometry/test_epipolar.py::test_essential_from_fundamental[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key...
FAILED kornia/geometry/test_epipolar.py::test_decompose_essential_matrix[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/geometry/test_epipolar.py::test_motion_from_essential[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ens...
FAILED kornia/geometry/test_epipolar.py::test_motion_from_essential_choose_solution[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use...
FAILED kornia/geometry/test_epipolar.py::test_find_fundamental[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure y...
FAILED kornia/geometry/test_epipolar.py::test_sampson_epipolar_distance[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key,...
FAILED kornia/geometry/test_epipolar.py::test_symmetrical_epipolar_distance[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ...
FAILED kornia/geometry/test_epipolar.py::test_left_to_right_epipolar_distance[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an ap...
FAILED kornia/geometry/test_epipolar.py::test_right_to_left_epipolar_distance[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an ap...
FAILED kornia/geometry/test_epipolar.py::test_projection_from_KRt[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensur...
FAILED kornia/geometry/test_epipolar.py::test_projections_from_fundamental[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api k...
FAILED kornia/geometry/test_epipolar.py::test_intrinsics_like[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/geometry/test_epipolar.py::test_scale_intrinsics[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure y...
FAILED kornia/geometry/test_epipolar.py::test_random_intrinsics[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/geometry/test_epipolar.py::test_cross_product_matrix[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/geometry/test_epipolar.py::test_triangulate_points[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
=============================================================================== 17 failed, 9 passed in 173.33s (0:02:53) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 16 items

kornia/test_utils.py FFF...F...FFFFFF                                                                                                                                                            [100%]

=============================================================================================== FAILURES ===============================================================================================
_________________________________________________________________________________ test_draw_line[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_draw_line(target_framework, mode, backend_compile):
        trace_args = (
            torch.zeros((1, 8, 8)),
            torch.tensor([6, 4]),
            torch.tensor([1, 4]),
            torch.tensor([255]),
        )
        trace_kwargs = {}
        test_args = (
            torch.zeros((1, 8, 8)),
            torch.tensor([0, 2]),
            torch.tensor([5, 1]),
            torch.tensor([255]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.utils.draw_line,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_utils.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function draw_line at 0x7fe9ece15990>
trace_args = (tensor([[[0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0..., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0.]]]), tensor([6, 4]), tensor([1, 4]), tensor([255]))
trace_kwargs = {}
test_args = (tensor([[[0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0..., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0.]]]), tensor([0, 2]), tensor([5, 1]), tensor([255]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function draw_line at 0x7fe9ece15990>
trace_args = (tensor([[[0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0..., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0.]]]), tensor([6, 4]), tensor([1, 4]), tensor([255]))
trace_kwargs = {}
test_args = (tensor([[[0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0..., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0.]]]), tensor([0, 2]), tensor([5, 1]), tensor([255]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function draw_line at 0x7fe9ece15990>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.draw.draw_line
______________________________________________________________________________ test_draw_rectangle[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_draw_rectangle(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3, 10, 12),
            torch.tensor([[[0, 0, 4, 4]], [[4, 4, 10, 10]]]),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(3, 3, 10, 12),
            torch.tensor([[[0, 0, 4, 4]], [[4, 4, 10, 10]], [[2, 2, 6, 6]]]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.utils.draw_rectangle,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_utils.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function draw_rectangle at 0x7fe9ece15a20>
trace_args = (tensor([[[[0.3661, 0.1762, 0.7776, 0.7873, 0.1067, 0.9449, 0.7279, 0.2891,
           0.4900, 0.3946, 0.3850, 0.3678]...148, 0.0410,
           0.2792, 0.8155, 0.4496, 0.2255]]]]), tensor([[[ 0,  0,  4,  4]],

        [[ 4,  4, 10, 10]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.7644, 0.6768, 0.4288,  ..., 0.0940, 0.4453, 0.5551],
          [0.7874, 0.4390, 0.8830,  ..., 0.2234, 0....., 0.6133, 0.6903, 0.0045]]]]), tensor([[[ 0,  0,  4,  4]],

        [[ 4,  4, 10, 10]],

        [[ 2,  2,  6,  6]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function draw_rectangle at 0x7fe9ece15a20>
trace_args = (tensor([[[[0.3661, 0.1762, 0.7776, 0.7873, 0.1067, 0.9449, 0.7279, 0.2891,
           0.4900, 0.3946, 0.3850, 0.3678]...148, 0.0410,
           0.2792, 0.8155, 0.4496, 0.2255]]]]), tensor([[[ 0,  0,  4,  4]],

        [[ 4,  4, 10, 10]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.7644, 0.6768, 0.4288,  ..., 0.0940, 0.4453, 0.5551],
          [0.7874, 0.4390, 0.8830,  ..., 0.2234, 0....., 0.6133, 0.6903, 0.0045]]]]), tensor([[[ 0,  0,  4,  4]],

        [[ 4,  4, 10, 10]],

        [[ 2,  2,  6,  6]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function draw_rectangle at 0x7fe9ece15a20>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.draw.draw_rectangle
____________________________________________________________________________ test_draw_convex_polygon[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_draw_convex_polygon(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 12, 16),
            torch.tensor([[[4, 4], [12, 4], [12, 8], [4, 8]]]),
            torch.tensor([0.5, 0.5, 0.5]),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2, 3, 12, 16),
            torch.tensor([[[4, 4], [12, 4], [12, 8], [4, 8]], [[3, 3], [10, 3], [10, 7], [3, 7]]]),
            torch.tensor([0.5, 0.5, 0.5]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.utils.draw_convex_polygon,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_utils.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function draw_convex_polygon at 0x7fe9ece15bd0>
trace_args = (tensor([[[[5.9121e-01, 9.9469e-01, 3.1544e-01, 7.5602e-01, 5.4540e-01,
           6.3798e-01, 6.9541e-01, 6.4027e-01,...]]]]), tensor([[[ 4,  4],
         [12,  4],
         [12,  8],
         [ 4,  8]]]), tensor([0.5000, 0.5000, 0.5000]))
trace_kwargs = {}
test_args = (tensor([[[[8.6764e-01, 3.3737e-01, 9.3046e-01,  ..., 7.5297e-01,
           5.7149e-01, 6.5173e-01],
          [6.610... 8]],

        [[ 3,  3],
         [10,  3],
         [10,  7],
         [ 3,  7]]]), tensor([0.5000, 0.5000, 0.5000]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function draw_convex_polygon at 0x7fe9ece15bd0>
trace_args = (tensor([[[[5.9121e-01, 9.9469e-01, 3.1544e-01, 7.5602e-01, 5.4540e-01,
           6.3798e-01, 6.9541e-01, 6.4027e-01,...]]]]), tensor([[[ 4,  4],
         [12,  4],
         [12,  8],
         [ 4,  8]]]), tensor([0.5000, 0.5000, 0.5000]))
trace_kwargs = {}
test_args = (tensor([[[[8.6764e-01, 3.3737e-01, 9.3046e-01,  ..., 7.5297e-01,
           5.7149e-01, 6.5173e-01],
          [6.610... 8]],

        [[ 3,  3],
         [10,  3],
         [10,  7],
         [ 3,  7]]]), tensor([0.5000, 0.5000, 0.5000]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function draw_convex_polygon at 0x7fe9ece15bd0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.draw.draw_convex_polygon
______________________________________________________________________________ test_tensor_to_image[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_tensor_to_image(target_framework, mode, backend_compile):
        print("kornia.utils.tensor_to_image")
    
        if backend_compile:
            pytest.skip()
    
        transpiled_func = ivy.transpile(kornia.utils.tensor_to_image, source="torch", target=target_framework)
    
        tensor = torch.ones(1, 3, 3)
        transpiled_tensor = _nest_torch_tensor_to_new_framework(tensor, target_framework)
        torch_image = kornia.utils.tensor_to_image(tensor)
>       transpiled_image = transpiled_func(transpiled_tensor)

kornia/test_utils.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tensor = <tf.Tensor: shape=(1, 3, 3), dtype=float32, numpy=
array([[[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]]], dtype=float32)>, keepdim = False, force_contiguous = False

    def tensorflow_tensor_to_image(tensor, keepdim=False, force_contiguous=False):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_detach_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_cpu_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_squeeze_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_permute_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_contiguous_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_numpy_frnt_
    
        if not isinstance(tensor, (tensorflow.Tensor, tensorflow.Variable)):
            raise TypeError(f"Input type is not a Tensor. Got {type(tensor)}")
        if (
            len(tensorflow_shape_frnt_(tensor)) > 4
            or len(tensorflow_shape_frnt_(tensor)) < 2
        ):
            raise ValueError("Input size must be a two, three or four dimensional tensor")
        input_shape = tensorflow_shape_frnt_(tensor)
        image = tensorflow_detach_frnt_(tensorflow_cpu_frnt_(tensor))
        if len(input_shape) == 2:
            pass
        elif len(input_shape) == 3:
            if input_shape[0] == 1:
                image = tensorflow_squeeze_frnt_(image)
            else:
                image = tensorflow_permute_frnt_(image, 1, 2, 0)
        elif len(input_shape) == 4:
            image = tensorflow_permute_frnt_(image, 0, 2, 3, 1)
            if input_shape[0] == 1 and not keepdim:
                image = tensorflow_squeeze_frnt_(image, 0)
            if input_shape[1] == 1:
                image = tensorflow_squeeze_frnt_(image, -1)
        else:
            raise ValueError(f"Cannot process tensor with shape {input_shape}")
        if force_contiguous:
            image = tensorflow_contiguous_frnt_(image)
>       return tensorflow_numpy_frnt_(image)

Translated_Outputs/tensorflow_outputs/kornia/utils/image.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<tf.Tensor: shape=(3, 3), dtype=float32, numpy=
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]], dtype=float32)>,), kwargs = {}
tensorflow_is_array_bknd = <function tensorflow_is_array_bknd at 0x7fe9e5a10310>
array_like = <tf.Tensor: shape=(3, 3), dtype=float32, numpy=
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]], dtype=float32)>

    @functools.wraps(fn)
    def wrapper(*args, **kwargs):
        from ..functional.ivy.general import tensorflow_is_array_bknd
    
        array_like = args[0]
        if isinstance(array_like, (list, tuple)):
            array_like = array_like[0]
        if tensorflow_is_array_bknd(array_like):
>           return fn(*args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tensor = <tf.Tensor: shape=(3, 3), dtype=float32, numpy=
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]], dtype=float32)>

    @tensorflow_handle_methods
    def tensorflow_numpy_frnt_(tensor):
>       return np_frontend_array(tensor)
E       NameError: name 'np_frontend_array' is not defined

Translated_Outputs/tensorflow_outputs/ivy/functional/frontends/torch/tensor.py:164: NameError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.tensor_to_image

Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling tensor_to_image from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
                                                                                                                                             
Transpilation of tensor_to_image complete.
____________________________________________________________________________ test_save_pointcloud_ply[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_save_pointcloud_ply(target_framework, mode, backend_compile):
        print("kornia.utils.save_pointcloud_ply")
    
        if backend_compile:
            pytest.skip()
    
        pointcloud = torch.rand(100, 3)
        transpiled_pointcloud = _nest_torch_tensor_to_new_framework(pointcloud, target_framework)
    
        with tempfile.NamedTemporaryFile(suffix=".ply") as temp_file:
            filename = temp_file.name
    
>           transpiled_save_pointcloud = ivy.transpile(kornia.utils.save_pointcloud_ply, source="torch", target=target_framework)

kornia/test_utils.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function save_pointcloud_ply at 0x7fe9ece88c10>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.save_pointcloud_ply
_______________________________________________________________________ test_get_cuda_device_if_available[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_cuda_device_if_available(target_framework, mode, backend_compile):
        print("kornia.utils.get_cuda_device_if_available")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_get_cuda_device_if_available = ivy.transpile(kornia.utils.get_cuda_device_if_available, source="torch", target=target_framework)

kornia/test_utils.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_cuda_device_if_available at 0x7fe9ece163b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.get_cuda_device_if_available
________________________________________________________________________ test_get_mps_device_if_available[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_mps_device_if_available(target_framework, mode, backend_compile):
        print("kornia.utils.get_mps_device_if_available")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_get_mps_device_if_available = ivy.transpile(kornia.utils.get_mps_device_if_available, source="torch", target=target_framework)

kornia/test_utils.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_mps_device_if_available at 0x7fe9ece16440>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.get_mps_device_if_available
____________________________________________________________________ test_get_cuda_or_mps_device_if_available[tensorflow-s2s-False] ____________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_cuda_or_mps_device_if_available(target_framework, mode, backend_compile):
        print("kornia.utils.get_cuda_or_mps_device_if_available")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_get_cuda_or_mps_device_if_available = ivy.transpile(kornia.utils.get_cuda_or_mps_device_if_available, source="torch", target=target_framework)

kornia/test_utils.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_cuda_or_mps_device_if_available at 0x7fe9ece164d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.get_cuda_or_mps_device_if_available
____________________________________________________________________________ test_map_location_to_cpu[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_map_location_to_cpu(target_framework, mode, backend_compile):
        print("kornia.utils.map_location_to_cpu")
    
        if backend_compile:
            pytest.skip()
    
        tensor = torch.rand(3, 3)
        transpiled_tensor = _nest_torch_tensor_to_new_framework(tensor, target_framework)
    
>       transpiled_func = ivy.transpile(kornia.utils.map_location_to_cpu, source="torch", target=target_framework)

kornia/test_utils.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function map_location_to_cpu at 0x7fe9ece16560>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.map_location_to_cpu
____________________________________________________________________________ test_is_autocast_enabled[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_is_autocast_enabled(target_framework, mode, backend_compile):
        print("kornia.utils.is_autocast_enabled")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_func = ivy.transpile(kornia.utils.is_autocast_enabled, source="torch", target=target_framework)

kornia/test_utils.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function is_autocast_enabled at 0x7fe9ece16b00>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.utils.is_autocast_enabled
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_utils.py::test_draw_line[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_utils.py::test_draw_rectangle[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_utils.py::test_draw_convex_polygon[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/test_utils.py::test_tensor_to_image[tensorflow-s2s-False] - NameError: name 'np_frontend_array' is not defined
FAILED kornia/test_utils.py::test_save_pointcloud_ply[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/test_utils.py::test_get_cuda_device_if_available[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure y...
FAILED kornia/test_utils.py::test_get_mps_device_if_available[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/test_utils.py::test_get_cuda_or_mps_device_if_available[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, e...
FAILED kornia/test_utils.py::test_map_location_to_cpu[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/test_utils.py::test_is_autocast_enabled[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
=============================================================================== 10 failed, 6 passed in 195.47s (0:03:15) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 1 item

kornia/geometry/test_quaternion.py .                                                                                                                                                             [100%]

--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
==================================================================================== 1 passed in 127.48s (0:02:07) =====================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 4 items

kornia/test_sensors.py FF..                                                                                                                                                                      [100%]

=============================================================================================== FAILURES ===============================================================================================
________________________________________________________________________________ test_CameraModel[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_CameraModel(target_framework, mode, backend_compile):
        print("kornia.sensors.camera.CameraModel")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledImageSize = ivy.transpile(kornia.image.ImageSize, source="torch", target=target_framework)
        TranspiledCameraModelType = ivy.transpile(CameraModelType, source="torch", target=target_framework)
>       TranspiledCameraModel = ivy.transpile(CameraModel, source="torch", target=target_framework)

kornia/test_sensors.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.sensors.camera.camera_model.CameraModel'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.sensors.camera.CameraModel

Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                    
Transpilation of ImageSize complete.

Transpiling CameraModelType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling CameraModelType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling CameraModelType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling CameraModelType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling CameraModelType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling CameraModelType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                          
Transpilation of CameraModelType complete.
_______________________________________________________________________________ test_PinholeModel[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PinholeModel(target_framework, mode, backend_compile):
        print("kornia.sensors.camera.PinholeModel")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledImageSize = ivy.transpile(kornia.image.ImageSize, source="torch", target=target_framework)
>       TranspiledPinholeModel = ivy.transpile(PinholeModel, source="torch", target=target_framework)

kornia/test_sensors.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.sensors.camera.camera_model.PinholeModel'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.sensors.camera.PinholeModel
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_sensors.py::test_CameraModel[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_sensors.py::test_PinholeModel[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
=============================================================================== 2 failed, 2 passed in 115.19s (0:01:55) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 2 items

kornia/geometry/test_boxes.py FF                                                                                                                                                                 [100%]

=============================================================================================== FAILURES ===============================================================================================
___________________________________________________________________________________ test_Boxes[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Boxes(target_framework, mode, backend_compile):
        print("kornia.geometry.boxes.Boxes")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledBoxes = ivy.transpile(kornia.geometry.boxes.Boxes, source="torch", target=target_framework)
    
        torch_args = (
            torch.as_tensor([[0, 3, 1, 4], [5, 1, 8, 4]]),
        )
        transpiled_args = _nest_torch_tensor_to_new_framework(torch_args, target_framework)
    
        # test .from_tensor
        torch_boxes = kornia.geometry.boxes.Boxes.from_tensor(*torch_args, mode="xyxy")
        transpiled_boxes = TranspiledBoxes.from_tensor(*transpiled_args, mode="xyxy")
        _check_boxes_same(torch_boxes, transpiled_boxes)
    
        # test .compute_area
        torch_area = torch_boxes.compute_area()
        transpiled_area = transpiled_boxes.compute_area()
        _to_numpy_and_allclose(torch_area, transpiled_area)
    
        # test .get_boxes_shape
        torch_heights, torch_widths = torch_boxes.get_boxes_shape()
        transpiled_heights, transpiled_widths = transpiled_boxes.get_boxes_shape()
        _to_numpy_and_allclose(torch_heights, transpiled_heights)
        _to_numpy_and_allclose(torch_widths, transpiled_widths)
    
        # test .merge
        torch_x = torch.as_tensor([[6, 6, 10, 10], [6, 6, 10, 10]])
        transpiled_x = _nest_torch_tensor_to_new_framework(torch_x, target_framework)
        merge_boxes = kornia.geometry.boxes.Boxes.from_tensor(torch_x, mode="xyxy")
        transpiled_merge_boxes = TranspiledBoxes.from_tensor(transpiled_x, mode="xyxy")
        torch_merged_boxes = torch_boxes.merge(merge_boxes)
        transpiled_merged_boxes = transpiled_boxes.merge(transpiled_merge_boxes)
        _check_boxes_same(torch_merged_boxes, transpiled_merged_boxes)
    
        # test .to_mask
        height, width = 10, 10
        torch_mask = torch_boxes.to_mask(height, width)
        transpiled_mask = transpiled_boxes.to_mask(height, width)
>       _to_numpy_and_allclose(torch_mask, transpiled_mask)

kornia/geometry/test_boxes.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0....., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]])
transpiled_x = <tf.Tensor: shape=(2, 10, 10), dtype=float32, numpy=
array([[[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0....,
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]], dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0...],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]], dtype=float32)
y = array([[[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0...],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]], dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.boxes.Boxes

Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                
Transpilation of Boxes complete.
__________________________________________________________________________________ test_Boxes3D[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Boxes3D(target_framework, mode, backend_compile):
        print("kornia.geometry.boxes.Boxes3D")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledBoxes3D = ivy.transpile(kornia.geometry.boxes.Boxes3D, source="torch", target=target_framework)
    
        torch_args = (
            torch.as_tensor([[0, 3, 6, 1, 4, 8], [5, 1, 3, 8, 4, 9]]),
        )
        transpiled_args = _nest_torch_tensor_to_new_framework(torch_args, target_framework)
    
        # test .from_tensor
        torch_boxes3d = kornia.geometry.boxes.Boxes3D.from_tensor(*torch_args, mode="xyzxyz")
        transpiled_boxes3d = TranspiledBoxes3D.from_tensor(*transpiled_args, mode="xyzxyz")
        _check_boxes_same(torch_boxes3d, transpiled_boxes3d)
    
        # test .get_boxes_shape
        torch_depths, torch_heights, torch_widths = torch_boxes3d.get_boxes_shape()
        transpiled_depths, transpiled_heights, transpiled_widths = transpiled_boxes3d.get_boxes_shape()
        _to_numpy_and_allclose(torch_depths, transpiled_depths)
        _to_numpy_and_allclose(torch_heights, transpiled_heights)
        _to_numpy_and_allclose(torch_widths, transpiled_widths)
    
        # test .to_mask
        depth, height, width = 10, 10, 10
        torch_mask = torch_boxes3d.to_mask(depth, height, width)
        transpiled_mask = transpiled_boxes3d.to_mask(depth, height, width)
>       _to_numpy_and_allclose(torch_mask, transpiled_mask)

kornia/geometry/test_boxes.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0., 0., 0.,  ..., 0., 0., 0.],
          [0., 0., 0.,  ..., 0., 0., 0.],
          [0., 0., 0.,  ..., 0., 0... [0., 0., 0.,  ..., 0., 0., 0.],
          [0., 0., 0.,  ..., 0., 0., 0.],
          [0., 0., 0.,  ..., 0., 0., 0.]]]])
transpiled_x = <tf.Tensor: shape=(2, 10, 10, 10), dtype=float32, numpy=
array([[[[0., 0., 0., ..., 0., 0., 0.],
         [0., 0., 0.,...., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.]]]], dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0., 0., 0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.]...0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.]]]], dtype=float32)
y = array([[[[0., 0., 0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.]...0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.],
         [0., 0., 0., ..., 0., 0., 0.]]]], dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.boxes.Boxes3D

Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Boxes3D from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                  
Transpilation of Boxes3D complete.
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_boxes.py::test_Boxes[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/geometry/test_boxes.py::test_Boxes3D[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
==================================================================================== 2 failed in 173.20s (0:02:53) =====================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 8 items

kornia/test_image.py FFFFF.FF                                                                                                                                                                    [100%]

=============================================================================================== FAILURES ===============================================================================================
_________________________________________________________________________________ test_ImageSize[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ImageSize(target_framework, mode, backend_compile):
        print("kornia.image.ImageSize")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledImageSize = ivy.transpile(kornia.image.ImageSize, source="torch", target=target_framework)

kornia/test_image.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.image.base.ImageSize'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.image.ImageSize
________________________________________________________________________________ test_PixelFormat[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PixelFormat(target_framework, mode, backend_compile):
        print("kornia.image.PixelFormat")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledPixelFormat = ivy.transpile(kornia.image.PixelFormat, source="torch", target=target_framework)

kornia/test_image.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.image.base.PixelFormat'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.image.PixelFormat
_______________________________________________________________________________ test_ChannelsOrder[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ChannelsOrder(target_framework, mode, backend_compile):
        print("kornia.image.ChannelsOrder")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledChannelsOrder = ivy.transpile(kornia.image.ChannelsOrder, source="torch", target=target_framework)

kornia/test_image.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <enum 'ChannelsOrder'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.image.ChannelsOrder
________________________________________________________________________________ test_ImageLayout[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ImageLayout(target_framework, mode, backend_compile):
        print("kornia.image.ImageLayout")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledImageSize = ivy.transpile(kornia.image.ImageSize, source="torch", target=target_framework)

kornia/test_image.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.image.base.ImageSize'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.image.ImageLayout
___________________________________________________________________________________ test_Image[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Image(target_framework, mode, backend_compile):
        print("kornia.image.Image")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledImageSize = ivy.transpile(kornia.image.ImageSize, source="torch", target=target_framework)
        TranspiledPixelFormat = ivy.transpile(kornia.image.PixelFormat, source="torch", target=target_framework)
        TranspiledChannelsOrder = ivy.transpile(kornia.image.ChannelsOrder, source="torch", target=target_framework)
        TranspiledImageLayout = ivy.transpile(kornia.image.ImageLayout, source="torch", target=target_framework)
        TranspiledImage = ivy.transpile(kornia.image.Image, source="torch", target=target_framework)
    
        torch_data = torch.randint(0, 255, (3, 4, 5), dtype=torch.uint8)
        transpiled_data = _array_to_new_backend(torch_data, target_framework)
    
        # torch
        pixel_format = kornia.image.PixelFormat(
            color_space=ColorSpace.rgb,
            bit_depth=8,
        )
        layout = kornia.image.ImageLayout(
            image_size=kornia.image.ImageSize(4, 5),
            channels=3,
            channels_order=kornia.image.ChannelsOrder.CHANNELS_FIRST,
        )
        torch_img = kornia.image.Image(torch_data, pixel_format, layout)
    
        # transpiled
        pixel_format = TranspiledPixelFormat(
            color_space=ColorSpace.rgb,
            bit_depth=8,
        )
        layout = TranspiledImageLayout(
            image_size=TranspiledImageSize(4, 5),
            channels=3,
            channels_order=TranspiledChannelsOrder.CHANNELS_FIRST,
        )
        transpiled_img = TranspiledImage(transpiled_data, pixel_format, layout)
        assert transpiled_img.channels == 3
    
>       assert dir(torch_img) == dir(transpiled_img), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_img)} != transpiled: {dir(transpiled_img)}"
E       AssertionError: attributes/methods of transpiled object do not align with the original - orig: ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_data', '_layout', '_pixel_format', 'channels', 'channels_order', 'clone', 'data', 'device', 'dtype', 'float', 'from_dlpack', 'from_file', 'from_numpy', 'height', 'image_size', 'layout', 'pixel_format', 'print', 'shape', 'to', 'to_color_space', 'to_dlpack', 'to_numpy', 'width', 'write'] != transpiled: ['__already_s2s', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_data', '_layout', '_pixel_format', 'channels', 'channels_order', 'clone', 'data', 'device', 'dtype', 'float', 'from_dlpack', 'from_file', 'from_numpy', 'height', 'image_size', 'layout', 'pixel_format', 'print', 'shape', 'to', 'to_color_space', 'to_dlpack', 'to_numpy', 'width', 'write']
E       assert ['__class__',...'__eq__', ...] == ['__already_s...__doc__', ...]
E         
E         At index 0 diff: '__class__' != '__already_s2s'
E         Right contains one more item: 'write'
E         Use -v to get more diff

kornia/test_image.py:114: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.image.Image

Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                    
Transpilation of ImageSize complete.

Transpiling PixelFormat from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PixelFormat from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PixelFormat from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PixelFormat from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PixelFormat from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PixelFormat from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                      
Transpilation of PixelFormat complete.

Transpiling ChannelsOrder from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ChannelsOrder from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ChannelsOrder from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ChannelsOrder from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ChannelsOrder from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ChannelsOrder from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                        
Transpilation of ChannelsOrder complete.

Transpiling ImageLayout from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageLayout from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageLayout from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageLayout from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageLayout from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageLayout from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                      
Transpilation of ImageLayout complete.

Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling Image from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                
Transpilation of Image complete.
_____________________________________________________________________________ test_Image_from_dlpack[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Image_from_dlpack(target_framework, mode, backend_compile):
        print("kornia.image.Image.from_dlpack")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledImage = ivy.transpile(kornia.image.Image, source="torch", target=target_framework)
    
        x = np.ones((4, 5, 3))
>       img = TranspiledImage.from_dlpack(x.__dlpack__())

kornia/test_image.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'Translated_Outputs.tensorflow_outputs.kornia.image.image.tensorflow_Image'>, data = <capsule object "dltensor" at 0x7fc6ce8427c0>

    @classmethod
    def from_dlpack(cls, data):
        from ...ivy.functional.frontends.torch.tensor import (
            tensorflow_element_size_frnt_,
        )
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from .base import tensorflow_ImageSize
        from .base import tensorflow_PixelFormat
        from .base import tensorflow_ImageLayout
        from ...ivy.data_classes.array.creation import tensorflow_from_dlpack_bknd_
    
>       _data: typing.Any = tensorflow_from_dlpack_bknd_(torch.utils.dlpack, data)
E       NameError: name 'torch' is not defined

Translated_Outputs/tensorflow_outputs/kornia/image/image.py:198: NameError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.image.Image.from_dlpack
______________________________________________________________________________ test_Image_to_numpy[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Image_to_numpy(target_framework, mode, backend_compile):
        print("kornia.image.Image.to_numpy")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledImage = ivy.transpile(kornia.image.Image, source="torch", target=target_framework)
    
        data = np.ones((4, 5, 3), dtype=np.uint8)
        img = TranspiledImage.from_numpy(data, color_space=ColorSpace.rgb)
>       img_data = img.to_numpy()

kornia/test_image.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Image data: [[[1 1 1]
  [1 1 1]
  [1 1 1]
  [1 1 1]
  [1 1 1]]

 [[1 1 1]
  [1 1 1]
  [1 1 1]
  [1 1 1]
  [1 1 1]]

 [...e_size=tensorflow_ImageSize(height=4, width=5), channels=3, channels_order=<tensorflow_ChannelsOrder.CHANNELS_LAST: 1>)

    def to_numpy(self):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_numpy_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_detach_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_cpu_frnt_
    
>       return tensorflow_numpy_frnt_(
            tensorflow_detach_frnt_(tensorflow_cpu_frnt_(self.data))
        )

Translated_Outputs/tensorflow_outputs/kornia/image/image.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<tf.Tensor: shape=(4, 5, 3), dtype=uint8, numpy=
array([[[1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1,... 1]],

       [[1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1]]], dtype=uint8)>,)
kwargs = {}, tensorflow_is_array_bknd = <function tensorflow_is_array_bknd at 0x7fc6cd4305e0>
array_like = <tf.Tensor: shape=(4, 5, 3), dtype=uint8, numpy=
array([[[1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1, ...1, 1]],

       [[1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1]]], dtype=uint8)>

    @functools.wraps(fn)
    def wrapper(*args, **kwargs):
        from ..functional.ivy.general import tensorflow_is_array_bknd
    
        array_like = args[0]
        if isinstance(array_like, (list, tuple)):
            array_like = array_like[0]
        if tensorflow_is_array_bknd(array_like):
>           return fn(*args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tensor = <tf.Tensor: shape=(4, 5, 3), dtype=uint8, numpy=
array([[[1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1, ...1, 1]],

       [[1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1]]], dtype=uint8)>

    @tensorflow_handle_methods
    def tensorflow_numpy_frnt_(tensor):
>       return np_frontend_array(tensor)
E       NameError: name 'np_frontend_array' is not defined

Translated_Outputs/tensorflow_outputs/ivy/functional/frontends/torch/tensor.py:176: NameError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.image.Image.to_numpy
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_image.py::test_ImageSize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_image.py::test_PixelFormat[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_image.py::test_ChannelsOrder[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_image.py::test_ImageLayout[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_image.py::test_Image[tensorflow-s2s-False] - AssertionError: attributes/methods of transpiled object do not align with the original - orig: ['__class__', '__delattr__', '__dict__...
FAILED kornia/test_image.py::test_Image_from_dlpack[tensorflow-s2s-False] - NameError: name 'torch' is not defined
FAILED kornia/test_image.py::test_Image_to_numpy[tensorflow-s2s-False] - NameError: name 'np_frontend_array' is not defined
=============================================================================== 7 failed, 1 passed in 250.97s (0:04:10) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 2 items

kornia/geometry/test_vector.py FF                                                                                                                                                                [100%]

=============================================================================================== FAILURES ===============================================================================================
__________________________________________________________________________________ test_Vector3[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Vector3(target_framework, mode, backend_compile):
        print("kornia.geometry.vector.Vector3")
    
        if backend_compile:
            pytest.skip()
    
        # Initialize a Vector3 with a tensor
        vector = torch.tensor([1.0, 2.0, 3.0], requires_grad=True)
        torch_vector3 = kornia.geometry.vector.Vector3(vector)
    
        # Transpile the Vector3 class
>       TranspiledVector3 = ivy.transpile(kornia.geometry.vector.Vector3, source="torch", target=target_framework)

kornia/geometry/test_vector.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.vector.Vector3'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.vector.Vector3
__________________________________________________________________________________ test_Vector2[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Vector2(target_framework, mode, backend_compile):
        print("kornia.geometry.vector.Vector2")
    
        if backend_compile:
            pytest.skip()
    
        # Initialize a Vector2 with a tensor
        vector = torch.tensor([1.0, 2.0], requires_grad=True)
        torch_vector2 = kornia.geometry.vector.Vector2(vector)
    
        # Transpile the Vector2 class
>       TranspiledVector2 = ivy.transpile(kornia.geometry.vector.Vector2, source="torch", target=target_framework)

kornia/geometry/test_vector.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.vector.Vector2'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.vector.Vector2
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_vector.py::test_Vector3[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/geometry/test_vector.py::test_Vector2[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
========================================================================================== 2 failed in 5.81s ===========================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 5 items

kornia/test_x.py sFFsF                                                                                                                                                                           [100%]

=============================================================================================== FAILURES ===============================================================================================
________________________________________________________________________ test_SemanticSegmentationTrainer[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SemanticSegmentationTrainer(target_framework, mode, backend_compile):
        print("kornia.x.SemanticSegmentationTrainer")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSemanticSegmentationTrainer = ivy.transpile(kornia.x.SemanticSegmentationTrainer, source="torch", target=target_framework)

kornia/test_x.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.x.trainers.SemanticSegmentationTrainer'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.x.SemanticSegmentationTrainer
__________________________________________________________________________ test_ObjectDetectionTrainer[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ObjectDetectionTrainer(target_framework, mode, backend_compile):
        print("kornia.x.ObjectDetectionTrainer")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledObjectDetectionTrainer = ivy.transpile(kornia.x.ObjectDetectionTrainer, source="torch", target=target_framework)

kornia/test_x.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.x.trainers.ObjectDetectionTrainer'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.x.ObjectDetectionTrainer
_______________________________________________________________________________ test_EarlyStopping[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_EarlyStopping(target_framework, mode, backend_compile):
        print("kornia.x.EarlyStopping")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledEarlyStopping = ivy.transpile(kornia.x.EarlyStopping, source="torch", target=target_framework)

kornia/test_x.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.x.callbacks.EarlyStopping'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.x.EarlyStopping
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_x.py::test_SemanticSegmentationTrainer[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do...
FAILED kornia/test_x.py::test_ObjectDetectionTrainer[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/test_x.py::test_EarlyStopping[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
=============================================================================== 3 failed, 2 skipped in 88.74s (0:01:28) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 3 items

kornia/augmentation/test_auto.py FFF                                                                                                                                                             [100%]

=============================================================================================== FAILURES ===============================================================================================
________________________________________________________________________________ test_AutoAugment[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_AutoAugment(target_framework, mode, backend_compile):
        print("kornia.augmentation.auto.AutoAugment")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledAutoAugment = ivy.transpile(
            kornia.augmentation.auto.AutoAugment,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_auto.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.auto.autoaugment.autoaugment.AutoAugment'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation._2d.mix.base: cannot import name 'ivy__BasicAugmentationBase' from 'Translated_Outputs.ivy_outputs.kornia.augmentation.base' (/ivy/ivy-integration-tests/Translated_Outputs/ivy_outputs/kornia/augmentation/base.py)

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.auto.AutoAugment

Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AutoAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                      
________________________________________________________________________________ test_RandAugment[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandAugment(target_framework, mode, backend_compile):
        print("kornia.augmentation.auto.RandAugment")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledRandAugment = ivy.transpile(
            kornia.augmentation.auto.RandAugment,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_auto.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.auto.rand_augment.rand_augment.RandAugment'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation._2d.mix.base: cannot import name 'ivy__BasicAugmentationBase' from 'Translated_Outputs.ivy_outputs.kornia.augmentation.base' (/ivy/ivy-integration-tests/Translated_Outputs/ivy_outputs/kornia/augmentation/base.py)

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.auto.RandAugment

Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandAugment from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                      
______________________________________________________________________________ test_TrivialAugment[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_TrivialAugment(target_framework, mode, backend_compile):
        print("kornia.augmentation.auto.TrivialAugment")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledTrivialAugment = ivy.transpile(
            kornia.augmentation.auto.TrivialAugment,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_auto.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.auto.trivial_augment.trivial_augment.TrivialAugment'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.auto.TrivialAugment
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/augmentation/test_auto.py::test_AutoAugment[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation._2d.mix....
FAILED kornia/augmentation/test_auto.py::test_RandAugment[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation._2d.mix....
FAILED kornia/augmentation/test_auto.py::test_TrivialAugment[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
==================================================================================== 3 failed in 303.96s (0:05:03) =====================================================================================


========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 1 item

transformers/test_vision.py .                                                                                                                                                                    [100%]

--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
==================================================================================== 1 passed in 996.29s (0:16:36) =====================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 1 item

kornia/test_tracking.py F                                                                                                                                                                        [100%]

=============================================================================================== FAILURES ===============================================================================================
_____________________________________________________________________________ test_HomographyTracker[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_HomographyTracker(target_framework, mode, backend_compile):
        print("kornia.tracking.HomographyTracker")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledHomographyTracker = ivy.transpile(kornia.tracking.HomographyTracker, source="torch", target=target_framework)

kornia/test_tracking.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.tracking.planar_tracker.HomographyTracker'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.tracking.HomographyTracker
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_tracking.py::test_HomographyTracker[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
========================================================================================== 1 failed in 5.85s ===========================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 38 items

kornia/geometry/test_conversions.py .....FF....F.......FFFFFFFFFFFFF.F....                                                                                                                       [100%]

=============================================================================================== FAILURES ===============================================================================================
______________________________________________________________________ test_convert_points_from_homogeneous[tensorflow-s2s-False] ______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_convert_points_from_homogeneous(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.convert_points_from_homogeneous,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function convert_points_from_homogeneous at 0x7fd5cd0ac820>, trace_args = (tensor([[0.0697, 0.0426, 0.7932]]),), trace_kwargs = {}
test_args = (tensor([[0.8987, 0.6304, 0.5151],
        [0.2098, 0.6766, 0.3281],
        [0.7669, 0.8367, 0.9586],
        [0.9076, 0.8478, 0.1412],
        [0.4318, 0.8257, 0.1966]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function convert_points_from_homogeneous at 0x7fd5cd0ac820>, trace_args = (tensor([[0.0697, 0.0426, 0.7932]]),), trace_kwargs = {}
test_args = (tensor([[0.8987, 0.6304, 0.5151],
        [0.2098, 0.6766, 0.3281],
        [0.7669, 0.8367, 0.9586],
        [0.9076, 0.8478, 0.1412],
        [0.4318, 0.8257, 0.1966]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function convert_points_from_homogeneous at 0x7fd5cd0ac820>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.convert_points_from_homogeneous
_______________________________________________________________________ test_convert_points_to_homogeneous[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_convert_points_to_homogeneous(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 2),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 2),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.convert_points_to_homogeneous,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function convert_points_to_homogeneous at 0x7fd5cd0ac8b0>, trace_args = (tensor([[0.8550, 0.1322]]),), trace_kwargs = {}
test_args = (tensor([[0.2137, 0.9644],
        [0.1589, 0.9318],
        [0.7775, 0.3932],
        [0.3228, 0.9555],
        [0.2769, 0.0160]]),), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function convert_points_to_homogeneous at 0x7fd5cd0ac8b0>, trace_args = (tensor([[0.8550, 0.1322]]),), trace_kwargs = {}
test_args = (tensor([[0.2137, 0.9644],
        [0.1589, 0.9318],
        [0.7775, 0.3932],
        [0.3228, 0.9555],
        [0.2769, 0.0160]]),), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function convert_points_to_homogeneous at 0x7fd5cd0ac8b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.convert_points_to_homogeneous
_______________________________________________________________________ test_normalize_pixel_coordinates3d[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_normalize_pixel_coordinates3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3),
            32,
            64,
            64,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3),
            64,
            128,
            128,
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.normalize_pixel_coordinates3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function normalize_pixel_coordinates3d at 0x7fd5cd0ad6c0>, trace_args = (tensor([[0.0410, 0.0845, 0.6403]]), 32, 64, 64), trace_kwargs = {}
test_args = (tensor([[0.6867, 0.2843, 0.2348],
        [0.4162, 0.3165, 0.3732],
        [0.0357, 0.1417, 0.6964],
        [0.8841, 0.3132, 0.9029],
        [0.9678, 0.8593, 0.0798]]), 64, 128, 128)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function normalize_pixel_coordinates3d at 0x7fd5cd0ad6c0>, trace_args = (tensor([[0.0410, 0.0845, 0.6403]]), 32, 64, 64), trace_kwargs = {}
test_args = (tensor([[0.6867, 0.2843, 0.2348],
        [0.4162, 0.3165, 0.3732],
        [0.0357, 0.1417, 0.6964],
        [0.8841, 0.3132, 0.9029],
        [0.9678, 0.8593, 0.0798]]), 64, 128, 128)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function normalize_pixel_coordinates3d at 0x7fd5cd0ad6c0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.normalize_pixel_coordinates3d
___________________________________________________________________________ test_quaternion_log_to_exp[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_quaternion_log_to_exp(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn(1, 3),
        )
        trace_kwargs = {'eps': 1.0e-12}
        test_args = (
            torch.randn(5, 3),
        )
        test_kwargs = {'eps': 1.0e-12}
>       _test_function(
            kornia.geometry.conversions.quaternion_log_to_exp,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:452: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function quaternion_log_to_exp at 0x7fd5cd0ad090>, trace_args = (tensor([[-0.5805, -0.6076, -1.9904]]),), trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[ 0.0624,  1.1245, -0.4072],
        [-1.1118, -0.5000, -1.7205],
        [ 0.3696,  1.2798, -1.7118],
        [ 0.2276,  1.8630,  0.5187],
        [-0.4080, -1.4934, -1.0799]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function quaternion_log_to_exp at 0x7fd5cd0ad090>, trace_args = (tensor([[-0.5805, -0.6076, -1.9904]]),), trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[ 0.0624,  1.1245, -0.4072],
        [-1.1118, -0.5000, -1.7205],
        [ 0.3696,  1.2798, -1.7118],
        [ 0.2276,  1.8630,  0.5187],
        [-0.4080, -1.4934, -1.0799]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function quaternion_log_to_exp at 0x7fd5cd0ad090>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.quaternion_log_to_exp
___________________________________________________________________________ test_quaternion_exp_to_log[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_quaternion_exp_to_log(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn(1, 4),
        )
        trace_kwargs = {'eps': 1.0e-12}
        test_args = (
            torch.randn(5, 4),
        )
        test_kwargs = {'eps': 1.0e-12}
>       _test_function(
            kornia.geometry.conversions.quaternion_exp_to_log,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:474: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function quaternion_exp_to_log at 0x7fd5cd0ad240>, trace_args = (tensor([[ 0.1183, -2.2142, -1.4505,  0.7751]]),), trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[ 0.6292, -1.0217,  2.9656,  1.5192],
        [ 0.2306, -1.7487, -0.7392,  0.8345],
        [ 0.1668, -0.3321,  0.0485, -0.5260],
        [ 1.6382, -0.0046, -1.2488, -0.3404],
        [-0.7406, -1.5782,  2.1722,  0.0728]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function quaternion_exp_to_log at 0x7fd5cd0ad240>, trace_args = (tensor([[ 0.1183, -2.2142, -1.4505,  0.7751]]),), trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[ 0.6292, -1.0217,  2.9656,  1.5192],
        [ 0.2306, -1.7487, -0.7392,  0.8345],
        [ 0.1668, -0.3321,  0.0485, -0.5260],
        [ 1.6382, -0.0046, -1.2488, -0.3404],
        [-0.7406, -1.5782,  2.1722,  0.0728]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function quaternion_exp_to_log at 0x7fd5cd0ad240>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.quaternion_exp_to_log
___________________________________________________________________________ test_normalize_quaternion[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_normalize_quaternion(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn(1, 4),
        )
        trace_kwargs = {'eps': 1.0e-12}
        test_args = (
            torch.randn(5, 4),
        )
        test_kwargs = {'eps': 1.0e-12}
>       _test_function(
            kornia.geometry.conversions.normalize_quaternion,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:496: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function normalize_quaternion at 0x7fd5cd0acee0>, trace_args = (tensor([[2.1734, 0.2213, 0.5616, 1.3862]]),), trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[-0.9798, -0.0967,  1.1075,  1.5835],
        [-0.5697, -0.0569,  0.9923, -2.3769],
        [ 1.3491, -0.6357,  0.4919,  1.6013],
        [-1.0465, -1.3415,  0.1027,  0.1801],
        [ 0.0874, -0.2901,  0.3369, -0.1358]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function normalize_quaternion at 0x7fd5cd0acee0>, trace_args = (tensor([[2.1734, 0.2213, 0.5616, 1.3862]]),), trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[-0.9798, -0.0967,  1.1075,  1.5835],
        [-0.5697, -0.0569,  0.9923, -2.3769],
        [ 1.3491, -0.6357,  0.4919,  1.6013],
        [-1.0465, -1.3415,  0.1027,  0.1801],
        [ 0.0874, -0.2901,  0.3369, -0.1358]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function normalize_quaternion at 0x7fd5cd0acee0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.normalize_quaternion
______________________________________________________________________ test_vector_to_skew_symmetric_matrix[tensorflow-s2s-False] ______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_vector_to_skew_symmetric_matrix(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([1.0, 2.0, 3.0]),
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.vector_to_skew_symmetric_matrix,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function vector_to_skew_symmetric_matrix at 0x7fd5cd0ae170>, trace_args = (tensor([1., 2., 3.]),), trace_kwargs = {}
test_args = (tensor([[1., 2., 3.],
        [4., 5., 6.],
        [7., 8., 9.]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function vector_to_skew_symmetric_matrix at 0x7fd5cd0ae170>, trace_args = (tensor([1., 2., 3.]),), trace_kwargs = {}
test_args = (tensor([[1., 2., 3.],
        [4., 5., 6.],
        [7., 8., 9.]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function vector_to_skew_symmetric_matrix at 0x7fd5cd0ae170>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.vector_to_skew_symmetric_matrix
_______________________________________________________________________ test_rotation_matrix_to_axis_angle[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rotation_matrix_to_axis_angle(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.rotation_matrix_to_axis_angle,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rotation_matrix_to_axis_angle at 0x7fd5cd0acb80>, trace_args = (tensor([[[0.3833, 0.6161, 0.7077],
         [0.8513, 0.2151, 0.3888],
         [0.6778, 0.8324, 0.6895]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.0075, 0.5724, 0.2217],
         [0.3295, 0.4620, 0.1604],
         [0.5002, 0.7074, 0.3410]],

        [[...0.5751]],

        [[0.4410, 0.4949, 0.9946],
         [0.4942, 0.8663, 0.4197],
         [0.3803, 0.7267, 0.4299]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rotation_matrix_to_axis_angle at 0x7fd5cd0acb80>, trace_args = (tensor([[[0.3833, 0.6161, 0.7077],
         [0.8513, 0.2151, 0.3888],
         [0.6778, 0.8324, 0.6895]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.0075, 0.5724, 0.2217],
         [0.3295, 0.4620, 0.1604],
         [0.5002, 0.7074, 0.3410]],

        [[...0.5751]],

        [[0.4410, 0.4949, 0.9946],
         [0.4942, 0.8663, 0.4197],
         [0.3803, 0.7267, 0.4299]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rotation_matrix_to_axis_angle at 0x7fd5cd0acb80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.rotation_matrix_to_axis_angle
_______________________________________________________________________ test_rotation_matrix_to_quaternion[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rotation_matrix_to_quaternion(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {'eps': 1e-8}
        test_args = (
            torch.rand(5, 3, 3),
        )
        test_kwargs = {'eps': 1e-3}
>       _test_function(
            kornia.geometry.conversions.rotation_matrix_to_quaternion,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:562: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rotation_matrix_to_quaternion at 0x7fd5cd0acd30>, trace_args = (tensor([[[0.8662, 0.4958, 0.1365],
         [0.5843, 0.1747, 0.3902],
         [0.0655, 0.0268, 0.0731]]]),)
trace_kwargs = {'eps': 1e-08}
test_args = (tensor([[[0.9724, 0.7563, 0.2240],
         [0.2659, 0.8919, 0.1617],
         [0.9066, 0.1636, 0.4766]],

        [[...0.4020]],

        [[0.6134, 0.6259, 0.7978],
         [0.5629, 0.8651, 0.0558],
         [0.5687, 0.6329, 0.3214]]]),)
test_kwargs = {'eps': 0.001}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rotation_matrix_to_quaternion at 0x7fd5cd0acd30>, trace_args = (tensor([[[0.8662, 0.4958, 0.1365],
         [0.5843, 0.1747, 0.3902],
         [0.0655, 0.0268, 0.0731]]]),)
trace_kwargs = {'eps': 1e-08}
test_args = (tensor([[[0.9724, 0.7563, 0.2240],
         [0.2659, 0.8919, 0.1617],
         [0.9066, 0.1636, 0.4766]],

        [[...0.4020]],

        [[0.6134, 0.6259, 0.7978],
         [0.5629, 0.8651, 0.0558],
         [0.5687, 0.6329, 0.3214]]]),)
test_kwargs = {'eps': 0.001}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rotation_matrix_to_quaternion at 0x7fd5cd0acd30>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.rotation_matrix_to_quaternion
_________________________________________________________________________ test_axis_angle_to_quaternion[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_axis_angle_to_quaternion(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand((1, 3)),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand((2, 3)),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.axis_angle_to_quaternion,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function axis_angle_to_quaternion at 0x7fd5cd0ad2d0>, trace_args = (tensor([[0.7432, 0.5378, 0.6363]]),), trace_kwargs = {}
test_args = (tensor([[0.7055, 0.8162, 0.9734],
        [0.6107, 0.2430, 0.4080]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function axis_angle_to_quaternion at 0x7fd5cd0ad2d0>, trace_args = (tensor([[0.7432, 0.5378, 0.6363]]),), trace_kwargs = {}
test_args = (tensor([[0.7055, 0.8162, 0.9734],
        [0.6107, 0.2430, 0.4080]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function axis_angle_to_quaternion at 0x7fd5cd0ad2d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.axis_angle_to_quaternion
_______________________________________________________________________ test_axis_angle_to_rotation_matrix[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_axis_angle_to_rotation_matrix(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[0., 0., 0.], [1.5708, 0., 0.]]),
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[0., 0., 0.], [1.5708, 0., 0.]]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.axis_angle_to_rotation_matrix,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:606: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function axis_angle_to_rotation_matrix at 0x7fd5cd0acaf0>, trace_args = (tensor([[0.0000, 0.0000, 0.0000],
        [1.5708, 0.0000, 0.0000]]),), trace_kwargs = {}
test_args = (tensor([[0.0000, 0.0000, 0.0000],
        [1.5708, 0.0000, 0.0000]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function axis_angle_to_rotation_matrix at 0x7fd5cd0acaf0>, trace_args = (tensor([[0.0000, 0.0000, 0.0000],
        [1.5708, 0.0000, 0.0000]]),), trace_kwargs = {}
test_args = (tensor([[0.0000, 0.0000, 0.0000],
        [1.5708, 0.0000, 0.0000]]),), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function axis_angle_to_rotation_matrix at 0x7fd5cd0acaf0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.axis_angle_to_rotation_matrix
___________________________________________________________________________ test_quaternion_from_euler[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_quaternion_from_euler(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor(0.),
            torch.tensor(0.),
            torch.tensor(0.),
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([0., 1., 2.]),
            torch.tensor([2., 1., 0.]),
            torch.tensor([1., 2., 0.]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.quaternion_from_euler,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:632: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function quaternion_from_euler at 0x7fd5cd0ad510>, trace_args = (tensor(0.), tensor(0.), tensor(0.)), trace_kwargs = {}
test_args = (tensor([0., 1., 2.]), tensor([2., 1., 0.]), tensor([1., 2., 0.])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function quaternion_from_euler at 0x7fd5cd0ad510>, trace_args = (tensor(0.), tensor(0.), tensor(0.)), trace_kwargs = {}
test_args = (tensor([0., 1., 2.]), tensor([2., 1., 0.]), tensor([1., 2., 0.])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function quaternion_from_euler at 0x7fd5cd0ad510>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.quaternion_from_euler
___________________________________________________________________________ test_euler_from_quaternion[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_euler_from_quaternion(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor(1.),
            torch.tensor(0.),
            torch.tensor(0.),
            torch.tensor(0.),
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor(2.),
            torch.tensor(1.),
            torch.tensor(1.),
            torch.tensor(1.),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.euler_from_quaternion,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:660: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function euler_from_quaternion at 0x7fd5cd0ad360>, trace_args = (tensor(1.), tensor(0.), tensor(0.), tensor(0.)), trace_kwargs = {}, test_args = (tensor(2.), tensor(1.), tensor(1.), tensor(1.))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function euler_from_quaternion at 0x7fd5cd0ad360>, trace_args = (tensor(1.), tensor(0.), tensor(0.), tensor(0.)), trace_kwargs = {}, test_args = (tensor(2.), tensor(1.), tensor(1.), tensor(1.))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function euler_from_quaternion at 0x7fd5cd0ad360>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.euler_from_quaternion
______________________________________________________________________________ test_Rt_to_matrix4x4[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Rt_to_matrix4x4(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn(1, 3, 3),
            torch.rand(1, 3, 1),
        )
        trace_kwargs = {}
        test_args = (
            torch.randn(5, 3, 3),
            torch.rand(5, 3, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.Rt_to_matrix4x4,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function Rt_to_matrix4x4 at 0x7fd5cd0adc60>
trace_args = (tensor([[[ 0.5828, -0.2666, -1.2085],
         [ 2.2747,  0.1111,  0.5852],
         [-1.2691, -0.4055,  0.9454]]]), tensor([[[0.5807],
         [0.0504],
         [0.5656]]]))
trace_kwargs = {}
test_args = (tensor([[[ 0.8282,  1.2886,  0.3391],
         [-0.7547,  0.2965, -1.1196],
         [-0.8786,  2.1771,  2.0772]],

 ...
        [[0.8121],
         [0.9240],
         [0.8217]],

        [[0.5552],
         [0.4294],
         [0.4075]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function Rt_to_matrix4x4 at 0x7fd5cd0adc60>
trace_args = (tensor([[[ 0.5828, -0.2666, -1.2085],
         [ 2.2747,  0.1111,  0.5852],
         [-1.2691, -0.4055,  0.9454]]]), tensor([[[0.5807],
         [0.0504],
         [0.5656]]]))
trace_kwargs = {}
test_args = (tensor([[[ 0.8282,  1.2886,  0.3391],
         [-0.7547,  0.2965, -1.1196],
         [-0.8786,  2.1771,  2.0772]],

 ...
        [[0.8121],
         [0.9240],
         [0.8217]],

        [[0.5552],
         [0.4294],
         [0.4075]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function Rt_to_matrix4x4 at 0x7fd5cd0adc60>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.Rt_to_matrix4x4
______________________________________________________________________________ test_matrix4x4_to_Rt[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_matrix4x4_to_Rt(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.matrix4x4_to_Rt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:706: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function matrix4x4_to_Rt at 0x7fd5cd0adcf0>
trace_args = (tensor([[[0.6373, 0.7952, 0.3775, 0.5201],
         [0.0533, 0.9298, 0.8691, 0.6047],
         [0.3382, 0.1460, 0.3054, 0.2046],
         [0.4115, 0.0829, 0.2289, 0.2628]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.5171, 0.5435, 0.8506, 0.9527],
         [0.6957, 0.5695, 0.2915, 0.3558],
         [0.7796, 0.3231, 0.280...912, 0.1343, 0.7728, 0.1381],
         [0.6908, 0.0280, 0.2020, 0.1237],
         [0.0226, 0.2965, 0.6737, 0.9374]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function matrix4x4_to_Rt at 0x7fd5cd0adcf0>
trace_args = (tensor([[[0.6373, 0.7952, 0.3775, 0.5201],
         [0.0533, 0.9298, 0.8691, 0.6047],
         [0.3382, 0.1460, 0.3054, 0.2046],
         [0.4115, 0.0829, 0.2289, 0.2628]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.5171, 0.5435, 0.8506, 0.9527],
         [0.6957, 0.5695, 0.2915, 0.3558],
         [0.7796, 0.3231, 0.280...912, 0.1343, 0.7728, 0.1381],
         [0.6908, 0.0280, 0.2020, 0.1237],
         [0.0226, 0.2965, 0.6737, 0.9374]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function matrix4x4_to_Rt at 0x7fd5cd0adcf0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.matrix4x4_to_Rt
________________________________________________________________________ test_worldtocam_to_camtoworld_Rt[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_worldtocam_to_camtoworld_Rt(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn(1, 3, 3),
            torch.rand(1, 3, 1),
        )
        trace_kwargs = {}
        test_args = (
            torch.randn(5, 3, 3),
            torch.rand(5, 3, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.worldtocam_to_camtoworld_Rt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function worldtocam_to_camtoworld_Rt at 0x7fd5cd0ae050>
trace_args = (tensor([[[-0.8030,  0.4540, -0.6377],
         [ 0.4670, -0.7611, -0.6067],
         [-1.1228, -0.7241, -0.2324]]]), tensor([[[0.1257],
         [0.8326],
         [0.7516]]]))
trace_kwargs = {}
test_args = (tensor([[[ 0.6102, -0.4641, -0.5162],
         [-0.4691,  1.3409,  1.6097],
         [ 0.6755, -0.0944, -0.4668]],

 ...
        [[0.4302],
         [0.1630],
         [0.4319]],

        [[0.6854],
         [0.8226],
         [0.8420]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function worldtocam_to_camtoworld_Rt at 0x7fd5cd0ae050>
trace_args = (tensor([[[-0.8030,  0.4540, -0.6377],
         [ 0.4670, -0.7611, -0.6067],
         [-1.1228, -0.7241, -0.2324]]]), tensor([[[0.1257],
         [0.8326],
         [0.7516]]]))
trace_kwargs = {}
test_args = (tensor([[[ 0.6102, -0.4641, -0.5162],
         [-0.4691,  1.3409,  1.6097],
         [ 0.6755, -0.0944, -0.4668]],

 ...
        [[0.4302],
         [0.1630],
         [0.4319]],

        [[0.6854],
         [0.8226],
         [0.8420]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function worldtocam_to_camtoworld_Rt at 0x7fd5cd0ae050>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.worldtocam_to_camtoworld_Rt
_____________________________________________________________________ test_camtoworld_graphics_to_vision_4x4[tensorflow-s2s-False] _____________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_camtoworld_graphics_to_vision_4x4(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.conversions.camtoworld_graphics_to_vision_4x4,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_conversions.py:776: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function camtoworld_graphics_to_vision_4x4 at 0x7fd5cd0add80>
trace_args = (tensor([[[0.3944, 0.8201, 0.6470, 0.8568],
         [0.6613, 0.6672, 0.1317, 0.2074],
         [0.2942, 0.7960, 0.6246, 0.5884],
         [0.4467, 0.9501, 0.8926, 0.2372]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.0825, 0.5881, 0.0217, 0.3649],
         [0.4713, 0.1589, 0.8720, 0.6383],
         [0.0676, 0.7489, 0.074...117, 0.7385, 0.8308, 0.4965],
         [0.4851, 0.6196, 0.0441, 0.2671],
         [0.3253, 0.3729, 0.4637, 0.7089]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function camtoworld_graphics_to_vision_4x4 at 0x7fd5cd0add80>
trace_args = (tensor([[[0.3944, 0.8201, 0.6470, 0.8568],
         [0.6613, 0.6672, 0.1317, 0.2074],
         [0.2942, 0.7960, 0.6246, 0.5884],
         [0.4467, 0.9501, 0.8926, 0.2372]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.0825, 0.5881, 0.0217, 0.3649],
         [0.4713, 0.1589, 0.8720, 0.6383],
         [0.0676, 0.7489, 0.074...117, 0.7385, 0.8308, 0.4965],
         [0.4851, 0.6196, 0.0441, 0.2671],
         [0.3253, 0.3729, 0.4637, 0.7089]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function camtoworld_graphics_to_vision_4x4 at 0x7fd5cd0add80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.conversions.camtoworld_graphics_to_vision_4x4
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_conversions.py::test_convert_points_from_homogeneous[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an...
FAILED kornia/geometry/test_conversions.py::test_convert_points_to_homogeneous[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an a...
FAILED kornia/geometry/test_conversions.py::test_normalize_pixel_coordinates3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a s...
FAILED kornia/geometry/test_conversions.py::test_quaternion_log_to_exp[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/geometry/test_conversions.py::test_quaternion_exp_to_log[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/geometry/test_conversions.py::test_normalize_quaternion[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, e...
FAILED kornia/geometry/test_conversions.py::test_vector_to_skew_symmetric_matrix[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an...
FAILED kornia/geometry/test_conversions.py::test_rotation_matrix_to_axis_angle[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an a...
FAILED kornia/geometry/test_conversions.py::test_rotation_matrix_to_quaternion[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an a...
FAILED kornia/geometry/test_conversions.py::test_axis_angle_to_quaternion[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ke...
FAILED kornia/geometry/test_conversions.py::test_axis_angle_to_rotation_matrix[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an a...
FAILED kornia/geometry/test_conversions.py::test_quaternion_from_euler[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/geometry/test_conversions.py::test_euler_from_quaternion[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/geometry/test_conversions.py::test_Rt_to_matrix4x4[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet...
FAILED kornia/geometry/test_conversions.py::test_matrix4x4_to_Rt[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/geometry/test_conversions.py::test_worldtocam_to_camtoworld_Rt[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api...
FAILED kornia/geometry/test_conversions.py::test_camtoworld_graphics_to_vision_4x4[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use ...
============================================================================== 17 failed, 21 passed in 210.43s (0:03:30) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 8 items

kornia/test_nerf.py FFFFFFFF                                                                                                                                                                     [100%]

=============================================================================================== FAILURES ===============================================================================================
_________________________________________________________________________________ test_NerfModel[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_NerfModel(target_framework, mode, backend_compile):
        print("kornia.nerf.nerf_model.NerfModel")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledNerfModel = ivy.transpile(nerf_model.NerfModel, source="torch", target=target_framework)

kornia/test_nerf.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.nerf.nerf_model.NerfModel'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.nerf.nerf_model.NerfModel
_____________________________________________________________________________ test_NerfModelRenderer[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_NerfModelRenderer(target_framework, mode, backend_compile):
        print("kornia.nerf.nerf_model.NerfModelRenderer")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledPinholeCamera = ivy.transpile(kornia.geometry.camera.pinhole.PinholeCamera, source="torch", target=target_framework)

kornia/test_nerf.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.camera.pinhole.PinholeCamera'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.nerf.nerf_model.NerfModelRenderer
____________________________________________________________________________________ test_MLP[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_MLP(target_framework, mode, backend_compile):
        print("kornia.nerf.nerf_model.MLP")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledMLP = ivy.transpile(nerf_model.MLP, source="torch", target=target_framework)

kornia/test_nerf.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.nerf.nerf_model.MLP'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.nerf.nerf_model.MLP
________________________________________________________________________________ test_NerfSolver[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_NerfSolver(target_framework, mode, backend_compile):
        print("kornia.nerf.nerf_solver.NerfSolver")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledPinholeCamera = ivy.transpile(kornia.geometry.camera.pinhole.PinholeCamera, source="torch", target=target_framework)
>       TranspiledNerfSolver = ivy.transpile(nerf_solver.NerfSolver, source="torch", target=target_framework)

kornia/test_nerf.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.nerf.nerf_solver.NerfSolver'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.torch_frontend_outputs.kornia.nerf.core: name 'Tensor' is not defined

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.nerf.nerf_solver.NerfSolver

Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PinholeCamera from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                        
Transpilation of PinholeCamera complete.

Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling NerfSolver from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                     
_____________________________________________________________________________ test_IrregularRenderer[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_IrregularRenderer(target_framework, mode, backend_compile):
        print("kornia.nerf.volume_renderer.IrregularRenderer")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledIrregularRenderer = ivy.transpile(volume_renderer.IrregularRenderer, source="torch", target=target_framework)

kornia/test_nerf.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.nerf.volume_renderer.IrregularRenderer'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.nerf.volume_renderer.IrregularRenderer
______________________________________________________________________________ test_RegularRenderer[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RegularRenderer(target_framework, mode, backend_compile):
        print("kornia.nerf.volume_renderer.RegularRenderer")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledRegularRenderer = ivy.transpile(volume_renderer.RegularRenderer, source="torch", target=target_framework)

kornia/test_nerf.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.nerf.volume_renderer.RegularRenderer'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.torch_frontend_outputs.kornia.nerf.core: name 'Tensor' is not defined

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.nerf.volume_renderer.RegularRenderer

Transpiling RegularRenderer from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RegularRenderer from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RegularRenderer from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RegularRenderer from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RegularRenderer from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                          
________________________________________________________________________________ test_RaySampler[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RaySampler(target_framework, mode, backend_compile):
        print("kornia.nerf.samplers.RaySampler")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledPinholeCamera = ivy.transpile(kornia.geometry.camera.pinhole.PinholeCamera, source="torch", target=target_framework)

kornia/test_nerf.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.camera.pinhole.PinholeCamera'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.nerf.samplers.RaySampler
_____________________________________________________________________________ test_RandomRaySampler[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomRaySampler(target_framework, mode, backend_compile):
        print("kornia.nerf.samplers.RandomRaySampler")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledPinholeCamera = ivy.transpile(kornia.geometry.camera.pinhole.PinholeCamera, source="torch", target=target_framework)
>       TranspiledRandomRaySampler = ivy.transpile(samplers.RandomRaySampler, source="torch", target=target_framework)

kornia/test_nerf.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.nerf.samplers.RandomRaySampler'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.nerf.samplers.RandomRaySampler
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_nerf.py::test_NerfModel[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_nerf.py::test_NerfModelRenderer[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_nerf.py::test_MLP[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY ...
FAILED kornia/test_nerf.py::test_NerfSolver[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.torch_frontend_outputs.kornia.nerf.core: name 'Tensor'...
FAILED kornia/test_nerf.py::test_IrregularRenderer[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_nerf.py::test_RegularRenderer[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.torch_frontend_outputs.kornia.nerf.core: name 'Te...
FAILED kornia/test_nerf.py::test_RaySampler[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_nerf.py::test_RandomRaySampler[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
==================================================================================== 8 failed in 147.83s (0:02:27) =====================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 6 items

kornia/augmentation/test_container.py FFFFFF                                                                                                                                                     [100%]

=============================================================================================== FAILURES ===============================================================================================
__________________________________________________________________________ test_AugmentationSequential[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_AugmentationSequential(target_framework, mode, backend_compile):
        print("kornia.augmentation.container.AugmentationSequential")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledAugmentationSequential = ivy.transpile(
            kornia.augmentation.container.AugmentationSequential,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_container.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.container.augment.AugmentationSequential'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation._2d.mix.base: cannot import name 'ivy__BasicAugmentationBase' from 'Translated_Outputs.ivy_outputs.kornia.augmentation.base' (/ivy/ivy-integration-tests/Translated_Outputs/ivy_outputs/kornia/augmentation/base.py)

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.container.AugmentationSequential

Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling AugmentationSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                                 
______________________________________________________________________ test_ManyToManyAugmentationDispather[tensorflow-s2s-False] ______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ManyToManyAugmentationDispather(target_framework, mode, backend_compile):
        print("kornia.augmentation.container.ManyToManyAugmentationDispather")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledManyToManyAugmentationDispather = ivy.transpile(
            kornia.augmentation.container.ManyToManyAugmentationDispather,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_container.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.container.dispatcher.ManyToManyAugmentationDispather'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation._2d.mix.base: cannot import name 'ivy__BasicAugmentationBase' from 'Translated_Outputs.ivy_outputs.kornia.augmentation.base' (/ivy/ivy-integration-tests/Translated_Outputs/ivy_outputs/kornia/augmentation/base.py)

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.container.ManyToManyAugmentationDispather

Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToManyAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                                          
______________________________________________________________________ test_ManyToOneAugmentationDispather[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ManyToOneAugmentationDispather(target_framework, mode, backend_compile):
        print("kornia.augmentation.container.ManyToOneAugmentationDispather")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledManyToOneAugmentationDispather = ivy.transpile(
            kornia.augmentation.container.ManyToOneAugmentationDispather,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_container.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.container.dispatcher.ManyToOneAugmentationDispather'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation._2d.mix.base: cannot import name 'ivy__BasicAugmentationBase' from 'Translated_Outputs.ivy_outputs.kornia.augmentation.base' (/ivy/ivy-integration-tests/Translated_Outputs/ivy_outputs/kornia/augmentation/base.py)

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.container.ManyToOneAugmentationDispather

Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ManyToOneAugmentationDispather from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                                         
______________________________________________________________________________ test_ImageSequential[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ImageSequential(target_framework, mode, backend_compile):
        print("kornia.augmentation.container.ImageSequential")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledImageSequential = ivy.transpile(
            kornia.augmentation.container.ImageSequential,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_container.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.container.image.ImageSequential'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation._2d.mix.base: cannot import name 'ivy__BasicAugmentationBase' from 'Translated_Outputs.ivy_outputs.kornia.augmentation.base' (/ivy/ivy-integration-tests/Translated_Outputs/ivy_outputs/kornia/augmentation/base.py)

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.container.ImageSequential

Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ImageSequential from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                          
______________________________________________________________________________ test_PatchSequential[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PatchSequential(target_framework, mode, backend_compile):
        print("kornia.augmentation.container.PatchSequential")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledPatchSequential = ivy.transpile(
            kornia.augmentation.container.PatchSequential,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_container.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.container.patch.PatchSequential'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.container.PatchSequential
______________________________________________________________________________ test_VideoSequential[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_VideoSequential(target_framework, mode, backend_compile):
        print("kornia.augmentation.container.VideoSequential")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledVideoSequential = ivy.transpile(
            kornia.augmentation.container.VideoSequential,
            source="torch",
            target=target_framework,
        )

kornia/augmentation/test_container.py:376: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation.container.video.VideoSequential'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.container.VideoSequential
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/augmentation/test_container.py::test_AugmentationSequential[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augme...
FAILED kornia/augmentation/test_container.py::test_ManyToManyAugmentationDispather[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kor...
FAILED kornia/augmentation/test_container.py::test_ManyToOneAugmentationDispather[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.korn...
FAILED kornia/augmentation/test_container.py::test_ImageSequential[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Error loading module Translated_Outputs.ivy_outputs.kornia.augmentation...
FAILED kornia/augmentation/test_container.py::test_PatchSequential[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/augmentation/test_container.py::test_VideoSequential[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
==================================================================================== 6 failed in 311.99s (0:05:11) =====================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 15 items

kornia/test_feature3.py .FFF..FFFFFFFFF                                                                                                                                                          [100%]

=============================================================================================== FAILURES ===============================================================================================
__________________________________________________________________________________ test_SOSNet[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SOSNet(target_framework, mode, backend_compile):
        print("kornia.feature.SOSNet")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSOSNet = ivy.transpile(kornia.feature.SOSNet, source="torch", target=target_framework)

kornia/test_feature3.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.sosnet.SOSNet'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.SOSNet
________________________________________________________________________________ test_BlobHessian[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_BlobHessian(target_framework, mode, backend_compile):
        print("kornia.feature.BlobHessian")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledBlobHessian = ivy.transpile(kornia.feature.BlobHessian, source="torch", target=target_framework)

kornia/test_feature3.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.responses.BlobHessian'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.BlobHessian
________________________________________________________________________________ test_CornerGFTT[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_CornerGFTT(target_framework, mode, backend_compile):
        print("kornia.feature.CornerGFTT")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledCornerGFTT = ivy.transpile(kornia.feature.CornerGFTT, source="torch", target=target_framework)

kornia/test_feature3.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.responses.CornerGFTT'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.CornerGFTT
_______________________________________________________________________________ test_BlobDoGSingle[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_BlobDoGSingle(target_framework, mode, backend_compile):
        print("kornia.feature.BlobDoGSingle")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledBlobDoGSingle = ivy.transpile(kornia.feature.BlobDoGSingle, source="torch", target=target_framework)

kornia/test_feature3.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.responses.BlobDoGSingle'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.BlobDoGSingle
__________________________________________________________________________________ test_KeyNet[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_KeyNet(target_framework, mode, backend_compile):
        print("kornia.feature.KeyNet")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledKeyNet = ivy.transpile(kornia.feature.KeyNet, source="torch", target=target_framework)

kornia/test_feature3.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.keynet.KeyNet'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.KeyNet
__________________________________________________________________________ test_MultiResolutionDetector[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_MultiResolutionDetector(target_framework, mode, backend_compile):
        print("kornia.feature.MultiResolutionDetector")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledMultiResolutionDetector = ivy.transpile(kornia.feature.MultiResolutionDetector, source="torch", target=target_framework)

kornia/test_feature3.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.scale_space_detector.MultiResolutionDetector'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.MultiResolutionDetector
____________________________________________________________________________ test_ScaleSpaceDetector[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ScaleSpaceDetector(target_framework, mode, backend_compile):
        print("kornia.feature.ScaleSpaceDetector")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledScaleSpaceDetector = ivy.transpile(kornia.feature.ScaleSpaceDetector, source="torch", target=target_framework)

kornia/test_feature3.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.scale_space_detector.ScaleSpaceDetector'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.ScaleSpaceDetector
______________________________________________________________________________ test_KeyNetDetector[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_KeyNetDetector(target_framework, mode, backend_compile):
        print("kornia.feature.KeyNetDetector")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledKeyNetDetector = ivy.transpile(kornia.feature.KeyNetDetector, source="torch", target=target_framework)

kornia/test_feature3.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.keynet.KeyNetDetector'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.KeyNetDetector
_______________________________________________________________________________ test_LAFDescriptor[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LAFDescriptor(target_framework, mode, backend_compile):
        print("kornia.feature.LAFDescriptor")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledLAFDescriptor = ivy.transpile(kornia.feature.LAFDescriptor, source="torch", target=target_framework)

kornia/test_feature3.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.integrated.LAFDescriptor'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LAFDescriptor
___________________________________________________________________________________ test_SOLD2[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SOLD2(target_framework, mode, backend_compile):
        print("kornia.feature.SOLD2")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSOLD2 = ivy.transpile(kornia.feature.SOLD2, source="torch", target=target_framework)

kornia/test_feature3.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.sold2.sold2.SOLD2'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.SOLD2
_______________________________________________________________________________ test_LocalFeature[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LocalFeature(target_framework, mode, backend_compile):
        print("kornia.feature.LocalFeature")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledKeyNetDetector = ivy.transpile(
            kornia.feature.KeyNetDetector, source="torch", target=target_framework
        )

kornia/test_feature3.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.keynet.KeyNetDetector'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LocalFeature
______________________________________________________________________________ test_SOLD2_detector[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SOLD2_detector(target_framework, mode, backend_compile):
        print("kornia.feature.SOLD2_detector")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSOLD2Detector = ivy.transpile(kornia.feature.SOLD2_detector, source="torch", target=target_framework)

kornia/test_feature3.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.sold2.sold2_detector.SOLD2_detector'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.SOLD2_detector
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_feature3.py::test_SOSNet[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_feature3.py::test_BlobHessian[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_feature3.py::test_CornerGFTT[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_feature3.py::test_BlobDoGSingle[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_feature3.py::test_KeyNet[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_feature3.py::test_MultiResolutionDetector[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/test_feature3.py::test_ScaleSpaceDetector[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do n...
FAILED kornia/test_feature3.py::test_KeyNetDetector[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
FAILED kornia/test_feature3.py::test_LAFDescriptor[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_feature3.py::test_SOLD2[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_feature3.py::test_LocalFeature[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/test_feature3.py::test_SOLD2_detector[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
=============================================================================== 12 failed, 3 passed in 236.72s (0:03:56) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 2 items

kornia/test_io.py ..                                                                                                                                                                             [100%]

--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
==================================================================================== 2 passed in 103.51s (0:01:43) =====================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 5 items

kornia/geometry/test_calibration.py ..FFF                                                                                                                                                        [100%]

=============================================================================================== FAILURES ===============================================================================================
______________________________________________________________________________ test_distort_points[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_distort_points(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 2),
            torch.eye(3)[None],
            torch.rand(1, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(1, 3, 2),
            torch.eye(3)[None],
            torch.rand(1, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.calibration.distort_points,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_calibration.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function distort_points at 0x7fd9dfd424d0>
trace_args = (tensor([[[0.1867, 0.6366]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[0.8468, 0.6002, 0.1636, 0.5373]])), trace_kwargs = {}
test_args = (tensor([[[0.8243, 0.7235],
         [0.2893, 0.8134],
         [0.6917, 0.6109]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[0.4607, 0.3364, 0.0890, 0.8881]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function distort_points at 0x7fd9dfd424d0>
trace_args = (tensor([[[0.1867, 0.6366]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[0.8468, 0.6002, 0.1636, 0.5373]])), trace_kwargs = {}
test_args = (tensor([[[0.8243, 0.7235],
         [0.2893, 0.8134],
         [0.6917, 0.6109]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[0.4607, 0.3364, 0.0890, 0.8881]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function distort_points at 0x7fd9dfd424d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.calibration.distort.distort_points
______________________________________________________________________________ test_tilt_projection[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_tilt_projection(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor(0.1),
            torch.tensor(0.2),
        )
        trace_kwargs = {'return_inverse': False}
        test_args = (
            torch.tensor(0.3),
            torch.tensor(0.4),
        )
        test_kwargs = {'return_inverse': False}
>       _test_function(
            kornia.geometry.calibration.tilt_projection,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_calibration.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function tilt_projection at 0x7fd9dfd42440>, trace_args = (tensor(0.1000), tensor(0.2000)), trace_kwargs = {'return_inverse': False}, test_args = (tensor(0.3000), tensor(0.4000))
test_kwargs = {'return_inverse': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function tilt_projection at 0x7fd9dfd42440>, trace_args = (tensor(0.1000), tensor(0.2000)), trace_kwargs = {'return_inverse': False}, test_args = (tensor(0.3000), tensor(0.4000))
test_kwargs = {'return_inverse': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function tilt_projection at 0x7fd9dfd42440>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.calibration.distort.tilt_projection
_______________________________________________________________________________ test_solve_pnp_dlt[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_solve_pnp_dlt(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[
                [5.0, -5.0, 0.0], [0.0, 0.0, 1.5],
                [2.5, 3.0, 6.0], [9.0, -2.0, 3.0],
                [-4.0, 5.0, 2.0], [-5.0, 5.0, 1.0]
            ]], dtype=torch.float64),
            torch.tensor([[
                [1409.1504, -800.936], [407.0207, -182.1229],
                [392.7021, 177.9428], [1016.838, -2.9416],
                [-63.1116, 142.9204], [-219.3874, 99.666]
            ]], dtype=torch.float64),
            torch.tensor([[
                [500.0, 0.0, 250.0],
                [0.0, 500.0, 250.0],
                [0.0, 0.0, 1.0]
            ]], dtype=torch.float64),
        )
        trace_kwargs = {'svd_eps': 1e-3}
        test_args = (
            torch.tensor([[
                [10.0, -10.0, 0.0], [0.0, 0.0, 3.0],
                [5.0, 6.0, 12.0], [18.0, -4.0, 6.0],
                [-8.0, 10.0, 4.0], [-10.0, 10.0, 2.0]
            ]], dtype=torch.float64),
            torch.tensor([[
                [2818.3008, -1601.872], [814.0414, -364.2458],
                [785.4042, 355.8856], [2033.676, -5.8832],
                [-126.2232, 285.8408], [-438.7748, 199.332]
            ]], dtype=torch.float64),
            torch.tensor([[
                [1000.0, 0.0, 500.0],
                [0.0, 1000.0, 500.0],
                [0.0, 0.0, 1.0]
            ]], dtype=torch.float64),
        )
        test_kwargs = {'svd_eps': 1e-3}
>       _test_function(
            kornia.geometry.calibration.solve_pnp_dlt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_calibration.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function solve_pnp_dlt at 0x7fd9dfd428c0>
trace_args = (tensor([[[ 5.0000, -5.0000,  0.0000],
         [ 0.0000,  0.0000,  1.5000],
         [ 2.5000,  3.0000,  6.0000],
   ...loat64), tensor([[[500.,   0., 250.],
         [  0., 500., 250.],
         [  0.,   0.,   1.]]], dtype=torch.float64))
trace_kwargs = {'svd_eps': 0.001}
test_args = (tensor([[[ 10., -10.,   0.],
         [  0.,   0.,   3.],
         [  5.,   6.,  12.],
         [ 18.,  -4.,   6.],
 ...tensor([[[1000.,    0.,  500.],
         [   0., 1000.,  500.],
         [   0.,    0.,    1.]]], dtype=torch.float64))
test_kwargs = {'svd_eps': 0.001}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function solve_pnp_dlt at 0x7fd9dfd428c0>
trace_args = (tensor([[[ 5.0000, -5.0000,  0.0000],
         [ 0.0000,  0.0000,  1.5000],
         [ 2.5000,  3.0000,  6.0000],
   ...loat64), tensor([[[500.,   0., 250.],
         [  0., 500., 250.],
         [  0.,   0.,   1.]]], dtype=torch.float64))
trace_kwargs = {'svd_eps': 0.001}
test_args = (tensor([[[ 10., -10.,   0.],
         [  0.,   0.,   3.],
         [  5.,   6.,  12.],
         [ 18.,  -4.,   6.],
 ...tensor([[[1000.,    0.,  500.],
         [   0., 1000.,  500.],
         [   0.,    0.,    1.]]], dtype=torch.float64))
test_kwargs = {'svd_eps': 0.001}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
>       graph_out = translated_fn(*graph_args, **graph_kwargs)

helpers.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

world_points = <tf.Tensor: shape=(1, 6, 3), dtype=float64, numpy=
array([[[ 5. , -5. ,  0. ],
        [ 0. ,  0. ,  1.5],
        [ 2.5,  3. ,  6. ],
        [ 9. , -2. ,  3. ],
        [-4. ,  5. ,  2. ],
        [-5. ,  5. ,  1. ]]])>
img_points = <tf.Tensor: shape=(1, 6, 2), dtype=float64, numpy=
array([[[1409.1504, -800.936 ],
        [ 407.0207, -182.1229],
   ...92.7021,  177.9428],
        [1016.838 ,   -2.9416],
        [ -63.1116,  142.9204],
        [-219.3874,   99.666 ]]])>
intrinsics = <tf.Tensor: shape=(1, 3, 3), dtype=float64, numpy=
array([[[500.,   0., 250.],
        [  0., 500., 250.],
        [  0.,   0.,   1.]]])>, weights = None, svd_eps = 0.001

    def tensorflow_solve_pnp_dlt(
        world_points, img_points, intrinsics, weights=None, svd_eps=0.0001
    ):
        from ....ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...utils.helpers import tensorflow__torch_linalg_svdvals
        from ....ivy.functional.frontends.torch.reduction_ops import tensorflow_any_frnt
        from ....ivy.functional.frontends.torch.blas_and_lapack_ops import (
            tensorflow_inverse_frnt,
        )
        from ..conversions import tensorflow_convert_points_to_homogeneous
        from ..linalg import tensorflow_transform_points
        from ....ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ....ivy.functional.frontends.torch.blas_and_lapack_ops import (
            tensorflow_svd_frnt_base_count_1_frnt,
        )
        from ....ivy.functional.frontends.torch.tensor import tensorflow_reshape_frnt_
        from ...utils.misc import tensorflow_eye_like
        from ....ivy.functional.frontends.torch.blas_and_lapack_ops import (
            tensorflow_bmm_frnt,
        )
        from ....ivy.functional.frontends.torch.blas_and_lapack_ops import (
            tensorflow_det_frnt,
        )
        from ....ivy.functional.frontends.torch.reduction_ops import tensorflow_norm_frnt
        from ....ivy.functional.frontends.torch.linalg import tensorflow_qr_frnt
        from ....ivy.functional.frontends.torch.pointwise_ops import tensorflow_sign_frnt
        from ....ivy.functional.frontends.torch.indexing_slicing_joining_mutating_ops import (
            tensorflow_cat_frnt,
        )
        from ...core._backend import zeros
        from ...core._backend import ones_like
        from ...core._backend import where
    
        if not isinstance(world_points, (tensorflow.Tensor, tensorflow.Variable)):
            raise AssertionError(
                f"world_points is not an instance of torch.Tensor. Type of world_points is {type(world_points)}"
            )
        if not isinstance(img_points, (tensorflow.Tensor, tensorflow.Variable)):
            raise AssertionError(
                f"img_points is not an instance of torch.Tensor. Type of img_points is {type(img_points)}"
            )
        if not isinstance(intrinsics, (tensorflow.Tensor, tensorflow.Variable)):
            raise AssertionError(
                f"intrinsics is not an instance of torch.Tensor. Type of intrinsics is {type(intrinsics)}"
            )
        if weights is not None and not isinstance(
            weights, (tensorflow.Tensor, tensorflow.Variable)
        ):
            raise AssertionError(
                f"If weights is not None, then weights should be an instance of torch.Tensor. Type of weights is {type(weights)}"
            )
        if not isinstance(svd_eps, (float,)):
            raise AssertionError(f"Type of svd_eps is not float. Got {type(svd_eps)}")
        accepted_dtypes = tf.float32, tf.float64
        if world_points.dtype not in accepted_dtypes:
            raise AssertionError(
                f"world_points must have one of the following dtypes {accepted_dtypes}. Currently it has {world_points.dtype}."
            )
        if img_points.dtype not in accepted_dtypes:
            raise AssertionError(
                f"img_points must have one of the following dtypes {accepted_dtypes}. Currently it has {img_points.dtype}."
            )
        if intrinsics.dtype not in accepted_dtypes:
            raise AssertionError(
                f"intrinsics must have one of the following dtypes {accepted_dtypes}. Currently it has {intrinsics.dtype}."
            )
        if (
            len(tensorflow_shape_frnt_(world_points)) != 3
            or tensorflow_shape_frnt_(world_points)[2] != 3
        ):
            raise AssertionError(
                f"world_points must be of shape (B, N, 3). Got shape {tensorflow_shape_frnt_(world_points)}."
            )
        if (
            len(tensorflow_shape_frnt_(img_points)) != 3
            or tensorflow_shape_frnt_(img_points)[2] != 2
        ):
            raise AssertionError(
                f"img_points must be of shape (B, N, 2). Got shape {tensorflow_shape_frnt_(img_points)}."
            )
        if len(tensorflow_shape_frnt_(intrinsics)) != 3 or tensorflow_shape_frnt_(
            intrinsics
        )[1:] != (3, 3):
            raise AssertionError(
                f"intrinsics must be of shape (B, 3, 3). Got shape {tensorflow_shape_frnt_(intrinsics)}."
            )
        if tensorflow_shape_frnt_(world_points)[1] != tensorflow_shape_frnt_(img_points)[1]:
            raise AssertionError(
                "world_points and img_points must have equal number of points."
            )
        if (
            tensorflow_shape_frnt_(world_points)[0] != tensorflow_shape_frnt_(img_points)[0]
            or tensorflow_shape_frnt_(world_points)[0]
            != tensorflow_shape_frnt_(intrinsics)[0]
        ):
            raise AssertionError(
                "world_points, img_points and intrinsics must have the same batch size."
            )
        if tensorflow_shape_frnt_(world_points)[1] < 6:
            raise AssertionError(
                f"At least 6 points are required to use this function. Got {tensorflow_shape_frnt_(world_points)[1]} points."
            )
        B, N = (
            tensorflow_shape_frnt_(world_points)[:2][0],
            tensorflow_shape_frnt_(world_points)[:2][1],
        )
        world_points_norm, world_transform_norm = (
            tensorflow__mean_isotropic_scale_normalize(world_points)
        )
        s = tensorflow__torch_linalg_svdvals(world_points_norm)
        if tensorflow_any_frnt(s[:, -1] < svd_eps):
            raise AssertionError(
                f"The last singular value of one/more of the elements of the batch is smaller than {svd_eps}. This function cannot be used if all world_points (of any element of the batch) lie on a line or if all world_points (of any element of the batch) lie on a plane."
            )
        intrinsics_inv = tensorflow_inverse_frnt(intrinsics)
        world_points_norm_h = tensorflow_convert_points_to_homogeneous(world_points_norm)
        img_points_inv = tensorflow_transform_points(intrinsics_inv, img_points)
        img_points_norm, img_transform_norm = tensorflow__mean_isotropic_scale_normalize(
            img_points_inv
        )
        inv_img_transform_norm = tensorflow_inverse_frnt(img_transform_norm)
        system = zeros((B, 2 * N, 12), dtype=world_points.dtype, device=world_points.device)
        system = tensorflow_set_item_bknd(
            system,
            (slice(None, None, None), slice(0, None, 2), slice(0, 4, None)),
            world_points_norm_h,
        )
        system = tensorflow_set_item_bknd(
            system,
            (slice(None, None, None), slice(1, None, 2), slice(4, 8, None)),
            world_points_norm_h,
        )
        system = tensorflow_set_item_bknd(
            system,
            (slice(None, None, None), slice(0, None, 2), slice(8, 12, None)),
            world_points_norm_h * -1 * img_points_norm[..., 0:1],
        )
        system = tensorflow_set_item_bknd(
            system,
            (slice(None, None, None), slice(1, None, 2), slice(8, 12, None)),
            world_points_norm_h * -1 * img_points_norm[..., 1:2],
        )
        _, _, v = tensorflow_svd_frnt_base_count_1_frnt(system)
        solution = v[..., -1]
        solution = tensorflow_reshape_frnt_(solution, B, 3, 4)
        solution_4x4 = tensorflow_eye_like(4, solution)
        solution_4x4 = tensorflow_set_item_bknd(
            solution_4x4,
            (slice(None, None, None), slice(None, 3, None), slice(None, None, None)),
            solution,
        )
        intermediate = tensorflow_bmm_frnt(solution_4x4, world_transform_norm)
        solution = tensorflow_bmm_frnt(inv_img_transform_norm, intermediate[:, :3, :])
        det = tensorflow_det_frnt(solution[:, :3, :3])
        ones = ones_like(det)
        sign_fix = where(det < 0, ones * -1, ones)
        solution = solution * sign_fix[:, None, None]
>       norm_col = tensorflow_norm_frnt(input=solution[:, :3, 0], p=2, dim=1)

Translated_Outputs/tensorflow_outputs/kornia/geometry/calibration/pnp.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (), kwargs = {'dim': 1, 'input': <tf.Tensor: shape=(1, 3), dtype=float64, numpy=array([[-0.02017233,  0.02388227,  0.05749283]])>, 'p': 2}
tensorflow_is_array_bknd = <function tensorflow_is_array_bknd at 0x7fd9d88e8550>

    @functools.wraps(fn)
    def wrapper(*args, **kwargs):
        from ..functional.ivy.general import tensorflow_is_array_bknd
    
>       array_like = args[0]
E       IndexError: tuple index out of range

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:181: IndexError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.calibration.pnp.solve_pnp_dlt

Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling solve_pnp_dlt from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
                                                                                                                                           
Transpilation of solve_pnp_dlt complete.
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_calibration.py::test_distort_points[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/geometry/test_calibration.py::test_tilt_projection[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/geometry/test_calibration.py::test_solve_pnp_dlt[tensorflow-s2s-False] - IndexError: tuple index out of range
=============================================================================== 3 failed, 2 passed in 180.39s (0:03:00) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 15 items

kornia/geometry/test_subpix.py ..FF.F....FFFFF                                                                                                                                                   [100%]

=============================================================================================== FAILURES ===============================================================================================
____________________________________________________________________________ test_conv_quad_interp3d[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_conv_quad_interp3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(20, 16, 3, 50, 32),
        )
        trace_kwargs = {
            'strict_maxima_bonus': 10.0,
            'eps': 1e-7,
        }
        test_args = (
            torch.rand(10, 16, 5, 50, 32),
        )
        test_kwargs = {
            'strict_maxima_bonus': 5.0,
            'eps': 1e-7,
        }
>       _test_function(
            kornia.geometry.subpix.conv_quad_interp3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_subpix.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function conv_quad_interp3d at 0x7f735f6b8b80>
trace_args = (tensor([[[[[6.7718e-01, 7.3256e-01, 9.8066e-01,  ..., 6.0622e-01,
            4.2173e-01, 1.7638e-01],
           [1....4523e-01],
           [5.3679e-01, 3.7480e-01, 4.6003e-01,  ..., 6.1153e-01,
            4.1856e-01, 4.6547e-02]]]]]),)
trace_kwargs = {'eps': 1e-07, 'strict_maxima_bonus': 10.0}
test_args = (tensor([[[[[9.6565e-01, 1.5198e-01, 6.3814e-01,  ..., 1.3218e-02,
            4.3217e-02, 1.3465e-01],
           [8....0810e-02],
           [1.6782e-01, 3.1504e-01, 8.9637e-01,  ..., 5.3766e-01,
            1.1372e-01, 5.2630e-01]]]]]),)
test_kwargs = {'eps': 1e-07, 'strict_maxima_bonus': 5.0}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function conv_quad_interp3d at 0x7f735f6b8b80>
trace_args = (tensor([[[[[6.7718e-01, 7.3256e-01, 9.8066e-01,  ..., 6.0622e-01,
            4.2173e-01, 1.7638e-01],
           [1....4523e-01],
           [5.3679e-01, 3.7480e-01, 4.6003e-01,  ..., 6.1153e-01,
            4.1856e-01, 4.6547e-02]]]]]),)
trace_kwargs = {'eps': 1e-07, 'strict_maxima_bonus': 10.0}
test_args = (tensor([[[[[9.6565e-01, 1.5198e-01, 6.3814e-01,  ..., 1.3218e-02,
            4.3217e-02, 1.3465e-01],
           [8....0810e-02],
           [1.6782e-01, 3.1504e-01, 8.9637e-01,  ..., 5.3766e-01,
            1.1372e-01, 5.2630e-01]]]]]),)
test_kwargs = {'eps': 1e-07, 'strict_maxima_bonus': 5.0}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function conv_quad_interp3d at 0x7f735f6b8b80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.subpix.spatial_soft_argmax.conv_quad_interp3d
_____________________________________________________________________________ test_spatial_softmax2d[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_spatial_softmax2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 5, 5),
        )
        trace_kwargs = {
            'temperature': torch.tensor(1.0),
        }
        test_args = (
            torch.rand(10, 1, 5, 5),
        )
        test_kwargs = {
            'temperature': torch.tensor(0.5),
        }
>       _test_function(
            kornia.geometry.subpix.spatial_softmax2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_subpix.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function spatial_softmax2d at 0x7f735f8a3760>
trace_args = (tensor([[[[0.9854, 0.3591, 0.9056, 0.8760, 0.4896],
          [0.0878, 0.9293, 0.7438, 0.3025, 0.3479],
          [0...., 0.2649],
          [0.8120, 0.6941, 0.6403, 0.5167, 0.7922],
          [0.1156, 0.9181, 0.3175, 0.7716, 0.5007]]]]),)
trace_kwargs = {'temperature': tensor(1.)}
test_args = (tensor([[[[0.6921, 0.1128, 0.1052, 0.5270, 0.0878],
          [0.9097, 0.4842, 0.5236, 0.3969, 0.7154],
          [0...., 0.2255],
          [0.3256, 0.8460, 0.3339, 0.6481, 0.2797],
          [0.8517, 0.1554, 0.7782, 0.1681, 0.5781]]]]),)
test_kwargs = {'temperature': tensor(0.5000)}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function spatial_softmax2d at 0x7f735f8a3760>
trace_args = (tensor([[[[0.9854, 0.3591, 0.9056, 0.8760, 0.4896],
          [0.0878, 0.9293, 0.7438, 0.3025, 0.3479],
          [0...., 0.2649],
          [0.8120, 0.6941, 0.6403, 0.5167, 0.7922],
          [0.1156, 0.9181, 0.3175, 0.7716, 0.5007]]]]),)
trace_kwargs = {'temperature': tensor(1.)}
test_args = (tensor([[[[0.6921, 0.1128, 0.1052, 0.5270, 0.0878],
          [0.9097, 0.4842, 0.5236, 0.3969, 0.7154],
          [0...., 0.2255],
          [0.3256, 0.8460, 0.3339, 0.6481, 0.2797],
          [0.8517, 0.1554, 0.7782, 0.1681, 0.5781]]]]),)
test_kwargs = {'temperature': tensor(0.5000)}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function spatial_softmax2d at 0x7f735f8a3760>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.subpix.dsnt.spatial_softmax2d
___________________________________________________________________________ test_spatial_soft_argmax2d[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_spatial_soft_argmax2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 5, 5),
        )
        trace_kwargs = {
            'temperature': torch.tensor(1.0),
            'normalized_coordinates': True,
        }
        test_args = (
            torch.rand(10, 1, 5, 5),
        )
        test_kwargs = {
            'temperature': torch.tensor(0.5),
            'normalized_coordinates': True,
        }
>       _test_function(
            kornia.geometry.subpix.spatial_soft_argmax2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_subpix.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function spatial_soft_argmax2d at 0x7f735f6b8af0>
trace_args = (tensor([[[[0.1188, 0.6250, 0.4447, 0.6671, 0.1840],
          [0.6710, 0.5054, 0.6255, 0.8619, 0.5368],
          [0...., 0.0220],
          [0.8896, 0.1017, 0.9099, 0.3255, 0.3188],
          [0.1032, 0.9632, 0.9459, 0.5333, 0.6605]]]]),)
trace_kwargs = {'normalized_coordinates': True, 'temperature': tensor(1.)}
test_args = (tensor([[[[0.7992, 0.4804, 0.5831, 0.0491, 0.0717],
          [0.7146, 0.8702, 0.3192, 0.6792, 0.0990],
          [0...., 0.6128],
          [0.0529, 0.0696, 0.8270, 0.0761, 0.0742],
          [0.9159, 0.3410, 0.3253, 0.6744, 0.4470]]]]),)
test_kwargs = {'normalized_coordinates': True, 'temperature': tensor(0.5000)}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function spatial_soft_argmax2d at 0x7f735f6b8af0>
trace_args = (tensor([[[[0.1188, 0.6250, 0.4447, 0.6671, 0.1840],
          [0.6710, 0.5054, 0.6255, 0.8619, 0.5368],
          [0...., 0.0220],
          [0.8896, 0.1017, 0.9099, 0.3255, 0.3188],
          [0.1032, 0.9632, 0.9459, 0.5333, 0.6605]]]]),)
trace_kwargs = {'normalized_coordinates': True, 'temperature': tensor(1.)}
test_args = (tensor([[[[0.7992, 0.4804, 0.5831, 0.0491, 0.0717],
          [0.7146, 0.8702, 0.3192, 0.6792, 0.0990],
          [0...., 0.6128],
          [0.0529, 0.0696, 0.8270, 0.0761, 0.0742],
          [0.9159, 0.3410, 0.3253, 0.6744, 0.4470]]]]),)
test_kwargs = {'normalized_coordinates': True, 'temperature': tensor(0.5000)}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function spatial_soft_argmax2d at 0x7f735f6b8af0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.subpix.spatial_soft_argmax.spatial_soft_argmax2d
_____________________________________________________________________________ test_ConvSoftArgmax2d[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ConvSoftArgmax2d(target_framework, mode, backend_compile):
        print("kornia.geometry.subpix.ConvSoftArgmax2d")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledConvSoftArgmax2d = ivy.transpile(
            kornia.geometry.subpix.ConvSoftArgmax2d, source="torch", target=target_framework
        )

kornia/geometry/test_subpix.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.subpix.spatial_soft_argmax.ConvSoftArgmax2d'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.subpix.ConvSoftArgmax2d
_____________________________________________________________________________ test_ConvSoftArgmax3d[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ConvSoftArgmax3d(target_framework, mode, backend_compile):
        print("kornia.geometry.subpix.ConvSoftArgmax3d")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledConvSoftArgmax3d = ivy.transpile(
            kornia.geometry.subpix.ConvSoftArgmax3d, source="torch", target=target_framework
        )

kornia/geometry/test_subpix.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.subpix.spatial_soft_argmax.ConvSoftArgmax3d'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.subpix.ConvSoftArgmax3d
_____________________________________________________________________________ test_ConvQuadInterp3d[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ConvQuadInterp3d(target_framework, mode, backend_compile):
        print("kornia.geometry.subpix.ConvQuadInterp3d")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledConvQuadInterp3d = ivy.transpile(
            kornia.geometry.subpix.ConvQuadInterp3d, source="torch", target=target_framework
        )

kornia/geometry/test_subpix.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.subpix.spatial_soft_argmax.ConvQuadInterp3d'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.subpix.ConvQuadInterp3d
__________________________________________________________________________ test_NonMaximaSuppression2d[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_NonMaximaSuppression2d(target_framework, mode, backend_compile):
        print("kornia.geometry.subpix.NonMaximaSuppression2d")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledNonMaximaSuppression2d = ivy.transpile(
            kornia.geometry.subpix.NonMaximaSuppression2d, source="torch", target=target_framework
        )

kornia/geometry/test_subpix.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.subpix.nms.NonMaximaSuppression2d'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.subpix.NonMaximaSuppression2d
__________________________________________________________________________ test_NonMaximaSuppression3d[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_NonMaximaSuppression3d(target_framework, mode, backend_compile):
        print("kornia.geometry.subpix.NonMaximaSuppression3d")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledNonMaximaSuppression3d = ivy.transpile(
            kornia.geometry.subpix.NonMaximaSuppression3d, source="torch", target=target_framework
        )

kornia/geometry/test_subpix.py:404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.subpix.nms.NonMaximaSuppression3d'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.subpix.NonMaximaSuppression3d
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_subpix.py::test_conv_quad_interp3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure y...
FAILED kornia/geometry/test_subpix.py::test_spatial_softmax2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/geometry/test_subpix.py::test_spatial_soft_argmax2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensur...
FAILED kornia/geometry/test_subpix.py::test_ConvSoftArgmax2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/geometry/test_subpix.py::test_ConvSoftArgmax3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/geometry/test_subpix.py::test_ConvQuadInterp3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/geometry/test_subpix.py::test_NonMaximaSuppression2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/geometry/test_subpix.py::test_NonMaximaSuppression3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
=============================================================================== 8 failed, 7 passed in 211.11s (0:03:31) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 8 items

kornia/geometry/test_homography.py FFF..F.F                                                                                                                                                      [100%]

=============================================================================================== FAILURES ===============================================================================================
____________________________________________________________________________ test_find_homography_dlt[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_find_homography_dlt(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2),
            torch.rand(1, 4, 2),
        )
        trace_kwargs = {'weights': torch.rand(1, 4), 'solver': 'svd'}
        test_args = (
            torch.rand(5, 4, 2),
            torch.rand(5, 4, 2),
        )
        test_kwargs = {'weights': torch.rand(5, 4), 'solver': 'svd'}
>       _test_function(
            kornia.geometry.homography.find_homography_dlt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=5e-2,
            mode=mode,
            # NOTE: numerical instability in svd()/lu() leads to logits not being allclose
            deterministic=False,
        )

kornia/geometry/test_homography.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_homography_dlt at 0x7f0c72ef0f70>
trace_args = (tensor([[[0.9704, 0.6572],
         [0.1971, 0.1160],
         [0.5832, 0.0699],
         [0.8013, 0.8142]]]), tensor([[[0.1038, 0.3022],
         [0.2423, 0.1396],
         [0.5951, 0.9142],
         [0.6510, 0.4479]]]))
trace_kwargs = {'solver': 'svd', 'weights': tensor([[0.7357, 0.6662, 0.4740, 0.3872]])}
test_args = (tensor([[[0.7083, 0.8286],
         [0.1474, 0.8030],
         [0.4656, 0.3390],
         [0.7483, 0.5451]],

       ...9870]],

        [[0.3189, 0.3974],
         [0.8994, 0.6523],
         [0.1787, 0.6768],
         [0.2664, 0.5204]]]))
test_kwargs = {'solver': 'svd', 'weights': tensor([[0.3515, 0.6720, 0.0107, 0.9956],
        [0.1676, 0.6520, 0.9617, 0.3665],
        [0.0671, 0.7908, 0.3479, 0.2075],
        [0.3979, 0.8944, 0.3705, 0.6637],
        [0.1378, 0.1481, 0.2403, 0.3677]])}
target = 'tensorflow', backend_compile = False, tolerance = 0.05, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_homography_dlt at 0x7f0c72ef0f70>
trace_args = (tensor([[[0.9704, 0.6572],
         [0.1971, 0.1160],
         [0.5832, 0.0699],
         [0.8013, 0.8142]]]), tensor([[[0.1038, 0.3022],
         [0.2423, 0.1396],
         [0.5951, 0.9142],
         [0.6510, 0.4479]]]))
trace_kwargs = {'solver': 'svd', 'weights': tensor([[0.7357, 0.6662, 0.4740, 0.3872]])}
test_args = (tensor([[[0.7083, 0.8286],
         [0.1474, 0.8030],
         [0.4656, 0.3390],
         [0.7483, 0.5451]],

       ...9870]],

        [[0.3189, 0.3974],
         [0.8994, 0.6523],
         [0.1787, 0.6768],
         [0.2664, 0.5204]]]))
test_kwargs = {'solver': 'svd', 'weights': tensor([[0.3515, 0.6720, 0.0107, 0.9956],
        [0.1676, 0.6520, 0.9617, 0.3665],
        [0.0671, 0.7908, 0.3479, 0.2075],
        [0.3979, 0.8944, 0.3705, 0.6637],
        [0.1378, 0.1481, 0.2403, 0.3677]])}
target = 'tensorflow', backend_compile = False, tolerance = 0.05, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function find_homography_dlt at 0x7f0c72ef0f70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.homography.find_homography_dlt
_______________________________________________________________________ test_find_homography_dlt_iterated[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_find_homography_dlt_iterated(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2),
            torch.rand(1, 4, 2),
            torch.rand(1, 4),
        )
        trace_kwargs = {'soft_inl_th': 3.0, 'n_iter': 5}
        test_args = (
            torch.rand(5, 4, 2),
            torch.rand(5, 4, 2),
            torch.rand(5, 4),
        )
        test_kwargs = {'soft_inl_th': 4.0, 'n_iter': 5}
>       _test_function(
            kornia.geometry.homography.find_homography_dlt_iterated,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=5e-2,
            mode=mode,
            # NOTE: numerical instability in svd()/lu() leads to logits not being allclose
            deterministic=False,
        )

kornia/geometry/test_homography.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_homography_dlt_iterated at 0x7f0c72ef1090>
trace_args = (tensor([[[0.4999, 0.4934],
         [0.5891, 0.2659],
         [0.3801, 0.0838],
         [0.6860, 0.7510]]]), tensor... [0.6640, 0.1225],
         [0.7050, 0.3783],
         [0.0343, 0.9810]]]), tensor([[0.9665, 0.7452, 0.9003, 0.6510]]))
trace_kwargs = {'n_iter': 5, 'soft_inl_th': 3.0}
test_args = (tensor([[[0.3935, 0.6599],
         [0.3868, 0.0334],
         [0.4178, 0.0625],
         [0.0372, 0.7100]],

       ...[0.6453, 0.9931, 0.2728, 0.7530],
        [0.1267, 0.7474, 0.0913, 0.6775],
        [0.8470, 0.3755, 0.0038, 0.3454]]))
test_kwargs = {'n_iter': 5, 'soft_inl_th': 4.0}, target = 'tensorflow', backend_compile = False, tolerance = 0.05, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_homography_dlt_iterated at 0x7f0c72ef1090>
trace_args = (tensor([[[0.4999, 0.4934],
         [0.5891, 0.2659],
         [0.3801, 0.0838],
         [0.6860, 0.7510]]]), tensor... [0.6640, 0.1225],
         [0.7050, 0.3783],
         [0.0343, 0.9810]]]), tensor([[0.9665, 0.7452, 0.9003, 0.6510]]))
trace_kwargs = {'n_iter': 5, 'soft_inl_th': 3.0}
test_args = (tensor([[[0.3935, 0.6599],
         [0.3868, 0.0334],
         [0.4178, 0.0625],
         [0.0372, 0.7100]],

       ...[0.6453, 0.9931, 0.2728, 0.7530],
        [0.1267, 0.7474, 0.0913, 0.6775],
        [0.8470, 0.3755, 0.0038, 0.3454]]))
test_kwargs = {'n_iter': 5, 'soft_inl_th': 4.0}, target = 'tensorflow', backend_compile = False, tolerance = 0.05, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function find_homography_dlt_iterated at 0x7f0c72ef1090>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.homography.find_homography_dlt_iterated
_________________________________________________________________________ test_find_homography_lines_dlt[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_find_homography_lines_dlt(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2, 2),
            torch.rand(1, 4, 2, 2),
        )
        trace_kwargs = {'weights': torch.rand(1, 4)}
        test_args = (
            torch.rand(5, 4, 2, 2),
            torch.rand(5, 4, 2, 2),
        )
        test_kwargs = {'weights': torch.rand(5, 4)}
>       _test_function(
            kornia.geometry.homography.find_homography_lines_dlt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=5e-2,
            mode=mode,
            # NOTE: numerical instability in svd()/lu() leads to logits not being allclose
            deterministic=False,
        )

kornia/geometry/test_homography.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_homography_lines_dlt at 0x7f0c72ef11b0>
trace_args = (tensor([[[[0.2133, 0.8477],
          [0.8337, 0.8456]],

         [[0.8847, 0.3383],
          [0.7140, 0.9074]],

 ...-02],
          [8.6032e-01, 4.8483e-01]],

         [[8.0480e-01, 6.4684e-01],
          [8.4757e-01, 2.6715e-04]]]]))
trace_kwargs = {'weights': tensor([[0.4144, 0.4423, 0.3462, 0.5799]])}
test_args = (tensor([[[[0.7577, 0.7291],
          [0.8440, 0.9831]],

         [[0.2888, 0.0837],
          [0.9967, 0.5708]],

 ...-01],
          [2.5554e-01, 9.5630e-01]],

         [[2.6112e-01, 9.3211e-02],
          [5.9004e-01, 5.1883e-01]]]]))
test_kwargs = {'weights': tensor([[0.0683, 0.9934, 0.6105, 0.5901],
        [0.6409, 0.4875, 0.9638, 0.3883],
        [0.9182, 0.5334, 0.5565, 0.8860],
        [0.5501, 0.2918, 0.7588, 0.3382],
        [0.5603, 0.3821, 0.9008, 0.0414]])}
target = 'tensorflow', backend_compile = False, tolerance = 0.05, mode = 's2s', skip = False, deterministic = False

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function find_homography_lines_dlt at 0x7f0c72ef11b0>
trace_args = (tensor([[[[0.2133, 0.8477],
          [0.8337, 0.8456]],

         [[0.8847, 0.3383],
          [0.7140, 0.9074]],

 ...-02],
          [8.6032e-01, 4.8483e-01]],

         [[8.0480e-01, 6.4684e-01],
          [8.4757e-01, 2.6715e-04]]]]))
trace_kwargs = {'weights': tensor([[0.4144, 0.4423, 0.3462, 0.5799]])}
test_args = (tensor([[[[0.7577, 0.7291],
          [0.8440, 0.9831]],

         [[0.2888, 0.0837],
          [0.9967, 0.5708]],

 ...-01],
          [2.5554e-01, 9.5630e-01]],

         [[2.6112e-01, 9.3211e-02],
          [5.9004e-01, 5.1883e-01]]]]))
test_kwargs = {'weights': tensor([[0.0683, 0.9934, 0.6105, 0.5901],
        [0.6409, 0.4875, 0.9638, 0.3883],
        [0.9182, 0.5334, 0.5565, 0.8860],
        [0.5501, 0.2918, 0.7588, 0.3382],
        [0.5603, 0.3821, 0.9008, 0.0414]])}
target = 'tensorflow', backend_compile = False, tolerance = 0.05, deterministic = False

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function find_homography_lines_dlt at 0x7f0c72ef11b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.homography.find_homography_lines_dlt
___________________________________________________________________________ test_oneway_transfer_error[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_oneway_transfer_error(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2),
            torch.rand(1, 4, 2),
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {'squared': False, 'eps': 1e-8}
        test_args = (
            torch.rand(5, 4, 2),
            torch.rand(5, 4, 2),
            torch.rand(5, 3, 3),
        )
        test_kwargs = {'squared': False, 'eps': 1e-7}
>       _test_function(
            kornia.geometry.homography.oneway_transfer_error,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_homography.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function oneway_transfer_error at 0x7f0c72ef0d30>
trace_args = (tensor([[[0.6384, 0.7698],
         [0.8517, 0.9686],
         [0.9629, 0.1631],
         [0.0196, 0.4470]]]), tensor...0.9358]]]), tensor([[[0.7693, 0.4002, 0.2509],
         [0.5066, 0.8068, 0.4181],
         [0.4296, 0.9808, 0.2567]]]))
trace_kwargs = {'eps': 1e-08, 'squared': False}
test_args = (tensor([[[0.7576, 0.5631],
         [0.4228, 0.8668],
         [0.2824, 0.6397],
         [0.0222, 0.2533]],

       ... 0.6432]],

        [[0.1731, 0.3223, 0.4768],
         [0.2440, 0.6658, 0.2784],
         [0.4159, 0.6929, 0.3286]]]))
test_kwargs = {'eps': 1e-07, 'squared': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function oneway_transfer_error at 0x7f0c72ef0d30>
trace_args = (tensor([[[0.6384, 0.7698],
         [0.8517, 0.9686],
         [0.9629, 0.1631],
         [0.0196, 0.4470]]]), tensor...0.9358]]]), tensor([[[0.7693, 0.4002, 0.2509],
         [0.5066, 0.8068, 0.4181],
         [0.4296, 0.9808, 0.2567]]]))
trace_kwargs = {'eps': 1e-08, 'squared': False}
test_args = (tensor([[[0.7576, 0.5631],
         [0.4228, 0.8668],
         [0.2824, 0.6397],
         [0.0222, 0.2533]],

       ... 0.6432]],

        [[0.1731, 0.3223, 0.4768],
         [0.2440, 0.6658, 0.2784],
         [0.4159, 0.6929, 0.3286]]]))
test_kwargs = {'eps': 1e-07, 'squared': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function oneway_transfer_error at 0x7f0c72ef0d30>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.homography.oneway_transfer_error
_________________________________________________________________________ test_symmetric_transfer_error[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_symmetric_transfer_error(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2),
            torch.rand(1, 4, 2),
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {'squared': True, 'eps': 1e-8}
        test_args = (
            torch.rand(5, 4, 2),
            torch.rand(5, 4, 2),
            torch.rand(5, 3, 3),
        )
        test_kwargs = {'squared': True, 'eps': 1e-7}
>       _test_function(
            kornia.geometry.homography.symmetric_transfer_error,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_homography.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function symmetric_transfer_error at 0x7f0c72ef0e50>
trace_args = (tensor([[[0.2064, 0.7954],
         [0.6208, 0.4696],
         [0.9695, 0.5458],
         [0.1575, 0.6906]]]), tensor...49e-01]]]), tensor([[[0.7770, 0.8346, 0.9874],
         [0.3689, 0.3118, 0.6514],
         [0.2084, 0.9588, 0.5300]]]))
trace_kwargs = {'eps': 1e-08, 'squared': True}
test_args = (tensor([[[0.9107, 0.0310],
         [0.4455, 0.8993],
         [0.3083, 0.8857],
         [0.3691, 0.3070]],

       ... 0.9905]],

        [[0.7038, 0.0572, 0.2889],
         [0.4584, 0.9138, 0.8472],
         [0.8228, 0.2576, 0.2893]]]))
test_kwargs = {'eps': 1e-07, 'squared': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function symmetric_transfer_error at 0x7f0c72ef0e50>
trace_args = (tensor([[[0.2064, 0.7954],
         [0.6208, 0.4696],
         [0.9695, 0.5458],
         [0.1575, 0.6906]]]), tensor...49e-01]]]), tensor([[[0.7770, 0.8346, 0.9874],
         [0.3689, 0.3118, 0.6514],
         [0.2084, 0.9588, 0.5300]]]))
trace_kwargs = {'eps': 1e-08, 'squared': True}
test_args = (tensor([[[0.9107, 0.0310],
         [0.4455, 0.8993],
         [0.3083, 0.8857],
         [0.3691, 0.3070]],

       ... 0.9905]],

        [[0.7038, 0.0572, 0.2889],
         [0.4584, 0.9138, 0.8472],
         [0.8228, 0.2576, 0.2893]]]))
test_kwargs = {'eps': 1e-07, 'squared': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function symmetric_transfer_error at 0x7f0c72ef0e50>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.homography.symmetric_transfer_error
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_homography.py::test_find_homography_dlt[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ens...
FAILED kornia/geometry/test_homography.py::test_find_homography_dlt_iterated[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api...
FAILED kornia/geometry/test_homography.py::test_find_homography_lines_dlt[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ke...
FAILED kornia/geometry/test_homography.py::test_oneway_transfer_error[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, e...
FAILED kornia/geometry/test_homography.py::test_symmetric_transfer_error[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key...
=============================================================================== 5 failed, 3 passed in 143.35s (0:02:23) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 10 items

kornia/test_feature5.py FFFFF.FFF.                                                                                                                                                               [100%]

=============================================================================================== FAILURES ===============================================================================================
________________________________________________________________________________ test_LAFOrienter[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LAFOrienter(target_framework, mode, backend_compile):
        print("kornia.feature.LAFOrienter")
    
        if backend_compile:
            pytest.skip()
    
        import os
        flag = os.environ.get("APPLY_TRANSPOSE_OPTIMIZATION")
        os.environ["APPLY_TRANSPOSE_OPTIMIZATION"] = "false"
    
>       TranspiledLAFOrienter = ivy.transpile(kornia.feature.LAFOrienter, source="torch", target=target_framework)

kornia/test_feature5.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.orientation.LAFOrienter'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LAFOrienter
_____________________________________________________________________ test_PatchDominantGradientOrientation[tensorflow-s2s-False] ______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PatchDominantGradientOrientation(target_framework, mode, backend_compile):
        print("kornia.feature.PatchDominantGradientOrientation")
    
        if backend_compile:
            pytest.skip()
    
        import os
        flag = os.environ.get("APPLY_TRANSPOSE_OPTIMIZATION")
        os.environ["APPLY_TRANSPOSE_OPTIMIZATION"] = "false"
    
>       TranspiledPatchDominantGradientOrientation = ivy.transpile(kornia.feature.PatchDominantGradientOrientation, source="torch", target=target_framework)

kornia/test_feature5.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.orientation.PatchDominantGradientOrientation'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.PatchDominantGradientOrientation
__________________________________________________________________________________ test_OriNet[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_OriNet(target_framework, mode, backend_compile):
        print("kornia.feature.OriNet")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledOriNet = ivy.transpile(kornia.feature.OriNet, source="torch", target=target_framework)

kornia/test_feature5.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.orientation.OriNet'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.OriNet
__________________________________________________________________________ test_LAFAffNetShapeEstimator[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LAFAffNetShapeEstimator(target_framework, mode, backend_compile):
        print("kornia.feature.LAFAffNetShapeEstimator")
    
        if backend_compile:
            pytest.skip()
    
        import os
        flag = os.environ.get("APPLY_TRANSPOSE_OPTIMIZATION")
        os.environ["APPLY_TRANSPOSE_OPTIMIZATION"] = "false"
    
        TranspiledLAFAffNetShapeEstimator = ivy.transpile(kornia.feature.LAFAffNetShapeEstimator, source="torch", target=target_framework)
    
        os.environ["APPLY_TRANSPOSE_OPTIMIZATION"] = flag
    
        laf = torch.rand(10, 2, 2, 3)
        img = torch.rand(10, 1, 32, 32)
        torch_out = kornia.feature.LAFAffNetShapeEstimator()(laf, img)
    
        transpiled_laf = _nest_torch_tensor_to_new_framework(laf, target_framework)
        transpiled_img = _nest_torch_tensor_to_new_framework(img, target_framework)
>       transpiled_out = TranspiledLAFAffNetShapeEstimator()(transpiled_laf, transpiled_img)

kornia/test_feature5.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNor...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
args = (<tf.Tensor: shape=(10, 2, 2, 3), dtype=float32, numpy=
array([[[[0.7265239 , 0.31040525, 0.9445165 ],
         [0.801...,
         [0.19520581, 0.09233981, 0.09280396, ..., 0.22299469,
          0.38871872, 0.03572404]]]], dtype=float32)>)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x562f03628290, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...ode_context=['        return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNo...,
         [0.19520581, 0.09233981, 0.09280396, ..., 0.22299469,
          0.38871872, 0.03572404]]]], dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNor...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(10, 2, 2, 3), dtype=float32, numpy=
array([[[[0.7265239 , 0.31040525, 0.9445165 ],
         [0.801...,
         [0.19520581, 0.09233981, 0.09280396, ..., 0.22299469,
          0.38871872, 0.03572404]]]], dtype=float32)>)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:1666: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNo...,
         [0.19520581, 0.09233981, 0.09280396, ..., 0.22299469,
          0.38871872, 0.03572404]]]], dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNor...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(10, 2, 2, 3), dtype=float32, numpy=
array([[[[0.7265239 , 0.31040525, 0.9445165 ],
         [0.801...,
         [0.19520581, 0.09233981, 0.09280396, ..., 0.22299469,
          0.38871872, 0.03572404]]]], dtype=float32)>)
kwargs = {}, replace_v = False, replace_buffers = False, call_signature = <Signature (laf, img)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Model, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Model, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Model, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:1438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNo...nsorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
),)
kwargs = {'img': <tf.Tensor: shape=(10, 1, 32, 32), dtype=float32, numpy=
array([[[[0.5059113 , 0.64752007, 0.4722659 , ..., 0....9]],

        [[0.53130347, 0.378798  , 0.7600776 ],
         [0.5536881 , 0.24618977, 0.28235954]]]], dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNor...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
laf = <tf.Tensor: shape=(10, 2, 2, 3), dtype=float32, numpy=
array([[[[0.7265239 , 0.31040525, 0.9445165 ],
         [0.8013...29]],

        [[0.53130347, 0.378798  , 0.7600776 ],
         [0.5536881 , 0.24618977, 0.28235954]]]], dtype=float32)>
img = <tf.Tensor: shape=(10, 1, 32, 32), dtype=float32, numpy=
array([[[[0.5059113 , 0.64752007, 0.4722659 , ..., 0.5842618 ...],
         [0.19520581, 0.09233981, 0.09280396, ..., 0.22299469,
          0.38871872, 0.03572404]]]], dtype=float32)>

    def call(self, laf, img):
        from ..core.check import tensorflow_KORNIA_CHECK_LAF
        from ..core.check import tensorflow_KORNIA_CHECK_SHAPE
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_view_frnt_
        from .laf import tensorflow_extract_patches_from_pyramid
        from .laf import tensorflow_make_upright
        from ...ivy.functional.frontends.torch.indexing_slicing_joining_mutating_ops import (
            tensorflow_cat_frnt,
        )
        from ...ivy.functional.frontends.torch.tensor import tensorflow_reshape_frnt_
        from .laf import tensorflow_get_laf_scale
        from .laf import tensorflow_get_laf_orientation
        from .laf import tensorflow_scale_laf
        from .laf import tensorflow_set_laf_orientation
    
        tensorflow_KORNIA_CHECK_LAF(laf)
        tensorflow_KORNIA_CHECK_SHAPE(img, ["B", "1", "H", "W"])
        B, N = tensorflow_shape_frnt_(laf)[:2][0], tensorflow_shape_frnt_(laf)[:2][1]
        PS: typing.Any = self.patch_size
        patches: typing.Any = tensorflow_view_frnt_(
            tensorflow_extract_patches_from_pyramid(
                img, tensorflow_make_upright(laf), PS, True
            ),
            -1,
            1,
            PS,
            PS,
        )
>       xy = tensorflow_view_frnt_(self.features(self._normalize_input(patches)), -1, 3)

Translated_Outputs/tensorflow_outputs/kornia/feature/affine_shape.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): KerasConv2D()
  (1): KerasBatchNorm2D()
  (2): tensorflow_ReLU()
  (3): KerasConv2D()
  ...)
  (18): tensorflow_Dropout()
  (19): KerasConv2D()
  (20): tensorflow_Tanh()
  (21): tensorflow_AdaptiveAvgPool2d()
)
args = (<tf.Tensor: shape=(20, 1, 32, 32), dtype=float32, numpy=
array([[[[22.593248  , 22.593248  , -0.04421379, ..., -0.044...    [ 0.        ,  0.        ,  0.        , ...,  0.        ,
           0.        ,  0.        ]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x562f04c36b60, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...function='__call__', code_context=['                    outputs = super().__call__(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): KerasConv2D()
  (1): KerasBatchNorm2D()
  (2): tensorflow_ReLU()
  (3): KerasConv2D()
  ...)
  (18): tensorflow_Dropout()
  (19): KerasConv2D()
  (20): tensorflow_Tanh()
  (21): tensorflow_AdaptiveAvgPool2d()
)
v = None, buffers = None
args = (<tf.Tensor: shape=(20, 1, 32, 32), dtype=float32, numpy=
array([[[[22.593248  , 22.593248  , -0.04421379, ..., -0.044...    [ 0.        ,  0.        ,  0.        , ...,  0.        ,
           0.        ,  0.        ]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): KerasConv2D()
  (1): KerasBatchNorm2D()
  (2): tensorflow_ReLU()
  (3): KerasConv2D()
  ...)
  (18): tensorflow_Dropout()
  (19): KerasConv2D()
  (20): tensorflow_Tanh()
  (21): tensorflow_AdaptiveAvgPool2d()
)
v = None, buffers = None
args = (<tf.Tensor: shape=(20, 1, 32, 32), dtype=float32, numpy=
array([[[[22.593248  , 22.593248  , -0.04421379, ..., -0.044...    [ 0.        ,  0.        ,  0.        , ...,  0.        ,
           0.        ,  0.        ]]]], dtype=float32)>,)
kwargs = {}, replace_v = False, replace_buffers = False, call_signature = <Signature (input)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): KerasConv2D()
  (1): KerasBatchNorm2D()
  (2): tensorflow_ReLU()
  (3): KerasConv2D()
  ...)
  (18): tensorflow_Dropout()
  (19): KerasConv2D()
  (20): tensorflow_Tanh()
  (21): tensorflow_AdaptiveAvgPool2d()
)
input = <tf.Tensor: shape=(20, 1, 32, 32), dtype=float32, numpy=
array([[[[22.593248  , 22.593248  , -0.04421379, ..., -0.0442...      [ 0.        ,  0.        ,  0.        , ...,  0.        ,
           0.        ,  0.        ]]]], dtype=float32)>

    def call(self, input):
        for module in self:
>           input = module(input)

Translated_Outputs/tensorflow_outputs/torch/nn/modules/container.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = KerasConv2D()
args = (<tf.Tensor: shape=(20, 1, 32, 32), dtype=float32, numpy=
array([[[[22.593248  , 22.593248  , -0.04421379, ..., -0.044...    [ 0.        ,  0.        ,  0.        , ...,  0.        ,
           0.        ,  0.        ]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7ff9631dc780, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...function='__call__', code_context=['                    outputs = super().__call__(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = KerasConv2D()
args = (<tf.Tensor: shape=(20, 1, 32, 32), dtype=float32, numpy=
array([[[[22.593248  , 22.593248  , -0.04421379, ..., -0.044...    [ 0.        ,  0.        ,  0.        , ...,  0.        ,
           0.        ,  0.        ]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    def __call__(self, *args, **kwargs):
        if not self.built:
>           res = super().__call__(*args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful_layers.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = KerasConv2D()
input = <tf.Tensor: shape=(20, 3, 34, 32), dtype=float32, numpy=
array([[[[ 0.        ,  0.        ,  0.        , ...,  0.    ...      [ 0.        ,  0.        ,  0.        , ...,  0.        ,
           0.        ,  0.        ]]]], dtype=float32)>
training = False

    def call(self, input, training=False):
        if self._padding != 0:
            padding_mode = (
                "constant" if self.padding_mode == "zeros" else self.padding_mode
            )
            # handle Pytorch-style padding
            input = torch_pad(
                input, self._reversed_padding_repeated_twice, mode=padding_mode
            )
>       return super().call(input)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful_layers.py:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def tf___conv_xla():
        with ag__.FunctionScope('_conv_xla', 'fscope', ag__.ConversionOptions(recursive=True, user_requested=True, optional_features=(), internal_convert_user_code=True)) as fscope:
            do_return = False
            retval_ = ag__.UndefinedReturnValue()
            try:
                do_return = True
>               retval_ = ag__.converted_call(ag__.ld(_conv), (), None, fscope)
E               ValueError: Exception encountered when calling KerasConv2D.call().
E               
E               [1min user code:
E               
E                   File "/opt/fw/tensorflow/keras/src/backend/tensorflow/nn.py", line 244, in _conv_xla  *
E                       return _conv()
E                   File "/opt/fw/tensorflow/keras/src/backend/tensorflow/nn.py", line 231, in _conv  **
E                       return tf.nn.convolution(
E               
E                   ValueError: Depth of output (16) is not a multiple of the number of groups (3) for '{{node convolution}} = Conv2D[T=DT_FLOAT, data_format="NCHW", dilations=[1, 1, 1, 1], explicit_paddings=[], padding="VALID", strides=[1, 1, 1, 1], use_cudnn_on_gpu=true](convolution/input, convolution/ReadVariableOp)' with input shapes: [20,3,34,32], [3,3,1,16].
E               [0m
E               
E               Arguments received by KerasConv2D.call():
E                  input=tf.Tensor(shape=(20, 1, 32, 32), dtype=float32)
E                  training=False

/tmp/__autograph_generated_filesru79ddn.py:13: ValueError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LAFAffNetShapeEstimator

Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffNetShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                                  
Transpilation of LAFAffNetShapeEstimator complete.
___________________________________________________________________________ test_FilterResponseNorm2d[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_FilterResponseNorm2d(target_framework, mode, backend_compile):
        print("kornia.feature.FilterResponseNorm2d")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledFilterResponseNorm2d = ivy.transpile(kornia.feature.FilterResponseNorm2d, source="torch", target=target_framework)

kornia/test_feature5.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.hynet.FilterResponseNorm2d'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.FilterResponseNorm2d
___________________________________________________________________________________ test_DeFMO[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_DeFMO(target_framework, mode, backend_compile):
        print("kornia.feature.DeFMO")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledDeFMO = ivy.transpile(kornia.feature.DeFMO, source="torch", target=target_framework)
    
        x = torch.rand(2, 6, 240, 320)
        torch_out = kornia.feature.DeFMO()(x)
    
        transpiled_x = _nest_torch_tensor_to_new_framework(x, target_framework)
>       transpiled_out = TranspiledDeFMO()(transpiled_x)

kornia/test_feature5.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_DeFMO(
  (encoder): tensorflow_EncoderDeFMO(
    (net): tensorflow_Sequential(
      (0): tensorflow_Sequen...tensorflow_PixelShuffle()
      (11): KerasConv2D()
      (12): tensorflow_ReLU()
      (13): KerasConv2D()
    )
  )
)
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7ff963a3abc0, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...ode_context=['        return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_DeFMO(
  (encoder): tensorflow_EncoderDeFMO(
    (net): tensorflow_Sequential(
      (0): tensorflow_Seque...,
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_DeFMO(
  (encoder): tensorflow_EncoderDeFMO(
    (net): tensorflow_Sequential(
      (0): tensorflow_Sequen...tensorflow_PixelShuffle()
      (11): KerasConv2D()
      (12): tensorflow_ReLU()
      (13): KerasConv2D()
    )
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:1666: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_DeFMO(
  (encoder): tensorflow_EncoderDeFMO(
    (net): tensorflow_Sequential(
      (0): tensorflow_Seque...,
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_DeFMO(
  (encoder): tensorflow_EncoderDeFMO(
    (net): tensorflow_Sequential(
      (0): tensorflow_Sequen...tensorflow_PixelShuffle()
      (11): KerasConv2D()
      (12): tensorflow_ReLU()
      (13): KerasConv2D()
    )
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}, replace_v = False, replace_buffers = False, call_signature = <Signature (input_data)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Model, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Model, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Model, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:1438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_DeFMO(
  (encoder): tensorflow_EncoderDeFMO(
    (net): tensorflow_Sequential(
      (0): tensorflow_Seque...nsorflow_PixelShuffle()
      (11): KerasConv2D()
      (12): tensorflow_ReLU()
      (13): KerasConv2D()
    )
  )
),)
kwargs = {'input_data': <tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042,...,
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_DeFMO(
  (encoder): tensorflow_EncoderDeFMO(
    (net): tensorflow_Sequential(
      (0): tensorflow_Sequen...tensorflow_PixelShuffle()
      (11): KerasConv2D()
      (12): tensorflow_ReLU()
      (13): KerasConv2D()
    )
  )
)
input_data = <tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.6542672...],
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>

    def call(self, input_data):
>       latent = self.encoder(input_data)

Translated_Outputs/tensorflow_outputs/kornia/feature/defmo.py:1974: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_EncoderDeFMO(
  (net): tensorflow_Sequential(
    (0): tensorflow_Sequential(
      (0): KerasConv2D()
    ...3): KerasConv2D()
          (bn3): KerasBatchNorm2D()
          (relu): tensorflow_ReLU()
        )
      )
    )
  )
)
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7ff9632745e0, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...function='__call__', code_context=['                    outputs = super().__call__(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_EncoderDeFMO(
  (net): tensorflow_Sequential(
    (0): tensorflow_Sequential(
      (0): KerasConv2D()
    ...3): KerasConv2D()
          (bn3): KerasBatchNorm2D()
          (relu): tensorflow_ReLU()
        )
      )
    )
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_EncoderDeFMO(
  (net): tensorflow_Sequential(
    (0): tensorflow_Sequential(
      (0): KerasConv2D()
    ...3): KerasConv2D()
          (bn3): KerasBatchNorm2D()
          (relu): tensorflow_ReLU()
        )
      )
    )
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}, replace_v = False, replace_buffers = False, call_signature = <Signature (input_data)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_EncoderDeFMO(
  (net): tensorflow_Sequential(
    (0): tensorflow_Sequential(
      (0): KerasConv2D()
    ...3): KerasConv2D()
          (bn3): KerasBatchNorm2D()
          (relu): tensorflow_ReLU()
        )
      )
    )
  )
)
input_data = <tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.6542672...],
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>

    def call(self, input_data):
>       return self.net(input_data)

Translated_Outputs/tensorflow_outputs/kornia/feature/defmo.py:1083: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
    (2): tenso...
        (conv3): KerasConv2D()
        (bn3): KerasBatchNorm2D()
        (relu): tensorflow_ReLU()
      )
    )
  )
)
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x562f04a10210, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...function='__call__', code_context=['                    outputs = super().__call__(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
    (2): tenso...
        (conv3): KerasConv2D()
        (bn3): KerasBatchNorm2D()
        (relu): tensorflow_ReLU()
      )
    )
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
    (2): tenso...
        (conv3): KerasConv2D()
        (bn3): KerasBatchNorm2D()
        (relu): tensorflow_ReLU()
      )
    )
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 6, 240, 320), dtype=float32, numpy=
array([[[[0.49581516, 0.4967841 , 0.14137042, ..., 0.654267...
         [0.10701555, 0.38750702, 0.14346492, ..., 0.26652348,
          0.8988693 , 0.31389618]]]], dtype=float32)>,)
kwargs = {}, replace_v = False, replace_buffers = False, call_signature = <Signature (input)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
    (2): tenso...
        (conv3): KerasConv2D()
        (bn3): KerasBatchNorm2D()
        (relu): tensorflow_ReLU()
      )
    )
  )
)
input = <tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.025645...],
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>

    def call(self, input):
        for module in self:
>           input = module(input)

Translated_Outputs/tensorflow_outputs/torch/nn/modules/container.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Sequential(
    (0): tensorflow_Bottleneck(
      (conv1): KerasConv2D()
    ...sBatchNorm2D()
      (conv3): KerasConv2D()
      (bn3): KerasBatchNorm2D()
      (relu): tensorflow_ReLU()
    )
  )
)
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x562f3c6f1580, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...function='__call__', code_context=['                    outputs = super().__call__(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Sequential(
    (0): tensorflow_Bottleneck(
      (conv1): KerasConv2D()
    ...sBatchNorm2D()
      (conv3): KerasConv2D()
      (bn3): KerasBatchNorm2D()
      (relu): tensorflow_ReLU()
    )
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Sequential(
    (0): tensorflow_Bottleneck(
      (conv1): KerasConv2D()
    ...sBatchNorm2D()
      (conv3): KerasConv2D()
      (bn3): KerasBatchNorm2D()
      (relu): tensorflow_ReLU()
    )
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}, replace_v = False, replace_buffers = False, call_signature = <Signature (input)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Sequential(
    (0): tensorflow_Bottleneck(
      (conv1): KerasConv2D()
    ...sBatchNorm2D()
      (conv3): KerasConv2D()
      (bn3): KerasBatchNorm2D()
      (relu): tensorflow_ReLU()
    )
  )
)
input = <tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.025645...],
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>

    def call(self, input):
        for module in self:
>           input = module(input)

Translated_Outputs/tensorflow_outputs/torch/nn/modules/container.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Bottleneck(
    (conv1): KerasConv2D()
    (bn1): KerasBatchNorm2D()
    (con... (bn2): KerasBatchNorm2D()
    (conv3): KerasConv2D()
    (bn3): KerasBatchNorm2D()
    (relu): tensorflow_ReLU()
  )
)
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7ff963abc420, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...function='__call__', code_context=['                    outputs = super().__call__(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Bottleneck(
    (conv1): KerasConv2D()
    (bn1): KerasBatchNorm2D()
    (con... (bn2): KerasBatchNorm2D()
    (conv3): KerasConv2D()
    (bn3): KerasBatchNorm2D()
    (relu): tensorflow_ReLU()
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Bottleneck(
    (conv1): KerasConv2D()
    (bn1): KerasBatchNorm2D()
    (con... (bn2): KerasBatchNorm2D()
    (conv3): KerasConv2D()
    (bn3): KerasBatchNorm2D()
    (relu): tensorflow_ReLU()
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}, replace_v = False, replace_buffers = False, call_signature = <Signature (input)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Sequential(
  (0): tensorflow_Bottleneck(
    (conv1): KerasConv2D()
    (bn1): KerasBatchNorm2D()
    (con... (bn2): KerasBatchNorm2D()
    (conv3): KerasConv2D()
    (bn3): KerasBatchNorm2D()
    (relu): tensorflow_ReLU()
  )
)
input = <tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.025645...],
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>

    def call(self, input):
        for module in self:
>           input = module(input)

Translated_Outputs/tensorflow_outputs/torch/nn/modules/container.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Bottleneck(
  (conv1): KerasConv2D()
  (bn1): KerasBatchNorm2D()
  (conv2): KerasConv2D()
  (bn2): KerasBat...elu): tensorflow_ReLU()
  (downsample): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
  )
)
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7ff9611f7130, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...function='__call__', code_context=['                    outputs = super().__call__(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Bottleneck(
  (conv1): KerasConv2D()
  (bn1): KerasBatchNorm2D()
  (conv2): KerasConv2D()
  (bn2): KerasBat...elu): tensorflow_ReLU()
  (downsample): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Bottleneck(
  (conv1): KerasConv2D()
  (bn1): KerasBatchNorm2D()
  (conv2): KerasConv2D()
  (bn2): KerasBat...elu): tensorflow_ReLU()
  (downsample): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
  )
)
v = None, buffers = None
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}, replace_v = False, replace_buffers = False, call_signature = <Signature (x)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Bottleneck(
  (conv1): KerasConv2D()
  (bn1): KerasBatchNorm2D()
  (conv2): KerasConv2D()
  (bn2): KerasBat...elu): tensorflow_ReLU()
  (downsample): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
  )
)
x = <tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.025645...],
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>

    def call(self, x):
        identity = x
>       out = self.conv1(x)

Translated_Outputs/tensorflow_outputs/kornia/feature/defmo.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = KerasConv2D()
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7ff9611f6480, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...function='__call__', code_context=['                    outputs = super().__call__(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = KerasConv2D()
args = (<tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.02564...
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    def __call__(self, *args, **kwargs):
        if not self.built:
>           res = super().__call__(*args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful_layers.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = KerasConv2D()
input = <tf.Tensor: shape=(2, 64, 120, 157), dtype=float32, numpy=
array([[[[0.        , 0.0453217 , 0.        , ..., 0.025645...],
         [0.11693653, 0.09077523, 0.        , ..., 0.10561664,
          0.12872821, 0.09108906]]]], dtype=float32)>
training = False

    def call(self, input, training=False):
        if self._padding != 0:
            padding_mode = (
                "constant" if self.padding_mode == "zeros" else self.padding_mode
            )
            # handle Pytorch-style padding
            input = torch_pad(
                input, self._reversed_padding_repeated_twice, mode=padding_mode
            )
>       return super().call(input)
E       tensorflow.python.framework.errors_impl.UnimplementedError: Exception encountered when calling KerasConv2D.call().
E       
E       [1m{{function_node __wrapped__Conv2D_device_/job:localhost/replica:0/task:0/device:CPU:0}} The Conv2D op currently only supports the NHWC tensor format on the CPU. The op was given the format: NCHW [Op:Conv2D][0m
E       
E       Arguments received by KerasConv2D.call():
E          input=tf.Tensor(shape=(2, 64, 120, 157), dtype=float32)
E          training=False

Translated_Outputs/tensorflow_outputs/tensorflow__stateful_layers.py:488: UnimplementedError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.DeFMO

Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeFMO from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                
Transpilation of DeFMO complete.
----------------------------------------------------------------------------------------- Captured stderr call -----------------------------------------------------------------------------------------
WARNING: All log messages before absl::InitializeLog() is called are written to STDERR
I0000 00:00:1726339270.538308      34 service.cc:146] XLA service 0x562f036c1960 initialized for platform Host (this does not guarantee that XLA will be used). Devices:
I0000 00:00:1726339270.538390      34 service.cc:154]   StreamExecutor device (0): Host, Default Version
I0000 00:00:1726339270.567111      34 device_compiler.h:188] Compiled cluster using XLA!  This line is logged at most once for the lifetime of the process.
__________________________________________________________________________________ test_DeDoDe[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_DeDoDe(target_framework, mode, backend_compile):
        print("kornia.feature.DeDoDe")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledDeDoDe = ivy.transpile(kornia.feature.DeDoDe, source="torch", target=target_framework)
    
        x = torch.rand(1, 3, 256, 256)
        torch_out = kornia.feature.DeDoDe(amp_dtype=torch.float32)(x)
    
        ivy.set_backend(target_framework)
    
        transpiled_x = _nest_torch_tensor_to_new_framework(x, target_framework)
>       transpiled_out = TranspiledDeDoDe(amp_dtype=ivy.as_native_dtype("float32"))(transpiled_x)

kornia/test_feature5.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_DeDoDe(), detector_model = 'L', descriptor_model = 'G', amp_dtype = tf.float32

    def __init__(self, detector_model="L", descriptor_model="G", amp_dtype=tf.float16):
        from .dedode_models import tensorflow_get_detector
        from .dedode_models import tensorflow_get_descriptor
        from ...enhance.normalize import tensorflow_normalize
        from ....ivy.functional.frontends.torch.creation_ops import (
            tensorflow_tensor_frnt,
        )
    
        self.super___init__(
            detector_model=detector_model,
            descriptor_model=descriptor_model,
            amp_dtype=amp_dtype,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
>       self.detector: typing.Any = tensorflow_get_detector(detector_model, amp_dtype)

Translated_Outputs/tensorflow_outputs/kornia/feature/dedode/dedode.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

kind = 'L', amp_dtype = tf.float32

    def tensorflow_get_detector(kind="L", amp_dtype=tf.float16):
        if kind == "L":
>           return tensorflow_dedode_detector_L(amp_dtype)

Translated_Outputs/tensorflow_outputs/kornia/feature/dedode/dedode_models.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

amp_dtype = tf.float32

    def tensorflow_dedode_detector_L(amp_dtype=tf.float16):
        from ....torch.nn.modules.container import tensorflow_ModuleDict
        from .decoder import tensorflow_ConvRefiner
        from .encoder import tensorflow_VGG19
        from .decoder import tensorflow_Decoder
        from .detector import tensorflow_DeDoDeDetector
    
        NUM_PROTOTYPES = 1
        residual = True
        hidden_blocks = 8
        amp = True
        conv_refiner = tensorflow_ModuleDict(
            {
>               "8": tensorflow_ConvRefiner(
                    512,
                    512,
                    256 + NUM_PROTOTYPES,
                    hidden_blocks=hidden_blocks,
                    residual=residual,
                    amp=amp,
                    amp_dtype=amp_dtype,
                ),
                "4": tensorflow_ConvRefiner(
                    256 + 256,
                    256,
                    128 + NUM_PROTOTYPES,
                    hidden_blocks=hidden_blocks,
                    residual=residual,
                    amp=amp,
                    amp_dtype=amp_dtype,
                ),
                "2": tensorflow_ConvRefiner(
                    128 + 128,
                    128,
                    64 + NUM_PROTOTYPES,
                    hidden_blocks=hidden_blocks,
                    residual=residual,
                    amp=amp,
                    amp_dtype=amp_dtype,
                ),
                "1": tensorflow_ConvRefiner(
                    64 + 64,
                    64,
                    1 + NUM_PROTOTYPES,
                    hidden_blocks=hidden_blocks,
                    residual=residual,
                    amp=amp,
                    amp_dtype=amp_dtype,
                ),
            }
        )

Translated_Outputs/tensorflow_outputs/kornia/feature/dedode/dedode_models.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_ConvRefiner(), args = (512, 512, 257), kwargs = {'amp': True, 'amp_dtype': tf.float32, 'hidden_blocks': 8, 'residual': True}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_ConvRefiner(), in_dim = 512, hidden_dim = 512, out_dim = 257, dw = True, kernel_size = 5, hidden_blocks = 8, amp = True, residual = True, amp_dtype = tf.float32

    @tensorflow_store_config_info
    def __init__(
        self,
        in_dim=6,
        hidden_dim=16,
        out_dim=2,
        dw=True,
        kernel_size=5,
        hidden_blocks=5,
        amp=True,
        residual=False,
        amp_dtype=tf.float16,
    ):
        from ....torch.nn.modules.container import tensorflow_Sequential
        from ....tensorflow__stateful_layers import KerasConv2D
    
        self.super___init__(
            in_dim=in_dim,
            hidden_dim=hidden_dim,
            out_dim=out_dim,
            dw=dw,
            kernel_size=kernel_size,
            hidden_blocks=hidden_blocks,
            amp=amp,
            residual=residual,
            amp_dtype=amp_dtype,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
>       self.block1 = self.create_block(in_dim, hidden_dim, dw=False, kernel_size=1)

Translated_Outputs/tensorflow_outputs/kornia/feature/dedode/decoder.py:466: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_ConvRefiner(), in_dim = 512, out_dim = 512, dw = False, kernel_size = 1, bias = True
norm_type = <class 'Translated_Outputs.tensorflow_outputs.tensorflow__stateful_layers.KerasBatchNorm2D'>

    def create_block(
        self,
        in_dim,
        out_dim,
        dw=True,
        kernel_size=5,
        bias=True,
        norm_type=KerasBatchNorm2D,
    ):
        from ....torch.nn.modules.container import tensorflow_Sequential
        from ....torch.nn.modules.activation import tensorflow_ReLU
        from ....tensorflow__stateful_layers import KerasConv2D
        from ....tensorflow__stateful_layers import resolve_convolution
        from ....tensorflow__stateful_layers import KerasBatchNorm2D
    
        num_groups = 1 if not dw else in_dim
        if dw:
            if out_dim % in_dim != 0:
                raise Exception("outdim must be divisible by indim for depthwise")
        conv1 = resolve_convolution(
            in_channels=in_dim,
            filters=out_dim,
            kernel_size=kernel_size,
            strides=1,
            padding=kernel_size // 2,
            use_bias=bias,
            dilation_rate=1,
            groups=num_groups,
            padding_mode="zeros",
            data_format="channels_first",
        )
        norm = (
>           norm_type(out_dim)
            if norm_type is KerasBatchNorm2D
            else norm_type(num_channels=out_dim)
        )

Translated_Outputs/tensorflow_outputs/kornia/feature/dedode/decoder.py:524: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = KerasBatchNorm2D(), args = (512,), kwargs = {}

    def __init__(self, *args, **kwargs):
        self._previous_frame_info = None
    
        # pytorch layer attributes
>       self.num_features = kwargs.pop("num_features")
E       KeyError: 'num_features'

Translated_Outputs/tensorflow_outputs/tensorflow__stateful_layers.py:580: KeyError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.DeDoDe

Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling DeDoDe from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                 
Transpilation of DeDoDe complete.
----------------------------------------------------------------------------------------- Captured stderr call -----------------------------------------------------------------------------------------
Downloading: "https://dl.fbaipublicfiles.com/dinov2/dinov2_vitl14/dinov2_vitl14_pretrain.pth" to /root/.cache/torch/hub/checkpoints/dinov2_vitl14_pretrain.pth

  0%|          | 0.00/1.13G [00:00<?, ?B/s]
  0%|          | 5.38M/1.13G [00:00<00:21, 56.3MB/s]
  1%|         | 17.4M/1.13G [00:00<00:12, 97.0MB/s]
  3%|         | 31.6M/1.13G [00:00<00:09, 121MB/s] 
  4%|         | 48.1M/1.13G [00:00<00:08, 141MB/s]
  6%|         | 68.8M/1.13G [00:00<00:06, 168MB/s]
  8%|         | 88.8M/1.13G [00:00<00:06, 181MB/s]
  9%|         | 109M/1.13G [00:00<00:05, 190MB/s] 
 11%|         | 129M/1.13G [00:00<00:05, 195MB/s]
 13%|        | 149M/1.13G [00:00<00:05, 200MB/s]
 15%|        | 168M/1.13G [00:01<00:05, 201MB/s]
 16%|        | 188M/1.13G [00:01<00:05, 202MB/s]
 18%|        | 208M/1.13G [00:01<00:04, 204MB/s]
 20%|        | 228M/1.13G [00:01<00:04, 204MB/s]
 21%|       | 248M/1.13G [00:01<00:04, 206MB/s]
 23%|       | 268M/1.13G [00:01<00:04, 207MB/s]
 25%|       | 288M/1.13G [00:01<00:04, 207MB/s]
 27%|       | 308M/1.13G [00:01<00:04, 208MB/s]
 28%|       | 328M/1.13G [00:01<00:04, 208MB/s]
 30%|       | 348M/1.13G [00:01<00:04, 209MB/s]
 32%|      | 368M/1.13G [00:02<00:03, 209MB/s]
 33%|      | 388M/1.13G [00:02<00:03, 209MB/s]
 35%|      | 408M/1.13G [00:02<00:03, 210MB/s]
 37%|      | 428M/1.13G [00:02<00:03, 208MB/s]
 39%|      | 448M/1.13G [00:02<00:03, 209MB/s]
 40%|      | 468M/1.13G [00:02<00:03, 209MB/s]
 42%|     | 489M/1.13G [00:02<00:03, 210MB/s]
 44%|     | 509M/1.13G [00:02<00:03, 208MB/s]
 46%|     | 529M/1.13G [00:02<00:03, 208MB/s]
 47%|     | 549M/1.13G [00:02<00:03, 209MB/s]
 49%|     | 569M/1.13G [00:03<00:02, 209MB/s]
 51%|     | 589M/1.13G [00:03<00:02, 209MB/s]
 52%|    | 609M/1.13G [00:03<00:02, 208MB/s]
 54%|    | 629M/1.13G [00:03<00:02, 208MB/s]
 56%|    | 649M/1.13G [00:03<00:02, 209MB/s]
 58%|    | 670M/1.13G [00:03<00:02, 209MB/s]
 59%|    | 690M/1.13G [00:03<00:02, 210MB/s]
 61%|    | 710M/1.13G [00:03<00:02, 211MB/s]
 63%|   | 730M/1.13G [00:03<00:02, 209MB/s]
 65%|   | 750M/1.13G [00:03<00:02, 209MB/s]
 66%|   | 770M/1.13G [00:04<00:01, 207MB/s]
 68%|   | 790M/1.13G [00:04<00:01, 204MB/s]
 70%|   | 810M/1.13G [00:04<00:01, 203MB/s]
 71%|  | 830M/1.13G [00:04<00:01, 205MB/s]
 73%|  | 850M/1.13G [00:04<00:01, 201MB/s]
 75%|  | 869M/1.13G [00:04<00:01, 202MB/s]
 77%|  | 889M/1.13G [00:04<00:01, 205MB/s]
 78%|  | 909M/1.13G [00:04<00:01, 206MB/s]
 80%|  | 929M/1.13G [00:04<00:01, 207MB/s]
 82%| | 949M/1.13G [00:04<00:01, 207MB/s]
 83%| | 969M/1.13G [00:05<00:00, 202MB/s]
 85%| | 989M/1.13G [00:05<00:00, 206MB/s]
 87%| | 0.99G/1.13G [00:05<00:00, 206MB/s]
 89%| | 1.00G/1.13G [00:05<00:00, 202MB/s]
 90%| | 1.02G/1.13G [00:05<00:00, 205MB/s]
 92%|| 1.04G/1.13G [00:05<00:00, 206MB/s]
 94%|| 1.06G/1.13G [00:05<00:00, 204MB/s]
 96%|| 1.08G/1.13G [00:05<00:00, 207MB/s]
 97%|| 1.10G/1.13G [00:05<00:00, 209MB/s]
 99%|| 1.12G/1.13G [00:05<00:00, 209MB/s]
100%|| 1.13G/1.13G [00:06<00:00, 202MB/s]
------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------
WARNING  dinov2:block.py:32 xFormers not available
___________________________________________________________________________________ test_DISK[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_DISK(target_framework, mode, backend_compile):
        print("kornia.feature.DISK")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledDISK = ivy.transpile(kornia.feature.DISK, source="torch", target=target_framework)

kornia/test_feature5.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.disk.disk.DISK'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.DISK
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_feature5.py::test_LAFOrienter[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_feature5.py::test_PatchDominantGradientOrientation[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, e...
FAILED kornia/test_feature5.py::test_OriNet[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_feature5.py::test_LAFAffNetShapeEstimator[tensorflow-s2s-False] - ValueError: Exception encountered when calling KerasConv2D.call().
FAILED kornia/test_feature5.py::test_FilterResponseNorm2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do...
FAILED kornia/test_feature5.py::test_DeFMO[tensorflow-s2s-False] - tensorflow.python.framework.errors_impl.UnimplementedError: Exception encountered when calling KerasConv2D.call().
FAILED kornia/test_feature5.py::test_DeDoDe[tensorflow-s2s-False] - KeyError: 'num_features'
FAILED kornia/test_feature5.py::test_DISK[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY...
=============================================================================== 8 failed, 2 passed in 972.39s (0:16:12) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 8 items

kornia/geometry/test_bbox.py FFF....F                                                                                                                                                            [100%]

=============================================================================================== FAILURES ===============================================================================================
______________________________________________________________________________ test_bbox_generator[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_bbox_generator(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([0, 1]),
            torch.tensor([1, 0]),
            torch.tensor([5, 3]),
            torch.tensor([7, 4]),
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([2, 3]),
            torch.tensor([4, 5]),
            torch.tensor([6, 8]),
            torch.tensor([10, 12]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.bbox.bbox_generator,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_bbox.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bbox_generator at 0x7f9f7a951fc0>, trace_args = (tensor([0, 1]), tensor([1, 0]), tensor([5, 3]), tensor([7, 4])), trace_kwargs = {}
test_args = (tensor([2, 3]), tensor([4, 5]), tensor([6, 8]), tensor([10, 12])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bbox_generator at 0x7f9f7a951fc0>, trace_args = (tensor([0, 1]), tensor([1, 0]), tensor([5, 3]), tensor([7, 4])), trace_kwargs = {}
test_args = (tensor([2, 3]), tensor([4, 5]), tensor([6, 8]), tensor([10, 12])), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function bbox_generator at 0x7f9f7a951fc0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.bbox.bbox_generator
_____________________________________________________________________________ test_bbox_generator3d[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_bbox_generator3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([0, 3]),
            torch.tensor([1, 4]),
            torch.tensor([2, 5]),
            torch.tensor([10, 40]),
            torch.tensor([20, 50]),
            torch.tensor([30, 60]),
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([5, 8]),
            torch.tensor([6, 7]),
            torch.tensor([9, 11]),
            torch.tensor([15, 20]),
            torch.tensor([25, 30]),
            torch.tensor([35, 45]),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.bbox.bbox_generator3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_bbox.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bbox_generator3d at 0x7f9f7a952050>, trace_args = (tensor([0, 3]), tensor([1, 4]), tensor([2, 5]), tensor([10, 40]), tensor([20, 50]), tensor([30, 60])), trace_kwargs = {}
test_args = (tensor([5, 8]), tensor([6, 7]), tensor([ 9, 11]), tensor([15, 20]), tensor([25, 30]), tensor([35, 45])), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bbox_generator3d at 0x7f9f7a952050>, trace_args = (tensor([0, 3]), tensor([1, 4]), tensor([2, 5]), tensor([10, 40]), tensor([20, 50]), tensor([30, 60])), trace_kwargs = {}
test_args = (tensor([5, 8]), tensor([6, 7]), tensor([ 9, 11]), tensor([15, 20]), tensor([25, 30]), tensor([35, 45])), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function bbox_generator3d at 0x7f9f7a952050>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.bbox.bbox_generator3d
_______________________________________________________________________________ test_bbox_to_mask[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_bbox_to_mask(target_framework, mode, backend_compile):
        trace_args = (
            torch.tensor([[[1., 1.], [3., 1.], [3., 2.], [1., 2.]]]),
            5,
            5,
        )
        trace_kwargs = {}
        test_args = (
            torch.tensor([[[2., 2.], [4., 2.], [4., 3.], [2., 3.]]]),
            6,
            6,
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.bbox.bbox_to_mask,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_bbox.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bbox_to_mask at 0x7f9f7a951ea0>, trace_args = (tensor([[[1., 1.],
         [3., 1.],
         [3., 2.],
         [1., 2.]]]), 5, 5), trace_kwargs = {}
test_args = (tensor([[[2., 2.],
         [4., 2.],
         [4., 3.],
         [2., 3.]]]), 6, 6), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s'
skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bbox_to_mask at 0x7f9f7a951ea0>, trace_args = (tensor([[[1., 1.],
         [3., 1.],
         [3., 2.],
         [1., 2.]]]), 5, 5), trace_kwargs = {}
test_args = (tensor([[[2., 2.],
         [4., 2.],
         [4., 3.],
         [2., 3.]]]), 6, 6), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[0., 0., 0., 0., 0.],
         [0., 1., 1., 1., 0.],
         [0., 1., 1., 1., 0.],
         [0., 0., 0., 0., 0.],
         [0., 0., 0., 0., 0.]]])
transpiled_x = <tf.Tensor: shape=(1, 5, 5), dtype=float32, numpy=
array([[[0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]]], dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[0., 0., 0., 0., 0.],
        [0., 1., 1., 1., 0.],
        [0., 1., 1., 1., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]]], dtype=float32)
y = array([[[0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]]], dtype=float32), tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.bbox.bbox_to_mask

Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bbox_to_mask from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
                                                                                                                                          
Transpilation of bbox_to_mask complete.
______________________________________________________________________________ test_transform_bbox[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_transform_bbox(target_framework, mode, backend_compile):
        trace_args = (
            torch.eye(3).unsqueeze(0),
            torch.tensor([[
                [0., 0.], [2., 0.], [2., 2.], [0., 2.]
            ]]),
        )
        trace_kwargs = {'mode': 'xyxy'}
        test_args = (
            torch.eye(3).unsqueeze(0),
            torch.tensor([[
                [1., 1.], [3., 1.], [3., 3.], [1., 3.]
            ]]),
        )
        test_kwargs = {'mode': 'xyxy'}
>       _test_function(
            kornia.geometry.bbox.transform_bbox,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_bbox.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function transform_bbox at 0x7f9f7a9520e0>
trace_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[[0., 0.],
         [2., 0.],
         [2., 2.],
         [0., 2.]]])), trace_kwargs = {'mode': 'xyxy'}
test_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[[1., 1.],
         [3., 1.],
         [3., 3.],
         [1., 3.]]])), test_kwargs = {'mode': 'xyxy'}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function transform_bbox at 0x7f9f7a9520e0>
trace_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[[0., 0.],
         [2., 0.],
         [2., 2.],
         [0., 2.]]])), trace_kwargs = {'mode': 'xyxy'}
test_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[[1., 1.],
         [3., 1.],
         [3., 3.],
         [1., 3.]]])), test_kwargs = {'mode': 'xyxy'}
target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function transform_bbox at 0x7f9f7a9520e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.bbox.transform_bbox
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_bbox.py::test_bbox_generator[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connect...
FAILED kornia/geometry/test_bbox.py::test_bbox_generator3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet conne...
FAILED kornia/geometry/test_bbox.py::test_bbox_to_mask[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/geometry/test_bbox.py::test_transform_bbox[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
=============================================================================== 4 failed, 4 passed in 120.07s (0:02:00) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 44 items

kornia/test_filters.py FFFFFFF..FFFFFFFFFFFFFFFFFFFFF..FF..FFFFFFFF                                                                                                                              [100%]

=============================================================================================== FAILURES ===============================================================================================
______________________________________________________________________________ test_bilateral_blur[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_bilateral_blur(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            (3, 3),
            0.1,
            (1.5, 1.5),
        )
        trace_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}
        test_args = (
            torch.rand(5, 3, 5, 5),
            (5, 5),
            0.2,
            (2.0, 2.0),
        )
        test_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}
>       _test_function(
            kornia.filters.bilateral_blur,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bilateral_blur at 0x7f0f1535f130>
trace_args = (tensor([[[[9.3331e-01, 7.9191e-01, 9.7104e-01, 1.6863e-01, 6.7374e-01],
          [6.8764e-01, 4.6357e-01, 2.5270e-01...e-01, 3.8948e-01],
          [7.4008e-01, 6.1454e-01, 8.5823e-02, 6.3330e-01, 4.3781e-02]]]]), (3, 3), 0.1, (1.5, 1.5))
trace_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}
test_args = (tensor([[[[7.1888e-01, 8.5891e-02, 5.1733e-01, 4.4035e-01, 1.9272e-01],
          [6.7902e-01, 3.6767e-01, 8.2732e-01...e-01, 6.2096e-02],
          [2.1524e-01, 6.8553e-01, 6.7672e-01, 2.6726e-01, 5.3519e-01]]]]), (5, 5), 0.2, (2.0, 2.0))
test_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bilateral_blur at 0x7f0f1535f130>
trace_args = (tensor([[[[9.3331e-01, 7.9191e-01, 9.7104e-01, 1.6863e-01, 6.7374e-01],
          [6.8764e-01, 4.6357e-01, 2.5270e-01...e-01, 3.8948e-01],
          [7.4008e-01, 6.1454e-01, 8.5823e-02, 6.3330e-01, 4.3781e-02]]]]), (3, 3), 0.1, (1.5, 1.5))
trace_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}
test_args = (tensor([[[[7.1888e-01, 8.5891e-02, 5.1733e-01, 4.4035e-01, 1.9272e-01],
          [6.7902e-01, 3.6767e-01, 8.2732e-01...e-01, 6.2096e-02],
          [2.1524e-01, 6.8553e-01, 6.7672e-01, 2.6726e-01, 5.3519e-01]]]]), (5, 5), 0.2, (2.0, 2.0))
test_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function bilateral_blur at 0x7f0f1535f130>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.bilateral.bilateral_blur
________________________________________________________________________________ test_blur_pool2d[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_blur_pool2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            3,
        )
        trace_kwargs = {'stride': 2}
        test_args = (
            torch.rand(5, 3, 8, 8),
            3,  # NOTE: changing this kernel size fails the test; also true for some of the other tests in this file
        )
        test_kwargs = {'stride': 2}
>       _test_function(
            kornia.filters.blur_pool2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function blur_pool2d at 0x7f0f153680d0>
trace_args = (tensor([[[[0.4843, 0.8581, 0.9632, 0.9469, 0.9149],
          [0.3879, 0.6751, 0.6154, 0.1116, 0.2532],
          [0....0.3983],
          [0.9086, 0.5399, 0.2752, 0.7511, 0.3268],
          [0.3742, 0.7939, 0.8534, 0.0079, 0.7910]]]]), 3)
trace_kwargs = {'stride': 2}
test_args = (tensor([[[[7.6867e-01, 6.1339e-01, 8.2286e-01, 3.1897e-01, 2.9674e-01,
           9.7260e-01, 1.9673e-01, 7.7839e-01]...    [6.9361e-01, 5.0357e-01, 9.2566e-01, 1.2993e-01, 1.0879e-01,
           5.7759e-01, 6.6829e-01, 2.9291e-01]]]]), 3)
test_kwargs = {'stride': 2}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function blur_pool2d at 0x7f0f153680d0>
trace_args = (tensor([[[[0.4843, 0.8581, 0.9632, 0.9469, 0.9149],
          [0.3879, 0.6751, 0.6154, 0.1116, 0.2532],
          [0....0.3983],
          [0.9086, 0.5399, 0.2752, 0.7511, 0.3268],
          [0.3742, 0.7939, 0.8534, 0.0079, 0.7910]]]]), 3)
trace_kwargs = {'stride': 2}
test_args = (tensor([[[[7.6867e-01, 6.1339e-01, 8.2286e-01, 3.1897e-01, 2.9674e-01,
           9.7260e-01, 1.9673e-01, 7.7839e-01]...    [6.9361e-01, 5.0357e-01, 9.2566e-01, 1.2993e-01, 1.0879e-01,
           5.7759e-01, 6.6829e-01, 2.9291e-01]]]]), 3)
test_kwargs = {'stride': 2}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function blur_pool2d at 0x7f0f153680d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.blur_pool.blur_pool2d
_________________________________________________________________________________ test_box_blur[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_box_blur(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            (3, 3),
        )
        trace_kwargs = {'border_type': 'reflect', 'separable': False}
        test_args = (
            torch.rand(5, 3, 5, 5),
            (3, 3),
        )
        test_kwargs = {'border_type': 'reflect', 'separable': False}
>       _test_function(
            kornia.filters.box_blur,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function box_blur at 0x7f0f1535f760>
trace_args = (tensor([[[[0.2012, 0.9557, 0.5762, 0.5734, 0.8478],
          [0.5060, 0.7402, 0.9495, 0.0161, 0.7781],
          [0....2],
          [0.8690, 0.6094, 0.6312, 0.9594, 0.4425],
          [0.2762, 0.5190, 0.6364, 0.1166, 0.9519]]]]), (3, 3))
trace_kwargs = {'border_type': 'reflect', 'separable': False}
test_args = (tensor([[[[9.2490e-01, 2.3743e-02, 6.4372e-02, 1.5737e-01, 5.2802e-01],
          [1.7058e-01, 2.9296e-01, 2.6918e-01....8339e-01, 4.6332e-01, 1.8301e-02],
          [6.4778e-01, 7.9981e-02, 6.4780e-01, 6.5725e-01, 2.5145e-01]]]]), (3, 3))
test_kwargs = {'border_type': 'reflect', 'separable': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function box_blur at 0x7f0f1535f760>
trace_args = (tensor([[[[0.2012, 0.9557, 0.5762, 0.5734, 0.8478],
          [0.5060, 0.7402, 0.9495, 0.0161, 0.7781],
          [0....2],
          [0.8690, 0.6094, 0.6312, 0.9594, 0.4425],
          [0.2762, 0.5190, 0.6364, 0.1166, 0.9519]]]]), (3, 3))
trace_kwargs = {'border_type': 'reflect', 'separable': False}
test_args = (tensor([[[[9.2490e-01, 2.3743e-02, 6.4372e-02, 1.5737e-01, 5.2802e-01],
          [1.7058e-01, 2.9296e-01, 2.6918e-01....8339e-01, 4.6332e-01, 1.8301e-02],
          [6.4778e-01, 7.9981e-02, 6.4780e-01, 6.5725e-01, 2.5145e-01]]]]), (3, 3))
test_kwargs = {'border_type': 'reflect', 'separable': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function box_blur at 0x7f0f1535f760>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.blur.box_blur
______________________________________________________________________________ test_gaussian_blur2d[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_gaussian_blur2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            (3, 3),
            (1.5, 1.5),
        )
        trace_kwargs = {'border_type': 'reflect', 'separable': True}
        test_args = (
            torch.rand(5, 3, 5, 5),
            (3, 3),
            (1.5, 1.5),
        )
        test_kwargs = {'border_type': 'reflect', 'separable': True}
>       _test_function(
            kornia.filters.gaussian_blur2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function gaussian_blur2d at 0x7f0f15368b80>
trace_args = (tensor([[[[0.1333, 0.3257, 0.8708, 0.3078, 0.9387],
          [0.1573, 0.1477, 0.2603, 0.3923, 0.0862],
          [0....  [0.8620, 0.9133, 0.3126, 0.0016, 0.0307],
          [0.3857, 0.5276, 0.8081, 0.2487, 0.1888]]]]), (3, 3), (1.5, 1.5))
trace_kwargs = {'border_type': 'reflect', 'separable': True}
test_args = (tensor([[[[6.0591e-01, 1.2009e-03, 1.6723e-01, 3.6355e-01, 8.5014e-01],
          [3.6954e-02, 8.4339e-01, 8.9223e-01....6183e-02, 4.4621e-01],
          [6.4776e-01, 1.0914e-01, 7.6500e-02, 4.0215e-01, 1.5350e-01]]]]), (3, 3), (1.5, 1.5))
test_kwargs = {'border_type': 'reflect', 'separable': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function gaussian_blur2d at 0x7f0f15368b80>
trace_args = (tensor([[[[0.1333, 0.3257, 0.8708, 0.3078, 0.9387],
          [0.1573, 0.1477, 0.2603, 0.3923, 0.0862],
          [0....  [0.8620, 0.9133, 0.3126, 0.0016, 0.0307],
          [0.3857, 0.5276, 0.8081, 0.2487, 0.1888]]]]), (3, 3), (1.5, 1.5))
trace_kwargs = {'border_type': 'reflect', 'separable': True}
test_args = (tensor([[[[6.0591e-01, 1.2009e-03, 1.6723e-01, 3.6355e-01, 8.5014e-01],
          [3.6954e-02, 8.4339e-01, 8.9223e-01....6183e-02, 4.4621e-01],
          [6.4776e-01, 1.0914e-01, 7.6500e-02, 4.0215e-01, 1.5350e-01]]]]), (3, 3), (1.5, 1.5))
test_kwargs = {'border_type': 'reflect', 'separable': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function gaussian_blur2d at 0x7f0f15368b80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.gaussian.gaussian_blur2d
________________________________________________________________________________ test_guided_blur[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_guided_blur(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(1, 3, 5, 5),
            (3, 3),
            0.1,
        )
        trace_kwargs = {'border_type': 'reflect', 'subsample': 1}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(5, 3, 5, 5),
            (3, 3),
            0.1,
        )
        test_kwargs = {'border_type': 'reflect', 'subsample': 1}
>       _test_function(
            kornia.filters.guided_blur,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function guided_blur at 0x7f0f1536a830>
trace_args = (tensor([[[[0.9722, 0.8703, 0.8492, 0.1416, 0.7496],
          [0.0894, 0.8336, 0.9612, 0.3109, 0.0054],
          [0....         [0.6210, 0.9020, 0.8748, 0.2884, 0.2602],
          [0.0368, 0.4149, 0.5032, 0.6723, 0.8420]]]]), (3, 3), 0.1)
trace_kwargs = {'border_type': 'reflect', 'subsample': 1}
test_args = (tensor([[[[1.4775e-01, 6.8058e-01, 3.4455e-01, 2.5808e-01, 6.0021e-02],
          [8.3628e-01, 1.1631e-01, 1.8068e-01...         [0.4040, 0.7225, 0.3744, 0.1160, 0.3975],
          [0.6091, 0.8400, 0.6526, 0.5928, 0.5906]]]]), (3, 3), 0.1)
test_kwargs = {'border_type': 'reflect', 'subsample': 1}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function guided_blur at 0x7f0f1536a830>
trace_args = (tensor([[[[0.9722, 0.8703, 0.8492, 0.1416, 0.7496],
          [0.0894, 0.8336, 0.9612, 0.3109, 0.0054],
          [0....         [0.6210, 0.9020, 0.8748, 0.2884, 0.2602],
          [0.0368, 0.4149, 0.5032, 0.6723, 0.8420]]]]), (3, 3), 0.1)
trace_kwargs = {'border_type': 'reflect', 'subsample': 1}
test_args = (tensor([[[[1.4775e-01, 6.8058e-01, 3.4455e-01, 2.5808e-01, 6.0021e-02],
          [8.3628e-01, 1.1631e-01, 1.8068e-01...         [0.4040, 0.7225, 0.3744, 0.1160, 0.3975],
          [0.6091, 0.8400, 0.6526, 0.5928, 0.5906]]]]), (3, 3), 0.1)
test_kwargs = {'border_type': 'reflect', 'subsample': 1}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function guided_blur at 0x7f0f1536a830>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.guided.guided_blur
___________________________________________________________________________ test_joint_bilateral_blur[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_joint_bilateral_blur(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(1, 3, 5, 5),
            (3, 3),
            0.1,
            (1.5, 1.5),
        )
        trace_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}
        test_args = (
            torch.rand(4, 3, 5, 5),
            torch.rand(4, 3, 5, 5),
            (5, 5),
            0.2,
            (2.0, 2.0),
        )
        test_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}
>       _test_function(
            kornia.filters.joint_bilateral_blur,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function joint_bilateral_blur at 0x7f0f1535f2e0>
trace_args = (tensor([[[[0.8764, 0.8062, 0.8153, 0.4290, 0.4959],
          [0.4428, 0.3371, 0.9518, 0.5470, 0.2869],
          [0....6673, 0.5085, 0.7930, 0.3208, 0.3365],
          [0.9766, 0.8473, 0.4002, 0.0279, 0.8101]]]]), (3, 3), 0.1, (1.5, 1.5))
trace_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}
test_args = (tensor([[[[2.8020e-01, 9.8229e-01, 7.4548e-01, 3.3483e-01, 5.0033e-01],
          [8.3171e-01, 9.8015e-01, 8.5609e-01...3097, 0.5049, 0.6759, 0.1664, 0.1164],
          [0.7638, 0.7445, 0.6216, 0.0733, 0.2629]]]]), (5, 5), 0.2, (2.0, 2.0))
test_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function joint_bilateral_blur at 0x7f0f1535f2e0>
trace_args = (tensor([[[[0.8764, 0.8062, 0.8153, 0.4290, 0.4959],
          [0.4428, 0.3371, 0.9518, 0.5470, 0.2869],
          [0....6673, 0.5085, 0.7930, 0.3208, 0.3365],
          [0.9766, 0.8473, 0.4002, 0.0279, 0.8101]]]]), (3, 3), 0.1, (1.5, 1.5))
trace_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}
test_args = (tensor([[[[2.8020e-01, 9.8229e-01, 7.4548e-01, 3.3483e-01, 5.0033e-01],
          [8.3171e-01, 9.8015e-01, 8.5609e-01...3097, 0.5049, 0.6759, 0.1664, 0.1164],
          [0.7638, 0.7445, 0.6216, 0.0733, 0.2629]]]]), (5, 5), 0.2, (2.0, 2.0))
test_kwargs = {'border_type': 'reflect', 'color_distance_type': 'l1'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function joint_bilateral_blur at 0x7f0f1535f2e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.bilateral.joint_bilateral_blur
______________________________________________________________________________ test_max_blur_pool2d[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_max_blur_pool2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            3,
        )
        trace_kwargs = {'stride': 2, 'max_pool_size': 2, 'ceil_mode': False}
        test_args = (
            torch.rand(5, 3, 8, 8),
            3,
        )
        test_kwargs = {'stride': 2, 'max_pool_size': 2, 'ceil_mode': False}
>       _test_function(
            kornia.filters.max_blur_pool2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function max_blur_pool2d at 0x7f0f153684c0>
trace_args = (tensor([[[[0.3580, 0.0390, 0.9398, 0.1594, 0.8559],
          [0.9289, 0.2015, 0.2549, 0.2381, 0.4342],
          [0....0.6176],
          [0.4364, 0.2785, 0.2875, 0.0972, 0.2515],
          [0.8701, 0.1671, 0.4509, 0.4559, 0.5375]]]]), 3)
trace_kwargs = {'ceil_mode': False, 'max_pool_size': 2, 'stride': 2}
test_args = (tensor([[[[0.4661, 0.0366, 0.3830, 0.7313, 0.1168, 0.0241, 0.8174, 0.8950],
          [0.0531, 0.8972, 0.1673, 0.6295...89, 0.8200, 0.9538, 0.7342, 0.2634],
          [0.3083, 0.5293, 0.9491, 0.4712, 0.4079, 0.3213, 0.9182, 0.0317]]]]), 3)
test_kwargs = {'ceil_mode': False, 'max_pool_size': 2, 'stride': 2}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function max_blur_pool2d at 0x7f0f153684c0>
trace_args = (tensor([[[[0.3580, 0.0390, 0.9398, 0.1594, 0.8559],
          [0.9289, 0.2015, 0.2549, 0.2381, 0.4342],
          [0....0.6176],
          [0.4364, 0.2785, 0.2875, 0.0972, 0.2515],
          [0.8701, 0.1671, 0.4509, 0.4559, 0.5375]]]]), 3)
trace_kwargs = {'ceil_mode': False, 'max_pool_size': 2, 'stride': 2}
test_args = (tensor([[[[0.4661, 0.0366, 0.3830, 0.7313, 0.1168, 0.0241, 0.8174, 0.8950],
          [0.0531, 0.8972, 0.1673, 0.6295...89, 0.8200, 0.9538, 0.7342, 0.2634],
          [0.3083, 0.5293, 0.9491, 0.4712, 0.4079, 0.3213, 0.9182, 0.0317]]]]), 3)
test_kwargs = {'ceil_mode': False, 'max_pool_size': 2, 'stride': 2}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function max_blur_pool2d at 0x7f0f153684c0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.blur_pool.max_blur_pool2d
_______________________________________________________________________________ test_unsharp_mask[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_unsharp_mask(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            (3, 3),
            (1.5, 1.5),
        )
        trace_kwargs = {'border_type': 'reflect'}
        test_args = (
            torch.rand(5, 3, 5, 5),
            (5, 5),
            (2.0, 2.0),
        )
        test_kwargs = {'border_type': 'reflect'}
>       _test_function(
            kornia.filters.unsharp_mask,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function unsharp_mask at 0x7f0f15261d80>
trace_args = (tensor([[[[0.6948, 0.9412, 0.6157, 0.8670, 0.5276],
          [0.6593, 0.8218, 0.4957, 0.9396, 0.8002],
          [0....  [0.1723, 0.6754, 0.2002, 0.6646, 0.0986],
          [0.2678, 0.0060, 0.8209, 0.7173, 0.4541]]]]), (3, 3), (1.5, 1.5))
trace_kwargs = {'border_type': 'reflect'}
test_args = (tensor([[[[0.3241, 0.4489, 0.7415, 0.1361, 0.4230],
          [0.4775, 0.8492, 0.8742, 0.0905, 0.7407],
          [0....  [0.5707, 0.9100, 0.8971, 0.8075, 0.7397],
          [0.6581, 0.6542, 0.3237, 0.4384, 0.8259]]]]), (5, 5), (2.0, 2.0))
test_kwargs = {'border_type': 'reflect'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function unsharp_mask at 0x7f0f15261d80>
trace_args = (tensor([[[[0.6948, 0.9412, 0.6157, 0.8670, 0.5276],
          [0.6593, 0.8218, 0.4957, 0.9396, 0.8002],
          [0....  [0.1723, 0.6754, 0.2002, 0.6646, 0.0986],
          [0.2678, 0.0060, 0.8209, 0.7173, 0.4541]]]]), (3, 3), (1.5, 1.5))
trace_kwargs = {'border_type': 'reflect'}
test_args = (tensor([[[[0.3241, 0.4489, 0.7415, 0.1361, 0.4230],
          [0.4775, 0.8492, 0.8742, 0.0905, 0.7407],
          [0....  [0.5707, 0.9100, 0.8971, 0.8075, 0.7397],
          [0.6581, 0.6542, 0.3237, 0.4384, 0.8259]]]]), (5, 5), (2.0, 2.0))
test_kwargs = {'border_type': 'reflect'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function unsharp_mask at 0x7f0f15261d80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.unsharp.unsharp_mask
___________________________________________________________________________________ test_canny[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_canny(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {
            'low_threshold': 0.1,
            'high_threshold': 0.2,
            'kernel_size': (5, 5),
            'sigma': (1, 1),
            'hysteresis': True,
            'eps': 1e-6,
        }
        test_args = (
            torch.rand(5, 3, 4, 4),
        )
        test_kwargs = {
            'low_threshold': 0.2,
            'high_threshold': 0.3,
            'kernel_size': (5, 5),
            'sigma': (1, 1),
            'hysteresis': True,
            'eps': 1e-6,
        }
>       _test_function(
            kornia.filters.canny,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:302: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function canny at 0x7f0f153688b0>
trace_args = (tensor([[[[0.6924, 0.8541, 0.5589, 0.4771],
          [0.8262, 0.5360, 0.9504, 0.6995],
          [0.2381, 0.1195, 0...., 0.1238, 0.3557, 0.8932],
          [0.8458, 0.8111, 0.3576, 0.1686],
          [0.2472, 0.9829, 0.1338, 0.3346]]]]),)
trace_kwargs = {'eps': 1e-06, 'high_threshold': 0.2, 'hysteresis': True, 'kernel_size': (5, 5), ...}
test_args = (tensor([[[[6.9281e-02, 7.6981e-01, 4.5937e-01, 2.9616e-01],
          [2.7578e-01, 2.0627e-01, 2.9238e-01, 6.3831e-01...     [9.8122e-02, 1.4456e-01, 5.1570e-01, 9.3053e-01],
          [3.7773e-01, 5.9572e-02, 9.0634e-01, 8.8134e-01]]]]),)
test_kwargs = {'eps': 1e-06, 'high_threshold': 0.3, 'hysteresis': True, 'kernel_size': (5, 5), ...}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False
deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function canny at 0x7f0f153688b0>
trace_args = (tensor([[[[0.6924, 0.8541, 0.5589, 0.4771],
          [0.8262, 0.5360, 0.9504, 0.6995],
          [0.2381, 0.1195, 0...., 0.1238, 0.3557, 0.8932],
          [0.8458, 0.8111, 0.3576, 0.1686],
          [0.2472, 0.9829, 0.1338, 0.3346]]]]),)
trace_kwargs = {'eps': 1e-06, 'high_threshold': 0.2, 'hysteresis': True, 'kernel_size': (5, 5), ...}
test_args = (tensor([[[[6.9281e-02, 7.6981e-01, 4.5937e-01, 2.9616e-01],
          [2.7578e-01, 2.0627e-01, 2.9238e-01, 6.3831e-01...     [9.8122e-02, 1.4456e-01, 5.1570e-01, 9.3053e-01],
          [3.7773e-01, 5.9572e-02, 9.0634e-01, 8.8134e-01]]]]),)
test_kwargs = {'eps': 1e-06, 'high_threshold': 0.3, 'hysteresis': True, 'kernel_size': (5, 5), ...}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function canny at 0x7f0f153688b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.canny.canny
_________________________________________________________________________________ test_laplacian[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_laplacian(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 4, 5, 5),
            3,
        )
        trace_kwargs = {
            'border_type': 'reflect',
            'normalized': True,
        }
        test_args = (
            torch.rand(5, 4, 5, 5),
            3,
        )
        test_kwargs = {
            'border_type': 'reflect',
            'normalized': True,
        }
>       _test_function(
            kornia.filters.laplacian,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laplacian at 0x7f0f15443760>
trace_args = (tensor([[[[0.2355, 0.9082, 0.6526, 0.8298, 0.9303],
          [0.7298, 0.4318, 0.8490, 0.0327, 0.0913],
          [0....0.1627],
          [0.4231, 0.7571, 0.9244, 0.8056, 0.1358],
          [0.1020, 0.1480, 0.9116, 0.4846, 0.2077]]]]), 3)
trace_kwargs = {'border_type': 'reflect', 'normalized': True}
test_args = (tensor([[[[0.0355, 0.6612, 0.5361, 0.7493, 0.5905],
          [0.3862, 0.2427, 0.5352, 0.5163, 0.9837],
          [0....0.0693],
          [0.9263, 0.2961, 0.6801, 0.9665, 0.0156],
          [0.4010, 0.4288, 0.8091, 0.8458, 0.1148]]]]), 3)
test_kwargs = {'border_type': 'reflect', 'normalized': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laplacian at 0x7f0f15443760>
trace_args = (tensor([[[[0.2355, 0.9082, 0.6526, 0.8298, 0.9303],
          [0.7298, 0.4318, 0.8490, 0.0327, 0.0913],
          [0....0.1627],
          [0.4231, 0.7571, 0.9244, 0.8056, 0.1358],
          [0.1020, 0.1480, 0.9116, 0.4846, 0.2077]]]]), 3)
trace_kwargs = {'border_type': 'reflect', 'normalized': True}
test_args = (tensor([[[[0.0355, 0.6612, 0.5361, 0.7493, 0.5905],
          [0.3862, 0.2427, 0.5352, 0.5163, 0.9837],
          [0....0.0693],
          [0.9263, 0.2961, 0.6801, 0.9665, 0.0156],
          [0.4010, 0.4288, 0.8091, 0.8458, 0.1148]]]]), 3)
test_kwargs = {'border_type': 'reflect', 'normalized': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function laplacian at 0x7f0f15443760>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.laplacian.laplacian
___________________________________________________________________________________ test_sobel[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_sobel(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {
            'normalized': True,
            'eps': 1e-6,
        }
        test_args = (
            torch.rand(5, 3, 4, 4),
        )
        test_kwargs = {
            'normalized': True,
            'eps': 1e-5,
        }
>       _test_function(
            kornia.filters.sobel,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function sobel at 0x7f0f15369240>
trace_args = (tensor([[[[0.3838, 0.8740, 0.7165, 0.6026],
          [0.7481, 0.7259, 0.2222, 0.6410],
          [0.3026, 0.3753, 0...., 0.1867, 0.8621, 0.7893],
          [0.4992, 0.3597, 0.5823, 0.8170],
          [0.0086, 0.0883, 0.5222, 0.4395]]]]),)
trace_kwargs = {'eps': 1e-06, 'normalized': True}
test_args = (tensor([[[[0.0321, 0.8988, 0.8132, 0.3437],
          [0.5218, 0.8633, 0.0310, 0.5572],
          [0.3189, 0.2273, 0...., 0.8195, 0.0285, 0.7780],
          [0.4690, 0.3041, 0.9359, 0.5687],
          [0.2392, 0.8158, 0.1672, 0.3792]]]]),)
test_kwargs = {'eps': 1e-05, 'normalized': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function sobel at 0x7f0f15369240>
trace_args = (tensor([[[[0.3838, 0.8740, 0.7165, 0.6026],
          [0.7481, 0.7259, 0.2222, 0.6410],
          [0.3026, 0.3753, 0...., 0.1867, 0.8621, 0.7893],
          [0.4992, 0.3597, 0.5823, 0.8170],
          [0.0086, 0.0883, 0.5222, 0.4395]]]]),)
trace_kwargs = {'eps': 1e-06, 'normalized': True}
test_args = (tensor([[[[0.0321, 0.8988, 0.8132, 0.3437],
          [0.5218, 0.8633, 0.0310, 0.5572],
          [0.3189, 0.2273, 0...., 0.8195, 0.0285, 0.7780],
          [0.4690, 0.3041, 0.9359, 0.5687],
          [0.2392, 0.8158, 0.1672, 0.3792]]]]),)
test_kwargs = {'eps': 1e-05, 'normalized': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function sobel at 0x7f0f15369240>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.sobel.sobel
_____________________________________________________________________________ test_spatial_gradient[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_spatial_gradient(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {
            'mode': 'sobel',
            'order': 1,
            'normalized': True,
        }
        test_args = (
            torch.rand(5, 3, 4, 4),
        )
        test_kwargs = {
            'mode': 'sobel',
            'order': 1,
            'normalized': True,
        }
>       _test_function(
            kornia.filters.spatial_gradient,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function spatial_gradient at 0x7f0f15369120>
trace_args = (tensor([[[[0.3877, 0.0697, 0.4304, 0.6437],
          [0.1113, 0.4485, 0.1079, 0.7063],
          [0.0975, 0.1732, 0...., 0.4751, 0.8227, 0.6366],
          [0.7304, 0.3384, 0.2558, 0.6613],
          [0.6441, 0.1877, 0.5778, 0.9819]]]]),)
trace_kwargs = {'mode': 'sobel', 'normalized': True, 'order': 1}
test_args = (tensor([[[[0.6377, 0.1827, 0.7986, 0.0789],
          [0.1984, 0.7618, 0.1311, 0.0262],
          [0.0138, 0.2368, 0...., 0.1412, 0.9706, 0.3961],
          [0.3396, 0.5580, 0.7023, 0.7146],
          [0.2043, 0.3130, 0.1199, 0.0642]]]]),)
test_kwargs = {'mode': 'sobel', 'normalized': True, 'order': 1}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function spatial_gradient at 0x7f0f15369120>
trace_args = (tensor([[[[0.3877, 0.0697, 0.4304, 0.6437],
          [0.1113, 0.4485, 0.1079, 0.7063],
          [0.0975, 0.1732, 0...., 0.4751, 0.8227, 0.6366],
          [0.7304, 0.3384, 0.2558, 0.6613],
          [0.6441, 0.1877, 0.5778, 0.9819]]]]),)
trace_kwargs = {'mode': 'sobel', 'normalized': True, 'order': 1}
test_args = (tensor([[[[0.6377, 0.1827, 0.7986, 0.0789],
          [0.1984, 0.7618, 0.1311, 0.0262],
          [0.0138, 0.2368, 0...., 0.1412, 0.9706, 0.3961],
          [0.3396, 0.5580, 0.7023, 0.7146],
          [0.2043, 0.3130, 0.1199, 0.0642]]]]),)
test_kwargs = {'mode': 'sobel', 'normalized': True, 'order': 1}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function spatial_gradient at 0x7f0f15369120>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.sobel.spatial_gradient
____________________________________________________________________________ test_spatial_gradient3d[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_spatial_gradient3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 2, 4, 4),
        )
        trace_kwargs = {
            'mode': 'diff',
            'order': 1,
        }
        test_args = (
            torch.rand(5, 4, 2, 4, 4),
        )
        test_kwargs = {
            'mode': 'diff',
            'order': 1,
        }
>       _test_function(
            kornia.filters.spatial_gradient3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:418: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function spatial_gradient3d at 0x7f0f153691b0>
trace_args = (tensor([[[[[8.5324e-01, 9.6481e-01, 8.8053e-01, 1.3191e-01],
           [2.1628e-01, 6.2600e-01, 8.0563e-01, 1.1245e-...   [3.0896e-01, 2.6792e-03, 4.5566e-01, 5.1792e-01],
           [4.2258e-02, 9.6176e-01, 8.4309e-01, 6.9470e-01]]]]]),)
trace_kwargs = {'mode': 'diff', 'order': 1}
test_args = (tensor([[[[[1.4061e-01, 3.0129e-01, 9.4237e-01, 3.9093e-01],
           [7.6335e-01, 8.9759e-01, 3.1035e-01, 2.8843e-...   [7.8135e-01, 5.0566e-01, 1.1212e-01, 6.5148e-01],
           [9.1627e-01, 6.9736e-03, 3.8584e-01, 4.2363e-01]]]]]),)
test_kwargs = {'mode': 'diff', 'order': 1}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function spatial_gradient3d at 0x7f0f153691b0>
trace_args = (tensor([[[[[8.5324e-01, 9.6481e-01, 8.8053e-01, 1.3191e-01],
           [2.1628e-01, 6.2600e-01, 8.0563e-01, 1.1245e-...   [3.0896e-01, 2.6792e-03, 4.5566e-01, 5.1792e-01],
           [4.2258e-02, 9.6176e-01, 8.4309e-01, 6.9470e-01]]]]]),)
trace_kwargs = {'mode': 'diff', 'order': 1}
test_args = (tensor([[[[[1.4061e-01, 3.0129e-01, 9.4237e-01, 3.9093e-01],
           [7.6335e-01, 8.9759e-01, 3.1035e-01, 2.8843e-...   [7.8135e-01, 5.0566e-01, 1.1212e-01, 6.5148e-01],
           [9.1627e-01, 6.9736e-03, 3.8584e-01, 4.2363e-01]]]]]),)
test_kwargs = {'mode': 'diff', 'order': 1}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function spatial_gradient3d at 0x7f0f153691b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.sobel.spatial_gradient3d
_________________________________________________________________________________ test_filter2d[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_filter2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 5, 5),
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {'padding': 'same'}
        test_args = (
            torch.rand(2, 1, 5, 5),
            torch.rand(1, 3, 3),
        )
        test_kwargs = {'padding': 'same'}
>       _test_function(
            kornia.filters.filter2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function filter2d at 0x7f0f1535f9a0>
trace_args = (tensor([[[[0.5054, 0.4309, 0.0328, 0.1532, 0.5758],
          [0.7003, 0.9771, 0.1632, 0.6054, 0.5099],
          [0.....2728]]]]), tensor([[[0.0959, 0.5195, 0.3131],
         [0.5449, 0.5545, 0.5555],
         [0.6819, 0.0565, 0.5548]]]))
trace_kwargs = {'padding': 'same'}
test_args = (tensor([[[[0.0566, 0.9467, 0.1921, 0.9629, 0.7424],
          [0.1670, 0.5405, 0.0412, 0.1078, 0.0959],
          [0.....2437]]]]), tensor([[[0.5203, 0.2907, 0.8998],
         [0.0102, 0.7985, 0.7907],
         [0.6107, 0.4683, 0.2918]]]))
test_kwargs = {'padding': 'same'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function filter2d at 0x7f0f1535f9a0>
trace_args = (tensor([[[[0.5054, 0.4309, 0.0328, 0.1532, 0.5758],
          [0.7003, 0.9771, 0.1632, 0.6054, 0.5099],
          [0.....2728]]]]), tensor([[[0.0959, 0.5195, 0.3131],
         [0.5449, 0.5545, 0.5555],
         [0.6819, 0.0565, 0.5548]]]))
trace_kwargs = {'padding': 'same'}
test_args = (tensor([[[[0.0566, 0.9467, 0.1921, 0.9629, 0.7424],
          [0.1670, 0.5405, 0.0412, 0.1078, 0.0959],
          [0.....2437]]]]), tensor([[[0.5203, 0.2907, 0.8998],
         [0.0102, 0.7985, 0.7907],
         [0.6107, 0.4683, 0.2918]]]))
test_kwargs = {'padding': 'same'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function filter2d at 0x7f0f1535f9a0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.filter.filter2d
____________________________________________________________________________ test_filter2d_separable[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_filter2d_separable(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 5, 5),
            torch.rand(1, 3),
            torch.rand(1, 3),
        )
        trace_kwargs = {'padding': 'same'}
        test_args = (
            torch.rand(2, 1, 5, 5),
            torch.rand(1, 3),
            torch.rand(1, 3),
        )
        test_kwargs = {'padding': 'same'}
>       _test_function(
            kornia.filters.filter2d_separable,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:468: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function filter2d_separable at 0x7f0f1535fa30>
trace_args = (tensor([[[[0.5446, 0.3919, 0.0443, 0.1571, 0.5319],
          [0.2962, 0.7377, 0.4500, 0.9154, 0.9474],
          [0....  [0.3712, 0.1113, 0.1025, 0.1639, 0.4696]]]]), tensor([[0.4342, 0.3784, 0.0516]]), tensor([[0.2490, 0.0277, 0.6746]]))
trace_kwargs = {'padding': 'same'}
test_args = (tensor([[[[0.2888, 0.8578, 0.0600, 0.8688, 0.0765],
          [0.4406, 0.7222, 0.9444, 0.7336, 0.6954],
          [0....  [0.9300, 0.5189, 0.9302, 0.5854, 0.6379]]]]), tensor([[0.2865, 0.3685, 0.0063]]), tensor([[0.5582, 0.9538, 0.6877]]))
test_kwargs = {'padding': 'same'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function filter2d_separable at 0x7f0f1535fa30>
trace_args = (tensor([[[[0.5446, 0.3919, 0.0443, 0.1571, 0.5319],
          [0.2962, 0.7377, 0.4500, 0.9154, 0.9474],
          [0....  [0.3712, 0.1113, 0.1025, 0.1639, 0.4696]]]]), tensor([[0.4342, 0.3784, 0.0516]]), tensor([[0.2490, 0.0277, 0.6746]]))
trace_kwargs = {'padding': 'same'}
test_args = (tensor([[[[0.2888, 0.8578, 0.0600, 0.8688, 0.0765],
          [0.4406, 0.7222, 0.9444, 0.7336, 0.6954],
          [0....  [0.9300, 0.5189, 0.9302, 0.5854, 0.6379]]]]), tensor([[0.2865, 0.3685, 0.0063]]), tensor([[0.5582, 0.9538, 0.6877]]))
test_kwargs = {'padding': 'same'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function filter2d_separable at 0x7f0f1535fa30>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.filter.filter2d_separable
_________________________________________________________________________________ test_filter3d[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_filter3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 5, 5, 5),
            torch.rand(1, 3, 3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2, 1, 5, 5, 5),
            torch.rand(1, 3, 3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.filters.filter3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function filter3d at 0x7f0f1535fac0>
trace_args = (tensor([[[[[0.9340, 0.6395, 0.7937, 0.1249, 0.4765],
           [0.0805, 0.2243, 0.1226, 0.5922, 0.9567],
           ...940]],

         [[0.4068, 0.6187, 0.1031],
          [0.6138, 0.1946, 0.6686],
          [0.1479, 0.8402, 0.8831]]]]))
trace_kwargs = {}
test_args = (tensor([[[[[6.2682e-02, 1.4030e-01, 5.1726e-01, 1.2416e-01, 8.2966e-01],
           [6.5822e-01, 3.5904e-01, 1.8011e-...037]],

         [[0.7893, 0.9093, 0.9144],
          [0.0956, 0.4531, 0.1057],
          [0.4155, 0.6288, 0.0735]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function filter3d at 0x7f0f1535fac0>
trace_args = (tensor([[[[[0.9340, 0.6395, 0.7937, 0.1249, 0.4765],
           [0.0805, 0.2243, 0.1226, 0.5922, 0.9567],
           ...940]],

         [[0.4068, 0.6187, 0.1031],
          [0.6138, 0.1946, 0.6686],
          [0.1479, 0.8402, 0.8831]]]]))
trace_kwargs = {}
test_args = (tensor([[[[[6.2682e-02, 1.4030e-01, 5.1726e-01, 1.2416e-01, 8.2966e-01],
           [6.5822e-01, 3.5904e-01, 1.8011e-...037]],

         [[0.7893, 0.9093, 0.9144],
          [0.0956, 0.4531, 0.1057],
          [0.4155, 0.6288, 0.0735]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function filter3d at 0x7f0f1535fac0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.filter.filter3d
___________________________________________________________________________ test_get_gaussian_kernel1d[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_gaussian_kernel1d(target_framework, mode, backend_compile):
        trace_args = (3, 2.5)
        trace_kwargs = {}
        test_args = (5, 1.5)
        test_kwargs = {}
>       _test_function(
            kornia.filters.get_gaussian_kernel1d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:510: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_gaussian_kernel1d at 0x7f0f1535e440>, trace_args = (3, 2.5), trace_kwargs = {}, test_args = (5, 1.5), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_gaussian_kernel1d at 0x7f0f1535e440>, trace_args = (3, 2.5), trace_kwargs = {}, test_args = (5, 1.5), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_gaussian_kernel1d at 0x7f0f1535e440>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels.get_gaussian_kernel1d
_________________________________________________________________________ test_get_gaussian_erf_kernel1d[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_gaussian_erf_kernel1d(target_framework, mode, backend_compile):
        trace_args = (3, 2.5)
        trace_kwargs = {}
        test_args = (5, 1.5)
        test_kwargs = {}
>       _test_function(
            kornia.filters.get_gaussian_erf_kernel1d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_gaussian_erf_kernel1d at 0x7f0f1535e560>, trace_args = (3, 2.5), trace_kwargs = {}, test_args = (5, 1.5), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_gaussian_erf_kernel1d at 0x7f0f1535e560>, trace_args = (3, 2.5), trace_kwargs = {}, test_args = (5, 1.5), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_gaussian_erf_kernel1d at 0x7f0f1535e560>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels.get_gaussian_erf_kernel1d
______________________________________________________________________ test_get_gaussian_discrete_kernel1d[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_gaussian_discrete_kernel1d(target_framework, mode, backend_compile):
        trace_args = (3, 2.5)
        trace_kwargs = {}
        test_args = (5, 1.5)
        test_kwargs = {}
>       _test_function(
            kornia.filters.get_gaussian_discrete_kernel1d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:546: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_gaussian_discrete_kernel1d at 0x7f0f1535e4d0>, trace_args = (3, 2.5), trace_kwargs = {}, test_args = (5, 1.5), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_gaussian_discrete_kernel1d at 0x7f0f1535e4d0>, trace_args = (3, 2.5), trace_kwargs = {}, test_args = (5, 1.5), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_gaussian_discrete_kernel1d at 0x7f0f1535e4d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels.get_gaussian_discrete_kernel1d
___________________________________________________________________________ test_get_gaussian_kernel2d[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_gaussian_kernel2d(target_framework, mode, backend_compile):
        trace_args = ((5, 5), (1.5, 1.5))
        trace_kwargs = {}
        test_args = ((3, 5), (1.5, 1.5))
        test_kwargs = {}
>       _test_function(
            kornia.filters.get_gaussian_kernel2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_gaussian_kernel2d at 0x7f0f1535e5f0>, trace_args = ((5, 5), (1.5, 1.5)), trace_kwargs = {}, test_args = ((3, 5), (1.5, 1.5)), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_gaussian_kernel2d at 0x7f0f1535e5f0>, trace_args = ((5, 5), (1.5, 1.5)), trace_kwargs = {}, test_args = ((3, 5), (1.5, 1.5)), test_kwargs = {}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_gaussian_kernel2d at 0x7f0f1535e5f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels.get_gaussian_kernel2d
___________________________________________________________________________ test_get_hanning_kernel1d[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_hanning_kernel1d(target_framework, mode, backend_compile):
        trace_args = (4,)
        trace_kwargs = {}
        test_args = (8,)
        test_kwargs = {}
>       _test_function(
            kornia.filters.get_hanning_kernel1d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:582: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_hanning_kernel1d at 0x7f0f1535ea70>, trace_args = (4,), trace_kwargs = {}, test_args = (8,), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_hanning_kernel1d at 0x7f0f1535ea70>, trace_args = (4,), trace_kwargs = {}, test_args = (8,), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_hanning_kernel1d at 0x7f0f1535ea70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels.get_hanning_kernel1d
___________________________________________________________________________ test_get_hanning_kernel2d[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_hanning_kernel2d(target_framework, mode, backend_compile):
        trace_args = ((4, 4),)
        trace_kwargs = {}
        test_args = ((8, 8),)
        test_kwargs = {}
>       _test_function(
            kornia.filters.get_hanning_kernel2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:600: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_hanning_kernel2d at 0x7f0f1535eb00>, trace_args = ((4, 4),), trace_kwargs = {}, test_args = ((8, 8),), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_hanning_kernel2d at 0x7f0f1535eb00>, trace_args = ((4, 4),), trace_kwargs = {}, test_args = ((8, 8),), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_hanning_kernel2d at 0x7f0f1535eb00>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels.get_hanning_kernel2d
__________________________________________________________________________ test_get_laplacian_kernel1d[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_laplacian_kernel1d(target_framework, mode, backend_compile):
        trace_args = (3,)
        trace_kwargs = {}
        test_args = (5,)
        test_kwargs = {}
>       _test_function(
            kornia.filters.get_laplacian_kernel1d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:618: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_laplacian_kernel1d at 0x7f0f1535e710>, trace_args = (3,), trace_kwargs = {}, test_args = (5,), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_laplacian_kernel1d at 0x7f0f1535e710>, trace_args = (3,), trace_kwargs = {}, test_args = (5,), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_laplacian_kernel1d at 0x7f0f1535e710>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels.get_laplacian_kernel1d
__________________________________________________________________________ test_get_laplacian_kernel2d[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_laplacian_kernel2d(target_framework, mode, backend_compile):
        trace_args = (3,)
        trace_kwargs = {}
        test_args = (5,)
        test_kwargs = {}
>       _test_function(
            kornia.filters.get_laplacian_kernel2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:636: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_laplacian_kernel2d at 0x7f0f1535e7a0>, trace_args = (3,), trace_kwargs = {}, test_args = (5,), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_laplacian_kernel2d at 0x7f0f1535e7a0>, trace_args = (3,), trace_kwargs = {}, test_args = (5,), test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001
deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_laplacian_kernel2d at 0x7f0f1535e7a0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels.get_laplacian_kernel2d
____________________________________________________________________________ test_get_motion_kernel2d[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_motion_kernel2d(target_framework, mode, backend_compile):
        trace_args = (5, 0.0)
        trace_kwargs = {'direction': 0.0, 'mode': 'nearest'}
        test_args = (3, 215.0)
        test_kwargs = {'direction': -0.5, 'mode': 'nearest'}
>       _test_function(
            kornia.filters.get_motion_kernel2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_filters.py:654: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_motion_kernel2d at 0x7f0f1536b010>, trace_args = (5, 0.0), trace_kwargs = {'direction': 0.0, 'mode': 'nearest'}, test_args = (3, 215.0)
test_kwargs = {'direction': -0.5, 'mode': 'nearest'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_motion_kernel2d at 0x7f0f1536b010>, trace_args = (5, 0.0), trace_kwargs = {'direction': 0.0, 'mode': 'nearest'}, test_args = (3, 215.0)
test_kwargs = {'direction': -0.5, 'mode': 'nearest'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_motion_kernel2d at 0x7f0f1536b010>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.kernels_geometry.get_motion_kernel2d
_________________________________________________________________________________ test_Laplacian[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Laplacian(target_framework, mode, backend_compile):
        print("kornia.filters.Laplacian")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledLaplacian = ivy.transpile(kornia.filters.Laplacian, source="torch", target=target_framework)

kornia/test_filters.py:673: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.laplacian.Laplacian'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.Laplacian
___________________________________________________________________________________ test_Sobel[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Sobel(target_framework, mode, backend_compile):
        print("kornia.filters.Sobel")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSobel = ivy.transpile(kornia.filters.Sobel, source="torch", target=target_framework)

kornia/test_filters.py:690: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.sobel.Sobel'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.Sobel
___________________________________________________________________________________ test_Canny[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Canny(target_framework, mode, backend_compile):
        print("kornia.filters.Canny")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledCanny = ivy.transpile(kornia.filters.Canny, source="torch", target=target_framework)

kornia/test_filters.py:707: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.canny.Canny'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.Canny
__________________________________________________________________________________ test_DexiNed[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_DexiNed(target_framework, mode, backend_compile):
        print("kornia.filters.DexiNed")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledDexiNed = ivy.transpile(kornia.filters.DexiNed, source="torch", target=target_framework)

kornia/test_filters.py:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.dexined.DexiNed'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.DexiNed
_______________________________________________________________________________ test_BilateralBlur[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_BilateralBlur(target_framework, mode, backend_compile):
        print("kornia.filters.BilateralBlur")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledBilateralBlur = ivy.transpile(kornia.filters.BilateralBlur, source="torch", target=target_framework)

kornia/test_filters.py:776: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.bilateral.BilateralBlur'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.BilateralBlur
_______________________________________________________________________________ test_MaxBlurPool2D[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_MaxBlurPool2D(target_framework, mode, backend_compile):
        print("kornia.filters.MaxBlurPool2D")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledMaxBlurPool2D = ivy.transpile(kornia.filters.MaxBlurPool2D, source="torch", target=target_framework)

kornia/test_filters.py:827: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.blur_pool.MaxBlurPool2D'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.MaxBlurPool2D
________________________________________________________________________________ test_MedianBlur[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_MedianBlur(target_framework, mode, backend_compile):
        print("kornia.filters.MedianBlur")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledMedianBlur = ivy.transpile(kornia.filters.MedianBlur, source="torch", target=target_framework)

kornia/test_filters.py:844: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.median.MedianBlur'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.MedianBlur
______________________________________________________________________________ test_GaussianBlur2d[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_GaussianBlur2d(target_framework, mode, backend_compile):
        print("kornia.filters.GaussianBlur2d")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledGaussianBlur2d = ivy.transpile(kornia.filters.GaussianBlur2d, source="torch", target=target_framework)

kornia/test_filters.py:861: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.gaussian.GaussianBlur2d'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.GaussianBlur2d
________________________________________________________________________________ test_GuidedBlur[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_GuidedBlur(target_framework, mode, backend_compile):
        print("kornia.filters.GuidedBlur")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledGuidedBlur = ivy.transpile(kornia.filters.GuidedBlur, source="torch", target=target_framework)

kornia/test_filters.py:878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.guided.GuidedBlur'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.GuidedBlur
____________________________________________________________________________ test_JointBilateralBlur[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_JointBilateralBlur(target_framework, mode, backend_compile):
        print("kornia.filters.JointBilateralBlur")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledJointBilateralBlur = ivy.transpile(kornia.filters.JointBilateralBlur, source="torch", target=target_framework)

kornia/test_filters.py:897: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.bilateral.JointBilateralBlur'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.JointBilateralBlur
________________________________________________________________________________ test_MotionBlur[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_MotionBlur(target_framework, mode, backend_compile):
        print("kornia.filters.MotionBlur")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledMotionBlur = ivy.transpile(kornia.filters.MotionBlur, source="torch", target=target_framework)

kornia/test_filters.py:916: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.motion.MotionBlur'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.MotionBlur
________________________________________________________________________________ test_UnsharpMask[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_UnsharpMask(target_framework, mode, backend_compile):
        print("kornia.filters.UnsharpMask")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledUnsharpMask = ivy.transpile(kornia.filters.UnsharpMask, source="torch", target=target_framework)

kornia/test_filters.py:933: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.unsharp.UnsharpMask'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.UnsharpMask
__________________________________________________________________________________ test_InRange[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_InRange(target_framework, mode, backend_compile):
        print("kornia.filters.InRange")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledInRange = ivy.transpile(kornia.filters.InRange, source="torch", target=target_framework)

kornia/test_filters.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.filters.in_range.InRange'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.filters.InRange
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_filters.py::test_bilateral_blur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_filters.py::test_blur_pool2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_filters.py::test_box_blur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_filters.py::test_gaussian_blur2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
FAILED kornia/test_filters.py::test_guided_blur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_filters.py::test_joint_bilateral_blur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connect...
FAILED kornia/test_filters.py::test_max_blur_pool2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_filters.py::test_unsharp_mask[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_filters.py::test_canny[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY...
FAILED kornia/test_filters.py::test_laplacian[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_filters.py::test_sobel[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY...
FAILED kornia/test_filters.py::test_spatial_gradient[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/test_filters.py::test_spatial_gradient3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
FAILED kornia/test_filters.py::test_filter2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_filters.py::test_filter2d_separable[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
FAILED kornia/test_filters.py::test_filter3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_filters.py::test_get_gaussian_kernel1d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do...
FAILED kornia/test_filters.py::test_get_gaussian_erf_kernel1d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/test_filters.py::test_get_gaussian_discrete_kernel1d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/test_filters.py::test_get_gaussian_kernel2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do...
FAILED kornia/test_filters.py::test_get_hanning_kernel1d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_filters.py::test_get_hanning_kernel2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_filters.py::test_get_laplacian_kernel1d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you d...
FAILED kornia/test_filters.py::test_get_laplacian_kernel2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you d...
FAILED kornia/test_filters.py::test_get_motion_kernel2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do n...
FAILED kornia/test_filters.py::test_Laplacian[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_filters.py::test_Sobel[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY...
FAILED kornia/test_filters.py::test_Canny[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY...
FAILED kornia/test_filters.py::test_DexiNed[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_filters.py::test_BilateralBlur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/test_filters.py::test_MaxBlurPool2D[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/test_filters.py::test_MedianBlur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_filters.py::test_GaussianBlur2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_filters.py::test_GuidedBlur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_filters.py::test_JointBilateralBlur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
FAILED kornia/test_filters.py::test_MotionBlur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_filters.py::test_UnsharpMask[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_filters.py::test_InRange[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
=============================================================================== 38 failed, 6 passed in 248.87s (0:04:08) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 1 item

kornia/geometry/test_ransac.py F                                                                                                                                                                 [100%]

=============================================================================================== FAILURES ===============================================================================================
__________________________________________________________________________________ test_RANSAC[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RANSAC(target_framework, mode, backend_compile):
        print("kornia.geometry.ransac.RANSAC")
    
        if backend_compile:
            pytest.skip()
    
        # Initialize RANSAC with default parameters
        ransac = kornia.geometry.ransac.RANSAC(model_type='homography')
    
        # Transpile the RANSAC class to the target framework
        TranspiledRANSAC = ivy.transpile(kornia.geometry.ransac.RANSAC, source="torch", target=target_framework)
    
        # Prepare synthetic keypoints data for source and destination images
        kp1 = torch.tensor([[0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 3.0]], requires_grad=True)
        kp2 = torch.tensor([[0.0, 0.0], [1.1, 1.1], [2.0, 2.1], [3.0, 3.1]], requires_grad=True)
    
        transpiled_kp1 = _nest_torch_tensor_to_new_framework(kp1, target_framework)
        transpiled_kp2 = _nest_torch_tensor_to_new_framework(kp2, target_framework)
    
        # Run RANSAC on the original data
        torch_model, torch_inliers = ransac(kp1, kp2)
    
        # Run transpiled RANSAC on the transpiled data
        transpiled_ransac = TranspiledRANSAC(model_type='homography')
        transpiled_model, transpiled_inliers = transpiled_ransac(transpiled_kp1, transpiled_kp2)
    
        # Ensure that the estimated models are close to each other
        _to_numpy_and_shape_allclose(torch_model, transpiled_model)
    
        # Ensure that the inlier masks are consistent
        _to_numpy_and_shape_allclose(torch_inliers, transpiled_inliers)
    
        # Test RANSAC with custom parameters
        ransac_custom = kornia.geometry.ransac.RANSAC(model_type='homography', inl_th=1.5, max_iter=20, confidence=0.95)
>       TranspiledRANSACCustom = ivy.transpile(kornia.geometry.ransac.RANSAC, source="torch", target=target_framework)

kornia/geometry/test_ransac.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.ransac.RANSAC'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.ransac.RANSAC

Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RANSAC from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
                                                                                                                                 
Transpilation of RANSAC complete.
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_ransac.py::test_RANSAC[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
==================================================================================== 1 failed in 216.68s (0:03:36) =====================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 15 items

kornia/test_contrib.py FFFFFFFFF.FFF..                                                                                                                                                           [100%]

=============================================================================================== FAILURES ===============================================================================================
______________________________________________________________________________ test_compute_padding[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_compute_padding(target_framework, mode, backend_compile):
        trace_args = (
            (4, 3),
            (3, 3),
        )
        trace_kwargs = {}
        test_args = (
            (8, 5),
            (4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.contrib.compute_padding,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_contrib.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function compute_padding at 0x7f6bdea7bb50>, trace_args = ((4, 3), (3, 3)), trace_kwargs = {}, test_args = ((8, 5), (4, 4)), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function compute_padding at 0x7f6bdea7bb50>, trace_args = ((4, 3), (3, 3)), trace_kwargs = {}, test_args = ((8, 5), (4, 4)), test_kwargs = {}, target = 'tensorflow', backend_compile = False
tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function compute_padding at 0x7f6bdea7bb50>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.extract_patches.compute_padding
__________________________________________________________________________ test_extract_tensor_patches[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_extract_tensor_patches(target_framework, mode, backend_compile):
        trace_args = (torch.arange(16).view(1, 1, 4, 4),)
        trace_kwargs = {
            "window_size": (2, 2),
            "stride": (2, 2),
        }
        test_args = (torch.flip(torch.arange(32), (0,)).view(2, 1, 4, 4),)
        test_kwargs = {
            "window_size": (2, 2),
            "stride": (2, 2),
        }
>       _test_function(
            kornia.contrib.extract_tensor_patches,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_contrib.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function extract_tensor_patches at 0x7f6bdeaa8160>, trace_args = (tensor([[[[ 0,  1,  2,  3],
          [ 4,  5,  6,  7],
          [ 8,  9, 10, 11],
          [12, 13, 14, 15]]]]),)
trace_kwargs = {'stride': (2, 2), 'window_size': (2, 2)}
test_args = (tensor([[[[31, 30, 29, 28],
          [27, 26, 25, 24],
          [23, 22, 21, 20],
          [19, 18, 17, 16]]],


        [[[15, 14, 13, 12],
          [11, 10,  9,  8],
          [ 7,  6,  5,  4],
          [ 3,  2,  1,  0]]]]),)
test_kwargs = {'stride': (2, 2), 'window_size': (2, 2)}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function extract_tensor_patches at 0x7f6bdeaa8160>, trace_args = (tensor([[[[ 0,  1,  2,  3],
          [ 4,  5,  6,  7],
          [ 8,  9, 10, 11],
          [12, 13, 14, 15]]]]),)
trace_kwargs = {'stride': (2, 2), 'window_size': (2, 2)}
test_args = (tensor([[[[31, 30, 29, 28],
          [27, 26, 25, 24],
          [23, 22, 21, 20],
          [19, 18, 17, 16]]],


        [[[15, 14, 13, 12],
          [11, 10,  9,  8],
          [ 7,  6,  5,  4],
          [ 3,  2,  1,  0]]]]),)
test_kwargs = {'stride': (2, 2), 'window_size': (2, 2)}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function extract_tensor_patches at 0x7f6bdeaa8160>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.extract_patches.extract_tensor_patches
__________________________________________________________________________ test_combine_tensor_patches[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_combine_tensor_patches(target_framework, mode, backend_compile):
        trace_args = (
            kornia.contrib.extract_tensor_patches(
                torch.arange(16).view(1, 1, 4, 4),
                window_size=(2, 2),
                stride=(2, 2),
            ),
        )
        trace_kwargs = {
            "original_size": (4, 4),
            "window_size": (2, 2),
            "stride": (2, 2),
        }
        test_args = (
            kornia.contrib.extract_tensor_patches(
                torch.flip(torch.arange(32), (0,)).view(2, 1, 4, 4),
                window_size=(2, 2),
                stride=(2, 2),
            ),
        )
        test_kwargs = {
            "original_size": (4, 4),
            "window_size": (2, 2),
            "stride": (2, 2),
        }
>       _test_function(
            kornia.contrib.combine_tensor_patches,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_contrib.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function combine_tensor_patches at 0x7f6bdea7bf40>
trace_args = (tensor([[[[[ 0,  1],
           [ 4,  5]]],


         [[[ 2,  3],
           [ 6,  7]]],


         [[[ 8,  9],
           [12, 13]]],


         [[[10, 11],
           [14, 15]]]]]),)
trace_kwargs = {'original_size': (4, 4), 'stride': (2, 2), 'window_size': (2, 2)}
test_args = (tensor([[[[[31, 30],
           [27, 26]]],


         [[[29, 28],
           [25, 24]]],


         [[[23, 22],
    ...
           [ 9,  8]]],


         [[[ 7,  6],
           [ 3,  2]]],


         [[[ 5,  4],
           [ 1,  0]]]]]),)
test_kwargs = {'original_size': (4, 4), 'stride': (2, 2), 'window_size': (2, 2)}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function combine_tensor_patches at 0x7f6bdea7bf40>
trace_args = (tensor([[[[[ 0,  1],
           [ 4,  5]]],


         [[[ 2,  3],
           [ 6,  7]]],


         [[[ 8,  9],
           [12, 13]]],


         [[[10, 11],
           [14, 15]]]]]),)
trace_kwargs = {'original_size': (4, 4), 'stride': (2, 2), 'window_size': (2, 2)}
test_args = (tensor([[[[[31, 30],
           [27, 26]]],


         [[[29, 28],
           [25, 24]]],


         [[[23, 22],
    ...
           [ 9,  8]]],


         [[[ 7,  6],
           [ 3,  2]]],


         [[[ 5,  4],
           [ 1,  0]]]]]),)
test_kwargs = {'original_size': (4, 4), 'stride': (2, 2), 'window_size': (2, 2)}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function combine_tensor_patches at 0x7f6bdea7bf40>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.extract_patches.combine_tensor_patches
____________________________________________________________________________ test_distance_transform[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_distance_transform(target_framework, mode, backend_compile):
        trace_args = (torch.randn(1, 1, 5, 5),)
        trace_kwargs = {"kernel_size": 3, "h": 0.35}
        test_args = (torch.randn(5, 1, 5, 5),)
        test_kwargs = {"kernel_size": 3, "h": 0.5}
>       _test_function(
            kornia.contrib.distance_transform,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_contrib.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function distance_transform at 0x7f6bdea7b2e0>
trace_args = (tensor([[[[-1.1785, -1.3011, -2.2349,  0.8876, -2.2483],
          [-0.5877,  1.6279, -1.3705, -1.0817, -0.5616],
   ...
          [ 0.8910,  0.1441,  0.8894, -0.9889, -1.0569],
          [ 0.3381,  1.7464, -1.3152, -0.6011,  0.9466]]]]),)
trace_kwargs = {'h': 0.35, 'kernel_size': 3}
test_args = (tensor([[[[-1.3672, -0.3792, -1.4376,  0.7658, -1.4049],
          [-0.0594, -1.4515,  0.5377, -0.3894,  0.9540],
   ...
          [-0.5027,  0.8581, -1.4812,  0.6068, -0.4773],
          [ 1.0145,  1.1393,  0.9048,  0.2820, -0.5559]]]]),)
test_kwargs = {'h': 0.5, 'kernel_size': 3}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function distance_transform at 0x7f6bdea7b2e0>
trace_args = (tensor([[[[-1.1785, -1.3011, -2.2349,  0.8876, -2.2483],
          [-0.5877,  1.6279, -1.3705, -1.0817, -0.5616],
   ...
          [ 0.8910,  0.1441,  0.8894, -0.9889, -1.0569],
          [ 0.3381,  1.7464, -1.3152, -0.6011,  0.9466]]]]),)
trace_kwargs = {'h': 0.35, 'kernel_size': 3}
test_args = (tensor([[[[-1.3672, -0.3792, -1.4376,  0.7658, -1.4049],
          [-0.0594, -1.4515,  0.5377, -0.3894,  0.9540],
   ...
          [-0.5027,  0.8581, -1.4812,  0.6068, -0.4773],
          [ 1.0145,  1.1393,  0.9048,  0.2820, -0.5559]]]]),)
test_kwargs = {'h': 0.5, 'kernel_size': 3}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function distance_transform at 0x7f6bdea7b2e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.distance_transform.distance_transform
______________________________________________________________________________ test_diamond_square[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_diamond_square(target_framework, mode, backend_compile):
        trace_args = ((1, 1, 8, 8),)
        trace_kwargs = {
            "roughness": 0.5,
            "random_scale": 1.0,
            "normalize_range": (0.0, 1.0),
            "random_fn": torch.ones,
        }
        test_args = ((5, 1, 8, 8),)
        test_kwargs = {
            "roughness": 0.7,
            "random_scale": 0.9,
            "normalize_range": (-1.0, 1.0),
            "random_fn": torch.ones,
        }
>       _test_function(
            kornia.contrib.diamond_square,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_contrib.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function diamond_square at 0x7f6bdea7af80>, trace_args = ((1, 1, 8, 8),)
trace_kwargs = {'normalize_range': (0.0, 1.0), 'random_fn': <built-in method ones of type object at 0x7f6bf9e2e900>, 'random_scale': 1.0, 'roughness': 0.5}, test_args = ((5, 1, 8, 8),)
test_kwargs = {'normalize_range': (-1.0, 1.0), 'random_fn': <built-in method ones of type object at 0x7f6bf9e2e900>, 'random_scale': 0.9, 'roughness': 0.7}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function diamond_square at 0x7f6bdea7af80>, trace_args = ((1, 1, 8, 8),)
trace_kwargs = {'normalize_range': (0.0, 1.0), 'random_fn': <built-in method ones of type object at 0x7f6bf9e2e900>, 'random_scale': 1.0, 'roughness': 0.5}, test_args = ((5, 1, 8, 8),)
test_kwargs = {'normalize_range': (-1.0, 1.0), 'random_fn': <built-in method ones of type object at 0x7f6bf9e2e900>, 'random_scale': 0.9, 'roughness': 0.7}, target = 'tensorflow'
backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function diamond_square at 0x7f6bdea7af80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.diamond_square.diamond_square
_______________________________________________________________________________ test_EdgeDetector[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_EdgeDetector(target_framework, mode, backend_compile):
        print("kornia.contrib.EdgeDetector")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledEdgeDetector = ivy.transpile(kornia.contrib.EdgeDetector, source="torch", target=target_framework)

kornia/test_contrib.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.contrib.edge_detection.EdgeDetector'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.EdgeDetector
_______________________________________________________________________________ test_FaceDetector[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_FaceDetector(target_framework, mode, backend_compile):
        print("kornia.contrib.FaceDetector")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledFaceDetector = ivy.transpile(kornia.contrib.FaceDetector, source="torch", target=target_framework)

kornia/test_contrib.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.contrib.face_detection.FaceDetector'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.FaceDetector
_____________________________________________________________________________ test_VisionTransformer[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_VisionTransformer(target_framework, mode, backend_compile):
        print("kornia.contrib.VisionTransformer")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledVisionTransformer = ivy.transpile(kornia.contrib.VisionTransformer, source="torch", target=target_framework)

kornia/test_contrib.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.contrib.vit.VisionTransformer'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.VisionTransformer
__________________________________________________________________________________ test_KMeans[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_KMeans(target_framework, mode, backend_compile):
        print("kornia.contrib.KMeans")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledKMeans = ivy.transpile(kornia.contrib.KMeans, source="torch", target=target_framework)
    
        torch_kmeans = kornia.contrib.KMeans(3, None, 10e-4, 100, 0)
        transpiled_kmeans = TranspiledKMeans(3, None, 10e-4, 100, 0)
    
        torch_x1 = torch.rand((1000, 5))
        torch_x2 = torch.rand((10, 5))
        transpiled_x1 = _array_to_new_backend(torch_x1, target_framework)
        transpiled_x2 = _array_to_new_backend(torch_x2, target_framework)
    
        torch_kmeans.fit(torch_x1)
        torch_predictions = torch_kmeans.predict(torch_x2)
    
>       transpiled_kmeans.fit(transpiled_x1)

kornia/test_contrib.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Translated_Outputs.tensorflow_outputs.kornia.contrib.kmeans.tensorflow_KMeans object at 0x7f6bd8980ca0>
X = <tf.Tensor: shape=(1000, 5), dtype=float32, numpy=
array([[0.4962566 , 0.7682218 , 0.08847743, 0.13203049, 0.30742282]...5, 0.49248123, 0.4287302 ],
       [0.3786084 , 0.04217941, 0.28761953, 0.5166052 , 0.11317676]],
      dtype=float32)>

    def fit(self, X):
        from ..core.check import tensorflow_KORNIA_CHECK
        from ..core.check import tensorflow_KORNIA_CHECK_SHAPE
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_argmin_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_clone_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_squeeze_frnt_
        from ...ivy.functional.frontends.torch.indexing_slicing_joining_mutating_ops import (
            tensorflow_nonzero_frnt,
        )
        from ...ivy.functional.frontends.torch.indexing_slicing_joining_mutating_ops import (
            tensorflow_index_select_frnt,
        )
        from ...ivy.functional.frontends.torch.random_sampling import (
            tensorflow_randint_frnt,
        )
        from ...ivy.functional.frontends.torch.tensor import tensorflow_mean_frnt_
        from ...ivy.functional.frontends.torch.reduction_ops import tensorflow_sum_frnt
        from ...ivy.functional.frontends.torch.pointwise_ops import tensorflow_sqrt_frnt
    
        tensorflow_KORNIA_CHECK_SHAPE(X, ["N", "D"])
        if self._cluster_centers is None:
            self._cluster_centers = self._initialise_cluster_centers(
                X, self.num_clusters
            )
        else:
            tensorflow_KORNIA_CHECK(
                tensorflow_shape_frnt_(X)[1]
                == tensorflow_shape_frnt_(self._cluster_centers)[1],
                f"Dimensions at position 1 of X and cluster_centers do not match.                 {tensorflow_shape_frnt_(X)[1]} != {tensorflow_shape_frnt_(self._cluster_centers)[1]}",
            )
        current_centers = self._cluster_centers
        previous_centers: typing.Any = None
        iteration: typing.Any = 0
        while True:
            distance: typing.Any = self._pairwise_euclidean_distance(X, current_centers)
            cluster_assignment = tensorflow_argmin_frnt_(distance, -1)
            previous_centers = tensorflow_clone_frnt_(current_centers)
            for index in range(self.num_clusters):
                selected = tensorflow_squeeze_frnt_(
                    tensorflow_nonzero_frnt(cluster_assignment == index)
                )
                selected = tensorflow_index_select_frnt(X, 0, selected)
                if tensorflow_shape_frnt_(selected)[0] == 0:
                    selected = X[tensorflow_randint_frnt(len(X), (1,), device=X.device)]
>               current_centers[index] = tensorflow_mean_frnt_(selected, dim=0)
E               TypeError: 'tensorflow.python.framework.ops.EagerTensor' object does not support item assignment

Translated_Outputs/tensorflow_outputs/kornia/contrib/kmeans.py:143: TypeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.KMeans

Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KMeans from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                 
Transpilation of KMeans complete.
___________________________________________________________________________ test_CombineTensorPatches[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_CombineTensorPatches(target_framework, mode, backend_compile):
        print("kornia.contrib.CombineTensorPatches")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledCombineTensorPatches = ivy.transpile(kornia.contrib.CombineTensorPatches, source="torch", target=target_framework)

kornia/test_contrib.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.contrib.extract_patches.CombineTensorPatches'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.CombineTensorPatches
____________________________________________________________________________ test_ClassificationHead[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ClassificationHead(target_framework, mode, backend_compile):
        print("kornia.contrib.ClassificationHead")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledClassificationHead = ivy.transpile(kornia.contrib.ClassificationHead, source="torch", target=target_framework)

kornia/test_contrib.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.contrib.classification.ClassificationHead'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.ClassificationHead
_______________________________________________________________________________ test_ImageStitcher[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ImageStitcher(target_framework, mode, backend_compile):
        print("kornia.contrib.ImageStitcher")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledLoFTR = ivy.transpile(kornia.feature.LoFTR, source="torch", target=target_framework)

kornia/test_contrib.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.loftr.loftr.LoFTR'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.contrib.ImageStitcher
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_contrib.py::test_compute_padding[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
FAILED kornia/test_contrib.py::test_extract_tensor_patches[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you d...
FAILED kornia/test_contrib.py::test_combine_tensor_patches[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you d...
FAILED kornia/test_contrib.py::test_distance_transform[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
FAILED kornia/test_contrib.py::test_diamond_square[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_contrib.py::test_EdgeDetector[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_contrib.py::test_FaceDetector[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_contrib.py::test_VisionTransformer[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/test_contrib.py::test_KMeans[tensorflow-s2s-False] - TypeError: 'tensorflow.python.framework.ops.EagerTensor' object does not support item assignment
FAILED kornia/test_contrib.py::test_CombineTensorPatches[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_contrib.py::test_ClassificationHead[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_contrib.py::test_ImageStitcher[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
=============================================================================== 12 failed, 3 passed in 174.65s (0:02:54) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 7 items

kornia/test_morphology.py FFFFFFF                                                                                                                                                                [100%]

=============================================================================================== FAILURES ===============================================================================================
_________________________________________________________________________________ test_dilation[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_dilation(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.morphology.dilation,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_morphology.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dilation at 0x7fb509df6320>
trace_args = (tensor([[[[0.1578, 0.2696, 0.7071, 0.8537, 0.1250],
          [0.4070, 0.9522, 0.7931, 0.3324, 0.2051],
          [0....2, 0.0491]]]]), tensor([[0.9884, 0.4974, 0.5176],
        [0.4369, 0.9863, 0.2826],
        [0.1457, 0.1404, 0.9862]]))
trace_kwargs = {}
test_args = (tensor([[[[5.3138e-01, 6.2773e-01, 7.0532e-01, 4.5494e-02, 1.0771e-01],
          [9.3486e-01, 3.3651e-03, 5.1988e-01....1560e-02]]]]), tensor([[0.8611, 0.6251, 0.0735],
        [0.7041, 0.5137, 0.3470],
        [0.5962, 0.8910, 0.5981]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dilation at 0x7fb509df6320>
trace_args = (tensor([[[[0.1578, 0.2696, 0.7071, 0.8537, 0.1250],
          [0.4070, 0.9522, 0.7931, 0.3324, 0.2051],
          [0....2, 0.0491]]]]), tensor([[0.9884, 0.4974, 0.5176],
        [0.4369, 0.9863, 0.2826],
        [0.1457, 0.1404, 0.9862]]))
trace_kwargs = {}
test_args = (tensor([[[[5.3138e-01, 6.2773e-01, 7.0532e-01, 4.5494e-02, 1.0771e-01],
          [9.3486e-01, 3.3651e-03, 5.1988e-01....1560e-02]]]]), tensor([[0.8611, 0.6251, 0.0735],
        [0.7041, 0.5137, 0.3470],
        [0.5962, 0.8910, 0.5981]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0.9522, 0.9522, 0.9522, 0.8537, 0.8537],
          [0.9522, 0.9522, 0.9522, 0.9261, 0.8537],
          [0.9...48, 0.9048],
          [0.9183, 0.9183, 0.9048, 0.9048, 0.9048],
          [0.9183, 0.9183, 0.9048, 0.9048, 0.9048]]]])
transpiled_x = <tf.Tensor: shape=(1, 3, 5, 5), dtype=float32, numpy=
array([[[[0.15783232, 0.8537472 , 0.8537472 , 0.9521909 , 0.9521....51111966, 0.7691076 ],
         [0.9183347 , 0.9048012 , 0.9183347 , 0.9183347 , 0.0490641 ]]]],
      dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0.9521909 , 0.9521909 , 0.9521909 , 0.8537472 , 0.8537472 ],
         [0.9521909 , 0.9521909 , 0.9521909 , 0...0.9048012 , 0.9048012 ],
         [0.9183347 , 0.9183347 , 0.9048012 , 0.9048012 , 0.9048012 ]]]],
      dtype=float32)
y = array([[[[0.15783232, 0.8537472 , 0.8537472 , 0.9521909 , 0.9521909 ],
         [0.9260641 , 0.960066  , 0.960066  , 0...0.51111966, 0.7691076 ],
         [0.9183347 , 0.9048012 , 0.9183347 , 0.9183347 , 0.0490641 ]]]],
      dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.morphology.morphology.dilation

Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling dilation from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
                                                                                                                                      
Transpilation of dilation complete.
__________________________________________________________________________________ test_erosion[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_erosion(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.morphology.erosion,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_morphology.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function erosion at 0x7fb509df63b0>
trace_args = (tensor([[[[0.1705, 0.9733, 0.9951, 0.5858, 0.5870],
          [0.7948, 0.4306, 0.7611, 0.1560, 0.7258],
          [0.... 0.8263, 0.8993],
        [0.1258, 0.7765, 0.2325, 0.9205, 0.9667],
        [0.5831, 0.8506, 0.0865, 0.2402, 0.0996]]))
trace_kwargs = {}
test_args = (tensor([[[[0.0878, 0.1808, 0.8383, 0.8813, 0.0683],
          [0.6773, 0.1374, 0.8922, 0.9558, 0.0140],
          [0.... 0.9813, 0.9005],
        [0.6036, 0.8357, 0.9277, 0.0237, 0.8384],
        [0.2818, 0.6583, 0.0362, 0.2074, 0.5329]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function erosion at 0x7fb509df63b0>
trace_args = (tensor([[[[0.1705, 0.9733, 0.9951, 0.5858, 0.5870],
          [0.7948, 0.4306, 0.7611, 0.1560, 0.7258],
          [0.... 0.8263, 0.8993],
        [0.1258, 0.7765, 0.2325, 0.9205, 0.9667],
        [0.5831, 0.8506, 0.0865, 0.2402, 0.0996]]))
trace_kwargs = {}
test_args = (tensor([[[[0.0878, 0.1808, 0.8383, 0.8813, 0.0683],
          [0.6773, 0.1374, 0.8922, 0.9558, 0.0140],
          [0.... 0.9813, 0.9005],
        [0.6036, 0.8357, 0.9277, 0.0237, 0.8384],
        [0.2818, 0.6583, 0.0362, 0.2074, 0.5329]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0.1705, 0.1560, 0.1560, 0.1560, 0.1560],
          [0.1705, 0.1560, 0.1560, 0.1560, 0.1560],
          [0.1...67, 0.0867],
          [0.1118, 0.0867, 0.0867, 0.0867, 0.0867],
          [0.1342, 0.0867, 0.0867, 0.0867, 0.0867]]]])
transpiled_x = <tf.Tensor: shape=(1, 3, 5, 5), dtype=float32, numpy=
array([[[[0.17054302, 0.17054302, 0.15601748, 0.15601748, 0.1560....13418096, 0.13418096],
         [0.08665758, 0.08665758, 0.13418096, 0.24564254, 0.24564254]]]],
      dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0.17054302, 0.15601748, 0.15601748, 0.15601748, 0.15601748],
         [0.17054302, 0.15601748, 0.15601748, 0...0.08665758, 0.08665758],
         [0.13418096, 0.08665758, 0.08665758, 0.08665758, 0.08665758]]]],
      dtype=float32)
y = array([[[[0.17054302, 0.17054302, 0.15601748, 0.15601748, 0.15601748],
         [0.15601748, 0.15601748, 0.15601748, 0...0.13418096, 0.13418096],
         [0.08665758, 0.08665758, 0.13418096, 0.24564254, 0.24564254]]]],
      dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.morphology.morphology.erosion

Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling erosion from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
                                                                                                                                     
Transpilation of erosion complete.
__________________________________________________________________________________ test_opening[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_opening(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.morphology.opening,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_morphology.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function opening at 0x7fb509df6440>
trace_args = (tensor([[[[0.3675, 0.6310, 0.3657, 0.8824, 0.7462],
          [0.5420, 0.3814, 0.8419, 0.7391, 0.6887],
          [0....7, 0.9278]]]]), tensor([[0.6103, 0.0754, 0.0090],
        [0.1236, 0.9649, 0.0440],
        [0.0429, 0.3782, 0.6027]]))
trace_kwargs = {}
test_args = (tensor([[[[3.1116e-01, 7.2258e-01, 8.5189e-01, 8.1294e-02, 7.5180e-01],
          [7.6711e-01, 5.6468e-01, 5.7274e-01....5618e-02]]]]), tensor([[0.2990, 0.5519, 0.0710],
        [0.5781, 0.9935, 0.4235],
        [0.4332, 0.7521, 0.2487]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function opening at 0x7fb509df6440>
trace_args = (tensor([[[[0.3675, 0.6310, 0.3657, 0.8824, 0.7462],
          [0.5420, 0.3814, 0.8419, 0.7391, 0.6887],
          [0....7, 0.9278]]]]), tensor([[0.6103, 0.0754, 0.0090],
        [0.1236, 0.9649, 0.0440],
        [0.0429, 0.3782, 0.6027]]))
trace_kwargs = {}
test_args = (tensor([[[[3.1116e-01, 7.2258e-01, 8.5189e-01, 8.1294e-02, 7.5180e-01],
          [7.6711e-01, 5.6468e-01, 5.7274e-01....5618e-02]]]]), tensor([[0.2990, 0.5519, 0.0710],
        [0.5781, 0.9935, 0.4235],
        [0.4332, 0.7521, 0.2487]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0.3675, 0.3675, 0.3657, 0.6887, 0.6887],
          [0.3675, 0.3675, 0.3657, 0.6887, 0.6887],
          [0.2...04, 0.3704],
          [0.0531, 0.1894, 0.1894, 0.6287, 0.6287],
          [0.0531, 0.0531, 0.0522, 0.6287, 0.6287]]]])
transpiled_x = <tf.Tensor: shape=(1, 3, 5, 5), dtype=float32, numpy=
array([[[[0.36746943, 0.381428  , 0.381428  , 0.36746943, 0.3814....36041826, 0.36041826],
         [0.26737607, 0.92779225, 0.92779225, 0.05312681, 0.92779225]]]],
      dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0.36746943, 0.36746943, 0.3657142 , 0.6886538 , 0.6886538 ],
         [0.36746943, 0.36746943, 0.3657142 , 0...0.62865174, 0.62865174],
         [0.05312681, 0.05312681, 0.05223906, 0.62865174, 0.62865174]]]],
      dtype=float32)
y = array([[[[0.36746943, 0.381428  , 0.381428  , 0.36746943, 0.381428  ],
         [0.381428  , 0.381428  , 0.381428  , 0...0.36041826, 0.36041826],
         [0.26737607, 0.92779225, 0.92779225, 0.05312681, 0.92779225]]]],
      dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.morphology.morphology.opening

Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling opening from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
                                                                                                                                     
Transpilation of opening complete.
__________________________________________________________________________________ test_closing[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_closing(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.morphology.closing,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_morphology.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function closing at 0x7fb509df64d0>
trace_args = (tensor([[[[0.6358, 0.5637, 0.7110, 0.2578, 0.5840],
          [0.5756, 0.9929, 0.0796, 0.8374, 0.7912],
          [0....3, 0.3787]]]]), tensor([[0.1612, 0.7910, 0.5803],
        [0.8596, 0.8217, 0.1162],
        [0.2455, 0.6473, 0.3478]]))
trace_kwargs = {}
test_args = (tensor([[[[0.5293, 0.4031, 0.5911, 0.2332, 0.8262],
          [0.3905, 0.3736, 0.2148, 0.3454, 0.7825],
          [0....2, 0.5005]]]]), tensor([[0.8986, 0.6504, 0.0256],
        [0.7963, 0.8610, 0.8958],
        [0.9593, 0.9184, 0.7246]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function closing at 0x7fb509df64d0>
trace_args = (tensor([[[[0.6358, 0.5637, 0.7110, 0.2578, 0.5840],
          [0.5756, 0.9929, 0.0796, 0.8374, 0.7912],
          [0....3, 0.3787]]]]), tensor([[0.1612, 0.7910, 0.5803],
        [0.8596, 0.8217, 0.1162],
        [0.2455, 0.6473, 0.3478]]))
trace_kwargs = {}
test_args = (tensor([[[[0.5293, 0.4031, 0.5911, 0.2332, 0.8262],
          [0.3905, 0.3736, 0.2148, 0.3454, 0.7825],
          [0....2, 0.5005]]]]), tensor([[0.8986, 0.6504, 0.0256],
        [0.7963, 0.8610, 0.8958],
        [0.9593, 0.9184, 0.7246]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0.9929, 0.9929, 0.8374, 0.8374, 0.8374],
          [0.9929, 0.9929, 0.8374, 0.8374, 0.8374],
          [0.9...13, 0.5913],
          [0.4135, 0.4135, 0.5268, 0.5268, 0.5913],
          [0.4135, 0.4135, 0.5268, 0.5268, 0.5913]]]])
transpiled_x = <tf.Tensor: shape=(1, 3, 5, 5), dtype=float32, numpy=
array([[[[0.6357922 , 0.7110032 , 0.6357922 , 0.6357922 , 0.7110....5913297 , 0.5913297 ],
         [0.4933877 , 0.37871838, 0.37871838, 0.4933877 , 0.37871838]]]],
      dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0.9929395 , 0.9929395 , 0.8373976 , 0.8373976 , 0.8373976 ],
         [0.9929395 , 0.9929395 , 0.8373976 , 0...0.5267907 , 0.5913297 ],
         [0.41347057, 0.41347057, 0.5267907 , 0.5267907 , 0.5913297 ]]]],
      dtype=float32)
y = array([[[[0.6357922 , 0.7110032 , 0.6357922 , 0.6357922 , 0.7110032 ],
         [0.7728267 , 0.7728267 , 0.9434218 , 0...0.5913297 , 0.5913297 ],
         [0.4933877 , 0.37871838, 0.37871838, 0.4933877 , 0.37871838]]]],
      dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.morphology.morphology.closing

Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling closing from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
                                                                                                                                     
Transpilation of closing complete.
_________________________________________________________________________________ test_gradient[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_gradient(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.morphology.gradient,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_morphology.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function gradient at 0x7fb509df6560>
trace_args = (tensor([[[[0.4848, 0.3787, 0.8940, 0.2710, 0.9763],
          [0.4442, 0.8517, 0.7430, 0.1605, 0.6873],
          [0....7, 0.8848]]]]), tensor([[0.9845, 0.0748, 0.8648],
        [0.2874, 0.5274, 0.9092],
        [0.4551, 0.2176, 0.0165]]))
trace_kwargs = {}
test_args = (tensor([[[[0.4635, 0.7684, 0.0636, 0.6836, 0.8789],
          [0.0550, 0.7946, 0.2969, 0.9005, 0.9822],
          [0....5, 0.7514]]]]), tensor([[0.6773, 0.5178, 0.8275],
        [0.3179, 0.1117, 0.0780],
        [0.7237, 0.1303, 0.7230]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function gradient at 0x7fb509df6560>
trace_args = (tensor([[[[0.4848, 0.3787, 0.8940, 0.2710, 0.9763],
          [0.4442, 0.8517, 0.7430, 0.1605, 0.6873],
          [0....7, 0.8848]]]]), tensor([[0.9845, 0.0748, 0.8648],
        [0.2874, 0.5274, 0.9092],
        [0.4551, 0.2176, 0.0165]]))
trace_kwargs = {}
test_args = (tensor([[[[0.4635, 0.7684, 0.0636, 0.6836, 0.8789],
          [0.0550, 0.7946, 0.2969, 0.9005, 0.9822],
          [0....5, 0.7514]]]]), tensor([[0.6773, 0.5178, 0.8275],
        [0.3179, 0.1117, 0.0780],
        [0.7237, 0.1303, 0.7230]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0.4730, 0.5153, 0.7334, 0.8158, 0.8158],
          [0.7836, 0.8259, 0.7334, 0.8158, 0.8158],
          [0.7...25, 0.7725],
          [0.8197, 0.8197, 0.8999, 0.8034, 0.8034],
          [0.6200, 0.6322, 0.6376, 0.7285, 0.7285]]]])
transpiled_x = <tf.Tensor: shape=(1, 3, 5, 5), dtype=float32, numpy=
array([[[[0.        , 0.70533526, 0.70533526, 0.62297875, 0.8157....9090495 , 0.8999458 ],
         [0.6376304 , 0.72853565, 0.36998147, 0.2668143 , 0.        ]]]],
      dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0.47302544, 0.5152662 , 0.7334283 , 0.8157848 , 0.8157848 ],
         [0.7836332 , 0.8258739 , 0.7334283 , 0...0.80343664, 0.80343664],
         [0.6199878 , 0.6322497 , 0.6376304 , 0.72853565, 0.72853565]]]],
      dtype=float32)
y = array([[[[0.        , 0.70533526, 0.70533526, 0.62297875, 0.8157848 ],
         [0.81570375, 0.798354  , 0.7719885 , 0...0.9090495 , 0.8999458 ],
         [0.6376304 , 0.72853565, 0.36998147, 0.2668143 , 0.        ]]]],
      dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.morphology.morphology.gradient

Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling gradient from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
                                                                                                                                      
Transpilation of gradient complete.
__________________________________________________________________________________ test_top_hat[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_top_hat(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.morphology.top_hat,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_morphology.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function top_hat at 0x7fb509df65f0>
trace_args = (tensor([[[[0.3828, 0.9641, 0.5340, 0.5464, 0.9253],
          [0.1679, 0.3698, 0.4640, 0.3230, 0.1097],
          [0....2, 0.3803]]]]), tensor([[0.0891, 0.3098, 0.2478],
        [0.5861, 0.4022, 0.8898],
        [0.4687, 0.1744, 0.6522]]))
trace_kwargs = {}
test_args = (tensor([[[[0.2562, 0.1892, 0.0922, 0.3083, 0.0404],
          [0.7289, 0.5085, 0.0398, 0.9297, 0.9394],
          [0....7, 0.1038]]]]), tensor([[0.0797, 0.7249, 0.6895],
        [0.3134, 0.8248, 0.4523],
        [0.8996, 0.6093, 0.6661]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function top_hat at 0x7fb509df65f0>
trace_args = (tensor([[[[0.3828, 0.9641, 0.5340, 0.5464, 0.9253],
          [0.1679, 0.3698, 0.4640, 0.3230, 0.1097],
          [0....2, 0.3803]]]]), tensor([[0.0891, 0.3098, 0.2478],
        [0.5861, 0.4022, 0.8898],
        [0.4687, 0.1744, 0.6522]]))
trace_kwargs = {}
test_args = (tensor([[[[0.2562, 0.1892, 0.0922, 0.3083, 0.0404],
          [0.7289, 0.5085, 0.0398, 0.9297, 0.9394],
          [0....7, 0.1038]]]]), tensor([[0.0797, 0.7249, 0.6895],
        [0.3134, 0.8248, 0.4523],
        [0.8996, 0.6093, 0.6661]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[2.1494e-01, 6.4111e-01, 2.1109e-01, 2.2348e-01, 8.1559e-01],
          [0.0000e+00, 4.6821e-02, 1.4107e-01,...42e-01, 5.9463e-01, 0.0000e+00, 1.6365e-01],
          [5.5466e-01, 3.1358e-01, 5.3705e-01, 1.3577e-01, 3.2882e-01]]]])
transpiled_x = <tf.Tensor: shape=(1, 3, 5, 5), dtype=float32, numpy=
array([[[[ 0.        ,  0.43002337,  0.        ,  0.01239413,
  ... -0.00978965],
         [ 0.0784815 , -0.14091897,  0.20823646,  0.        ,
           0.        ]]]], dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[2.14940608e-01, 6.41112030e-01, 2.11088657e-01,
          2.23482788e-01, 8.15590024e-01],
         [0.00000...
         [5.54664373e-01, 3.13582242e-01, 5.37051797e-01,
          1.35770023e-01, 3.28815341e-01]]]], dtype=float32)
y = array([[[[ 0.        ,  0.43002337,  0.        ,  0.01239413,
           0.5424494 ],
         [-0.06497389,  0.136911...  -0.00978965],
         [ 0.0784815 , -0.14091897,  0.20823646,  0.        ,
           0.        ]]]], dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.morphology.morphology.top_hat

Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling top_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
                                                                                                                                     
Transpilation of top_hat complete.
________________________________________________________________________________ test_bottom_hat[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_bottom_hat(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
            torch.rand(3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
            torch.rand(3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.morphology.bottom_hat,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_morphology.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bottom_hat at 0x7fb509df6680>
trace_args = (tensor([[[[0.1404, 0.1783, 0.4284, 0.8658, 0.9384],
          [0.2565, 0.6531, 0.1305, 0.5925, 0.6227],
          [0....5, 0.4088]]]]), tensor([[0.0856, 0.0449, 0.7244],
        [0.5331, 0.9901, 0.2240],
        [0.4603, 0.5241, 0.1762]]))
trace_kwargs = {}
test_args = (tensor([[[[1.2875e-01, 2.9227e-03, 2.8036e-01, 9.0093e-02, 9.8943e-01],
          [8.3287e-01, 6.5721e-01, 6.4891e-01....2442e-01]]]]), tensor([[0.9857, 0.7400, 0.9807],
        [0.7329, 0.8018, 0.2889],
        [0.2438, 0.4060, 0.8111]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bottom_hat at 0x7fb509df6680>
trace_args = (tensor([[[[0.1404, 0.1783, 0.4284, 0.8658, 0.9384],
          [0.2565, 0.6531, 0.1305, 0.5925, 0.6227],
          [0....5, 0.4088]]]]), tensor([[0.0856, 0.0449, 0.7244],
        [0.5331, 0.9901, 0.2240],
        [0.4603, 0.5241, 0.1762]]))
trace_kwargs = {}
test_args = (tensor([[[[1.2875e-01, 2.9227e-03, 2.8036e-01, 9.0093e-02, 9.8943e-01],
          [8.3287e-01, 6.5721e-01, 6.4891e-01....2442e-01]]]]), tensor([[0.9857, 0.7400, 0.9807],
        [0.7329, 0.8018, 0.2889],
        [0.2438, 0.4060, 0.8111]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0.5127, 0.4748, 0.2247, 0.0000, 0.0000],
          [0.3966, 0.0000, 0.5226, 0.2733, 0.2913],
          [0.5...73, 0.0000],
          [0.5365, 0.0000, 0.0000, 0.0000, 0.4211],
          [0.4501, 0.0932, 0.6994, 0.6492, 0.2899]]]])
transpiled_x = <tf.Tensor: shape=(1, 3, 5, 5), dtype=float32, numpy=
array([[[[ 0.        ,  0.6875445 , -0.2880165 , -0.7254235 ,
  ...  0.5745503 ],
         [ 0.47728384, -0.12137473,  0.24010313,  0.48062295,
           0.        ]]]], dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0.5127027 , 0.4748237 , 0.2246862 , 0.        , 0.        ],
         [0.39659643, 0.        , 0.52262956, 0...0.        , 0.42112648],
         [0.4500512 , 0.09322083, 0.69936574, 0.6491557 , 0.28990746]]]],
      dtype=float32)
y = array([[[[ 0.        ,  0.6875445 , -0.2880165 , -0.7254235 ,
          -0.17850894],
         [ 0.39659643,  0.      ...   0.5745503 ],
         [ 0.47728384, -0.12137473,  0.24010313,  0.48062295,
           0.        ]]]], dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.morphology.morphology.bottom_hat

Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling bottom_hat from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
                                                                                                                                        
Transpilation of bottom_hat complete.
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_morphology.py::test_dilation[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/test_morphology.py::test_erosion[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/test_morphology.py::test_opening[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/test_morphology.py::test_closing[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/test_morphology.py::test_gradient[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/test_morphology.py::test_top_hat[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/test_morphology.py::test_bottom_hat[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
==================================================================================== 7 failed in 126.73s (0:02:06) =====================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 2 items

kornia/geometry/test_line.py .F                                                                                                                                                                  [100%]

=============================================================================================== FAILURES ===============================================================================================
_____________________________________________________________________________ test_ParametrizedLine[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ParametrizedLine(target_framework, mode, backend_compile):
        print("kornia.geometry.line.ParametrizedLine")
    
        if backend_compile:
            pytest.skip()
    
        origin = torch.tensor([0.0, 0.0], requires_grad=True)
        direction = torch.tensor([1.0, 1.0], requires_grad=True)
        torch_line = kornia.geometry.line.ParametrizedLine(origin, direction)
    
>       TranspiledParametrizedLine = ivy.transpile(kornia.geometry.line.ParametrizedLine, source="torch", target=target_framework)

kornia/geometry/test_line.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.line.ParametrizedLine'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.line.ParametrizedLine
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_line.py::test_ParametrizedLine[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you d...
================================================================================ 1 failed, 1 passed in 96.29s (0:01:36) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 19 items

kornia/test_feature1.py F....FF.FFF.FF..FF.                                                                                                                                                      [100%]

=============================================================================================== FAILURES ===============================================================================================
_______________________________________________________________________________ test_gftt_response[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_gftt_response(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 7, 7),
        )
        trace_kwargs = {'grads_mode': 'sobel', 'sigmas': None}
        test_args = (
            torch.rand(5, 1, 7, 7),
        )
        test_kwargs = {'grads_mode': 'sobel', 'sigmas': None}
>       _test_function(
            kornia.feature.gftt_response,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function gftt_response at 0x7fb874645fc0>
trace_args = (tensor([[[[0.5441, 0.3840, 0.5030, 0.6041, 0.3574, 0.1574, 0.0114],
          [0.1436, 0.3168, 0.3787, 0.7755, 0.2703...2534, 0.2197, 0.3748, 0.6342, 0.9585, 0.0229],
          [0.6945, 0.8722, 0.1277, 0.0511, 0.3523, 0.7668, 0.9703]]]]),)
trace_kwargs = {'grads_mode': 'sobel', 'sigmas': None}
test_args = (tensor([[[[0.3818, 0.2842, 0.8205, 0.8499, 0.0780, 0.6347, 0.9106],
          [0.5742, 0.2836, 0.4678, 0.1360, 0.8376...9063, 0.0133, 0.4007, 0.0359, 0.3814, 0.2458],
          [0.4972, 0.9299, 0.3536, 0.1114, 0.7667, 0.0897, 0.0688]]]]),)
test_kwargs = {'grads_mode': 'sobel', 'sigmas': None}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function gftt_response at 0x7fb874645fc0>
trace_args = (tensor([[[[0.5441, 0.3840, 0.5030, 0.6041, 0.3574, 0.1574, 0.0114],
          [0.1436, 0.3168, 0.3787, 0.7755, 0.2703...2534, 0.2197, 0.3748, 0.6342, 0.9585, 0.0229],
          [0.6945, 0.8722, 0.1277, 0.0511, 0.3523, 0.7668, 0.9703]]]]),)
trace_kwargs = {'grads_mode': 'sobel', 'sigmas': None}
test_args = (tensor([[[[0.3818, 0.2842, 0.8205, 0.8499, 0.0780, 0.6347, 0.9106],
          [0.5742, 0.2836, 0.4678, 0.1360, 0.8376...9063, 0.0133, 0.4007, 0.0359, 0.3814, 0.2458],
          [0.4972, 0.9299, 0.3536, 0.1114, 0.7667, 0.0897, 0.0688]]]]),)
test_kwargs = {'grads_mode': 'sobel', 'sigmas': None}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function gftt_response at 0x7fb874645fc0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.responses.gftt_response
____________________________________________________________________________ test_get_laf_descriptors[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_laf_descriptors(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 32, 32),
            torch.rand(1, 3, 2, 2),
            kornia.feature.HardNet8(pretrained=False),
        )
        trace_kwargs = {'patch_size': 32, 'grayscale_descriptor': True}
        test_args = (
            torch.rand(5, 1, 32, 32),
            torch.rand(5, 3, 2, 2),
            kornia.feature.HardNet8(pretrained=False),
        )
        test_kwargs = {'patch_size': 32, 'grayscale_descriptor': True}
>       _test_function(
            kornia.feature.get_laf_descriptors,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_laf_descriptors at 0x7fb8744877f0>
trace_args = (tensor([[[[0.4502, 0.0041, 0.2040,  ..., 0.5606, 0.1338, 0.1628],
          [0.7434, 0.5887, 0.7893,  ..., 0.2955, 0....=(1, 1), bias=False)
    (23): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=False, track_running_stats=True)
  )
))
trace_kwargs = {'grayscale_descriptor': True, 'patch_size': 32}
test_args = (tensor([[[[0.9087, 0.2176, 0.2818,  ..., 0.4691, 0.6327, 0.7988],
          [0.2277, 0.2821, 0.1912,  ..., 0.0927, 0....=(1, 1), bias=False)
    (23): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=False, track_running_stats=True)
  )
))
test_kwargs = {'grayscale_descriptor': True, 'patch_size': 32}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_laf_descriptors at 0x7fb8744877f0>
trace_args = (tensor([[[[0.4502, 0.0041, 0.2040,  ..., 0.5606, 0.1338, 0.1628],
          [0.7434, 0.5887, 0.7893,  ..., 0.2955, 0....=(1, 1), bias=False)
    (23): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=False, track_running_stats=True)
  )
))
trace_kwargs = {'grayscale_descriptor': True, 'patch_size': 32}
test_args = (tensor([[[[0.9087, 0.2176, 0.2818,  ..., 0.4691, 0.6327, 0.7988],
          [0.2277, 0.2821, 0.1912,  ..., 0.0927, 0....=(1, 1), bias=False)
    (23): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=False, track_running_stats=True)
  )
))
test_kwargs = {'grayscale_descriptor': True, 'patch_size': 32}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
>       orig_out = fn(*trace_args, **trace_kwargs)

helpers.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

img = tensor([[[[0.4502, 0.0041, 0.2040,  ..., 0.5606, 0.1338, 0.1628],
          [0.7434, 0.5887, 0.7893,  ..., 0.2955, 0.4...49, 0.2319, 0.0928,  ..., 0.6018, 0.5323, 0.5887],
          [0.2120, 0.1012, 0.6593,  ..., 0.5032, 0.0392, 0.3704]]]])
lafs = tensor([[[[0.2204, 0.5424],
          [0.4783, 0.1074]],

         [[0.2184, 0.8296],
          [0.3079, 0.2399]],

         [[0.8554, 0.8659],
          [0.6482, 0.0486]]]])
patch_descriptor = HardNet8(
  (features): Sequential(
    (0): Conv2d(1, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=Fal...e=(1, 1), bias=False)
    (23): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=False, track_running_stats=True)
  )
)
patch_size = 32, grayscale_descriptor = True

    def get_laf_descriptors(
        img: Tensor, lafs: Tensor, patch_descriptor: Module, patch_size: int = 32, grayscale_descriptor: bool = True
    ) -> Tensor:
        r"""Function to get local descriptors, corresponding to LAFs (keypoints).
    
        Args:
            img: image features with shape :math:`(B,C,H,W)`.
            lafs: local affine frames :math:`(B,N,2,3)`.
            patch_descriptor: patch descriptor module, e.g. :class:`~kornia.feature.SIFTDescriptor`
                or :class:`~kornia.feature.HardNet`.
            patch_size: patch size in pixels, which descriptor expects.
            grayscale_descriptor: True if ``patch_descriptor`` expects single-channel image.
    
        Returns:
            Local descriptors of shape :math:`(B,N,D)` where :math:`D` is descriptor size.
        """
>       KORNIA_CHECK_LAF(lafs)

/opt/miniconda/envs/multienv/lib/python3.10/site-packages/kornia/feature/integrated.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

laf = tensor([[[[0.2204, 0.5424],
          [0.4783, 0.1074]],

         [[0.2184, 0.8296],
          [0.3079, 0.2399]],

         [[0.8554, 0.8659],
          [0.6482, 0.0486]]]]), raises = True

    def KORNIA_CHECK_LAF(laf: Tensor, raises: bool = True) -> bool:
        """Check whether a Local Affine Frame (laf) has a valid shape.
    
        Args:
            laf: local affine frame tensor to evaluate.
            raises: bool indicating whether an exception should be raised upon failure.
    
        Raises:
            Exception: if the input laf does not have a shape :math:`(B,N,2,3)` and raises is True.
    
        Example:
            >>> lafs = torch.rand(2, 10, 2, 3)
            >>> KORNIA_CHECK_LAF(lafs)
            True
        """
>       return KORNIA_CHECK_SHAPE(laf, ["B", "N", "2", "3"], raises)

/opt/miniconda/envs/multienv/lib/python3.10/site-packages/kornia/core/check.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = tensor([[[[0.2204, 0.5424],
          [0.4783, 0.1074]],

         [[0.2184, 0.8296],
          [0.3079, 0.2399]],

         [[0.8554, 0.8659],
          [0.6482, 0.0486]]]])
shape = ['B', 'N', '2', '3'], raises = True

    def KORNIA_CHECK_SHAPE(x: Tensor, shape: list[str], raises: bool = True) -> bool:
        """Check whether a tensor has a specified shape.
    
        The shape can be specified with a implicit or explicit list of strings.
        The guard also check whether the variable is a type `Tensor`.
    
        Args:
            x: the tensor to evaluate.
            shape: a list with strings with the expected shape.
            raises: bool indicating whether an exception should be raised upon failure.
    
        Raises:
            Exception: if the input tensor is has not the expected shape and raises is True.
    
        Example:
            >>> x = torch.rand(2, 3, 4, 4)
            >>> KORNIA_CHECK_SHAPE(x, ["B", "C", "H", "W"])  # implicit
            True
    
            >>> x = torch.rand(2, 3, 4, 4)
            >>> KORNIA_CHECK_SHAPE(x, ["2", "3", "H", "W"])  # explicit
            True
        """
        if "*" == shape[0]:
            shape_to_check = shape[1:]
            x_shape_to_check = x.shape[-len(shape) + 1 :]
        elif "*" == shape[-1]:
            shape_to_check = shape[:-1]
            x_shape_to_check = x.shape[: len(shape) - 1]
        else:
            shape_to_check = shape
            x_shape_to_check = x.shape
    
        if len(x_shape_to_check) != len(shape_to_check):
            if raises:
                raise TypeError(f"{x} shape must be [{shape}]. Got {x.shape}")
            else:
                return False
    
        for i in range(len(x_shape_to_check)):
            # The voodoo below is because torchscript does not like
            # that dim can be both int and str
            dim_: str = shape_to_check[i]
            if not dim_.isnumeric():
                continue
            dim = int(dim_)
            if x_shape_to_check[i] != dim:
                if raises:
>                   raise TypeError(f"{x} shape must be [{shape}]. Got {x.shape}")
E                   TypeError: tensor([[[[0.2204, 0.5424],
E                             [0.4783, 0.1074]],
E                   
E                            [[0.2184, 0.8296],
E                             [0.3079, 0.2399]],
E                   
E                            [[0.8554, 0.8659],
E                             [0.6482, 0.0486]]]]) shape must be [['B', 'N', '2', '3']]. Got torch.Size([1, 3, 2, 2])

/opt/miniconda/envs/multienv/lib/python3.10/site-packages/kornia/core/check.py:80: TypeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.integrated.get_laf_descriptors

Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.. 
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time...
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time   
Transpiling get_laf_descriptors from torch to tensorflow. This could take a few minutes if you're transpiling this function for the first time.  
                                                                                                                                                 
Transpilation of get_laf_descriptors complete.
_________________________________________________________________________________ test_match_nn[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_match_nn(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 128),
            torch.rand(1, 128),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 128),
            torch.rand(5, 128),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.match_nn,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
            skip=True,
        )

kornia/test_feature1.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function match_nn at 0x7fb874486b00>
trace_args = (tensor([[0.2212, 0.6679, 0.1266, 0.3264, 0.6231, 0.6649, 0.8722, 0.6748, 0.4283,
         0.1052, 0.3198, 0.4308, 0.1...6, 0.5318,
         0.5174, 0.4092, 0.6378, 0.9759, 0.9101, 0.4836, 0.0424, 0.1435, 0.7010,
         0.4517, 0.0830]]))
trace_kwargs = {}
test_args = (tensor([[3.4945e-01, 3.4430e-01, 3.4921e-01, 4.9452e-01, 3.7650e-01, 6.4559e-01,
         4.1977e-01, 2.8132e-01, 4.5...1,
         7.8242e-01, 3.6494e-02, 3.9344e-01, 6.0280e-01, 1.5526e-01, 2.8171e-01,
         6.0127e-02, 4.3736e-01]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = True, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function match_nn at 0x7fb874486b00>
trace_args = (tensor([[0.2212, 0.6679, 0.1266, 0.3264, 0.6231, 0.6649, 0.8722, 0.6748, 0.4283,
         0.1052, 0.3198, 0.4308, 0.1...6, 0.5318,
         0.5174, 0.4092, 0.6378, 0.9759, 0.9101, 0.4836, 0.0424, 0.1435, 0.7010,
         0.4517, 0.0830]]))
trace_kwargs = {}
test_args = (tensor([[3.4945e-01, 3.4430e-01, 3.4921e-01, 4.9452e-01, 3.7650e-01, 6.4559e-01,
         4.1977e-01, 2.8132e-01, 4.5...1,
         7.8242e-01, 3.6494e-02, 3.9344e-01, 6.0280e-01, 1.5526e-01, 2.8171e-01,
         6.0127e-02, 4.3736e-01]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function match_nn at 0x7fb874486b00>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.matching.match_nn
_________________________________________________________________________________ test_match_snn[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_match_snn(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 128),
            torch.rand(1, 128),
        )
        trace_kwargs = {'th': 0.8}
        test_args = (
            torch.rand(5, 128),
            torch.rand(5, 128),
        )
        test_kwargs = {'th': 0.8}
>       _test_function(
            kornia.feature.match_snn,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function match_snn at 0x7fb874486c20>
trace_args = (tensor([[0.4904, 0.8945, 0.1837, 0.6225, 0.2206, 0.5337, 0.0985, 0.0890, 0.3830,
         0.0920, 0.3648, 0.0308, 0.8...1,
         2.4963e-01, 8.5914e-01, 3.7624e-01, 6.1176e-01, 6.3523e-02, 5.1676e-01,
         7.2143e-01, 6.2426e-01]]))
trace_kwargs = {'th': 0.8}
test_args = (tensor([[0.7972, 0.9948, 0.2924, 0.6223, 0.6687, 0.3228, 0.2046, 0.4886, 0.5178,
         0.9731, 0.6554, 0.6366, 0.1...5, 0.1815,
         0.4127, 0.0777, 0.0765, 0.9477, 0.4687, 0.9091, 0.0796, 0.0311, 0.4943,
         0.3509, 0.5639]]))
test_kwargs = {'th': 0.8}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function match_snn at 0x7fb874486c20>
trace_args = (tensor([[0.4904, 0.8945, 0.1837, 0.6225, 0.2206, 0.5337, 0.0985, 0.0890, 0.3830,
         0.0920, 0.3648, 0.0308, 0.8...1,
         2.4963e-01, 8.5914e-01, 3.7624e-01, 6.1176e-01, 6.3523e-02, 5.1676e-01,
         7.2143e-01, 6.2426e-01]]))
trace_kwargs = {'th': 0.8}
test_args = (tensor([[0.7972, 0.9948, 0.2924, 0.6223, 0.6687, 0.3228, 0.2046, 0.4886, 0.5178,
         0.9731, 0.6554, 0.6366, 0.1...5, 0.1815,
         0.4127, 0.0777, 0.0765, 0.9477, 0.4687, 0.9091, 0.0796, 0.0311, 0.4943,
         0.3509, 0.5639]]))
test_kwargs = {'th': 0.8}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function match_snn at 0x7fb874486c20>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.matching.match_snn
________________________________________________________________________________ test_match_smnn[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_match_smnn(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 128),
            torch.rand(1, 128),
        )
        trace_kwargs = {'th': 0.95}
        test_args = (
            torch.rand(5, 128),
            torch.rand(5, 128),
        )
        test_kwargs = {'th': 0.95}
>       _test_function(
            kornia.feature.match_smnn,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function match_smnn at 0x7fb874486cb0>
trace_args = (tensor([[0.6283, 0.2890, 0.7886, 0.7432, 0.4378, 0.8899, 0.8597, 0.1710, 0.2284,
         0.4420, 0.6710, 0.9336, 0.9...1, 0.7426,
         0.3644, 0.8645, 0.3873, 0.7293, 0.2496, 0.6942, 0.2338, 0.1780, 0.3146,
         0.4346, 0.4865]]))
trace_kwargs = {'th': 0.95}
test_args = (tensor([[0.5169, 0.2515, 0.3401, 0.9998, 0.7097, 0.6029, 0.6034, 0.4208, 0.3094,
         0.1564, 0.9909, 0.3935, 0.2...1,
         8.9856e-01, 1.7705e-01, 1.9669e-01, 3.9709e-01, 6.4212e-01, 3.6283e-02,
         1.2718e-01, 5.8019e-01]]))
test_kwargs = {'th': 0.95}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function match_smnn at 0x7fb874486cb0>
trace_args = (tensor([[0.6283, 0.2890, 0.7886, 0.7432, 0.4378, 0.8899, 0.8597, 0.1710, 0.2284,
         0.4420, 0.6710, 0.9336, 0.9...1, 0.7426,
         0.3644, 0.8645, 0.3873, 0.7293, 0.2496, 0.6942, 0.2338, 0.1780, 0.3146,
         0.4346, 0.4865]]))
trace_kwargs = {'th': 0.95}
test_args = (tensor([[0.5169, 0.2515, 0.3401, 0.9998, 0.7097, 0.6029, 0.6034, 0.4208, 0.3094,
         0.1564, 0.9909, 0.3935, 0.2...1,
         8.9856e-01, 1.7705e-01, 1.9669e-01, 3.9709e-01, 6.4212e-01, 3.6283e-02,
         1.2718e-01, 5.8019e-01]]))
test_kwargs = {'th': 0.95}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function match_smnn at 0x7fb874486cb0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.matching.match_smnn
________________________________________________________________________________ test_match_fginn[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_match_fginn(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(3, 128),
            torch.rand(3, 128),
            torch.rand(1, 3, 2, 3),
            torch.rand(1, 3, 2, 3),
        )
        trace_kwargs = {'th': 0.8, 'spatial_th': 10.0, 'mutual': False}
        test_args = (
            torch.rand(5, 128),
            torch.rand(5, 128),
            torch.rand(1, 5, 2, 3),
            torch.rand(1, 5, 2, 3),
        )
        test_kwargs = {'th': 0.8, 'spatial_th': 10.0, 'mutual': False}
>       _test_function(
            kornia.feature.match_fginn,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function match_fginn at 0x7fb874486d40>
trace_args = (tensor([[0.2208, 0.9323, 0.6825, 0.5870, 0.3928, 0.2650, 0.6353, 0.4554, 0.6635,
         0.4087, 0.1496, 0.0331, 0.1...951],
          [0.8503, 0.9050, 0.3380]],

         [[0.5244, 0.1096, 0.5989],
          [0.8214, 0.0685, 0.3828]]]]))
trace_kwargs = {'mutual': False, 'spatial_th': 10.0, 'th': 0.8}
test_args = (tensor([[0.4035, 0.5218, 0.2420, 0.8468, 0.1924, 0.3752, 0.0130, 0.0291, 0.3517,
         0.6469, 0.9698, 0.0068, 0.1...478],
          [0.1150, 0.7535, 0.1386]],

         [[0.9576, 0.8982, 0.1334],
          [0.3584, 0.2531, 0.5548]]]]))
test_kwargs = {'mutual': False, 'spatial_th': 10.0, 'th': 0.8}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function match_fginn at 0x7fb874486d40>
trace_args = (tensor([[0.2208, 0.9323, 0.6825, 0.5870, 0.3928, 0.2650, 0.6353, 0.4554, 0.6635,
         0.4087, 0.1496, 0.0331, 0.1...951],
          [0.8503, 0.9050, 0.3380]],

         [[0.5244, 0.1096, 0.5989],
          [0.8214, 0.0685, 0.3828]]]]))
trace_kwargs = {'mutual': False, 'spatial_th': 10.0, 'th': 0.8}
test_args = (tensor([[0.4035, 0.5218, 0.2420, 0.8468, 0.1924, 0.3752, 0.0130, 0.0291, 0.3517,
         0.6469, 0.9698, 0.0068, 0.1...478],
          [0.1150, 0.7535, 0.1386]],

         [[0.9576, 0.8982, 0.1334],
          [0.3584, 0.2531, 0.5548]]]]))
test_kwargs = {'mutual': False, 'spatial_th': 10.0, 'th': 0.8}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function match_fginn at 0x7fb874486d40>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.matching.match_fginn
_______________________________________________________________________ test_extract_patches_from_pyramid[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_extract_patches_from_pyramid(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 32, 32),
            torch.rand(1, 5, 2, 3),
        )
        trace_kwargs = {'PS': 32}
        test_args = (
            torch.rand(1, 3, 64, 64),  # TODO: changing the batch size of these causes the trace_graph test to fail
            torch.rand(1, 5, 2, 3),
        )
        test_kwargs = {'PS': 16}
>       _test_function(
            kornia.feature.extract_patches_from_pyramid,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function extract_patches_from_pyramid at 0x7fb87460e320>
trace_args = (tensor([[[[6.6197e-01, 3.7501e-01, 1.9480e-01,  ..., 8.9892e-01,
           7.3152e-01, 8.3489e-01],
          [1.619...038],
          [0.9597, 0.3837, 0.9854]],

         [[0.4454, 0.5560, 0.9969],
          [0.4098, 0.7879, 0.3424]]]]))
trace_kwargs = {'PS': 32}
test_args = (tensor([[[[1.2153e-01, 7.7725e-01, 3.2908e-01,  ..., 3.5238e-01,
           9.4413e-01, 9.9497e-01],
          [3.209...336],
          [0.6316, 0.8822, 0.3143]],

         [[0.6884, 0.7051, 0.1606],
          [0.1856, 0.4771, 0.0580]]]]))
test_kwargs = {'PS': 16}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function extract_patches_from_pyramid at 0x7fb87460e320>
trace_args = (tensor([[[[6.6197e-01, 3.7501e-01, 1.9480e-01,  ..., 8.9892e-01,
           7.3152e-01, 8.3489e-01],
          [1.619...038],
          [0.9597, 0.3837, 0.9854]],

         [[0.4454, 0.5560, 0.9969],
          [0.4098, 0.7879, 0.3424]]]]))
trace_kwargs = {'PS': 32}
test_args = (tensor([[[[1.2153e-01, 7.7725e-01, 3.2908e-01,  ..., 3.5238e-01,
           9.4413e-01, 9.9497e-01],
          [3.209...336],
          [0.6316, 0.8822, 0.3143]],

         [[0.6884, 0.7051, 0.1606],
          [0.1856, 0.4771, 0.0580]]]]))
test_kwargs = {'PS': 16}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
        translated_fn = ivy.source_to_source(fn, source="torch", target=target)
    
        if backend_compile:
            try:
                fn = torch.compile(fn)
                fn(*trace_args, **trace_kwargs)
                orig_compilable = True
            except:
                orig_compilable = False
    
            # only test with backend compilation if the original function was compilable in torch
            if orig_compilable:
                translated_fn = _backend_compile(translated_fn, target)
    
        # test it works with the trace_args as input
        orig_out = fn(*trace_args, **trace_kwargs)
        graph_args = _nest_torch_tensor_to_new_framework(trace_args, target)
        graph_kwargs = _nest_torch_tensor_to_new_framework(trace_kwargs, target)
        graph_out = translated_fn(*graph_args, **graph_kwargs)
    
        if deterministic:
>           _to_numpy_and_allclose(orig_out, graph_out, tolerance=tolerance)

helpers.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[[0.6620, 0.6620, 0.6620,  ..., 0.6620, 0.6620, 0.6620],
           [0.6620, 0.6620, 0.6620,  ..., 0.6620, 0..., 0.2346, 0.2444,  ..., 0.5248, 0.5267, 0.5279],
           [0.2429, 0.2532, 0.2640,  ..., 0.5316, 0.5254, 0.5192]]]]])
transpiled_x = <tf.Tensor: shape=(1, 5, 3, 32, 32), dtype=float32, numpy=
array([[[[[0.6619717, 0.6619717, 0.6619717, ..., 0.       ,...   ],
          [0.       , 0.       , 0.       , ..., 0.       , 0.       ,
           0.       ]]]]], dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[[0.6619717 , 0.6619717 , 0.6619717 , ..., 0.6619717 ,
           0.6619717 , 0.6619717 ],
          [0.66197...
          [0.2429161 , 0.25315103, 0.2639807 , ..., 0.5315656 ,
           0.5253956 , 0.51917595]]]]], dtype=float32)
y = array([[[[[0.6619717, 0.6619717, 0.6619717, ..., 0.       , 0.       ,
           0.       ],
          [0.       , 0....    ],
          [0.       , 0.       , 0.       , ..., 0.       , 0.       ,
           0.       ]]]]], dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.extract_patches_from_pyramid
__________________________________________________________________________ test_extract_patches_simple[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_extract_patches_simple(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 32, 32),
            torch.rand(1, 5, 2, 3),
        )
        trace_kwargs = {'PS': 32, 'normalize_lafs_before_extraction': True}
        test_args = (
            torch.rand(2, 3, 64, 64),
            torch.rand(2, 5, 2, 3),
        )
        test_kwargs = {'PS': 16, 'normalize_lafs_before_extraction': False}
>       _test_function(
            kornia.feature.extract_patches_simple,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function extract_patches_simple at 0x7fb87460e290>
trace_args = (tensor([[[[0.4358, 0.5482, 0.6705,  ..., 0.8574, 0.5071, 0.3445],
          [0.5068, 0.8866, 0.9824,  ..., 0.0970, 0....671],
          [0.9983, 0.6636, 0.6944]],

         [[0.7532, 0.4687, 0.1774],
          [0.9340, 0.7592, 0.9517]]]]))
trace_kwargs = {'PS': 32, 'normalize_lafs_before_extraction': True}
test_args = (tensor([[[[0.1582, 0.7325, 0.2809,  ..., 0.1385, 0.9931, 0.0692],
          [0.0252, 0.9714, 0.9384,  ..., 0.9550, 0....858],
          [0.7630, 0.0304, 0.4121]],

         [[0.5872, 0.4959, 0.5151],
          [0.4257, 0.5011, 0.3056]]]]))
test_kwargs = {'PS': 16, 'normalize_lafs_before_extraction': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function extract_patches_simple at 0x7fb87460e290>
trace_args = (tensor([[[[0.4358, 0.5482, 0.6705,  ..., 0.8574, 0.5071, 0.3445],
          [0.5068, 0.8866, 0.9824,  ..., 0.0970, 0....671],
          [0.9983, 0.6636, 0.6944]],

         [[0.7532, 0.4687, 0.1774],
          [0.9340, 0.7592, 0.9517]]]]))
trace_kwargs = {'PS': 32, 'normalize_lafs_before_extraction': True}
test_args = (tensor([[[[0.1582, 0.7325, 0.2809,  ..., 0.1385, 0.9931, 0.0692],
          [0.0252, 0.9714, 0.9384,  ..., 0.9550, 0....858],
          [0.7630, 0.0304, 0.4121]],

         [[0.5872, 0.4959, 0.5151],
          [0.4257, 0.5011, 0.3056]]]]))
test_kwargs = {'PS': 16, 'normalize_lafs_before_extraction': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function extract_patches_simple at 0x7fb87460e290>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.extract_patches_simple
__________________________________________________________________________ test_laf_to_boundary_points[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_laf_to_boundary_points(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 5, 2, 3),
        )
        trace_kwargs = {'n_pts': 50}
        test_args = (
            torch.rand(2, 5, 2, 3),
        )
        test_kwargs = {'n_pts': 100}
>       _test_function(
            kornia.feature.laf_to_boundary_points,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_to_boundary_points at 0x7fb87460dfc0>
trace_args = (tensor([[[[0.3285, 0.3572, 0.2403],
          [0.8067, 0.9891, 0.6602]],

         [[0.8591, 0.2459, 0.2786],
       ...86],
          [0.8956, 0.6815, 0.6887]],

         [[0.8716, 0.5595, 0.1567],
          [0.4289, 0.8926, 0.3568]]]]),)
trace_kwargs = {'n_pts': 50}
test_args = (tensor([[[[0.3736, 0.7089, 0.1145],
          [0.3552, 0.4975, 0.6857]],

         [[0.0051, 0.6760, 0.4196],
       ...01],
          [0.4783, 0.4422, 0.8525]],

         [[0.1247, 0.9345, 0.6265],
          [0.0759, 0.6788, 0.2117]]]]),)
test_kwargs = {'n_pts': 100}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_to_boundary_points at 0x7fb87460dfc0>
trace_args = (tensor([[[[0.3285, 0.3572, 0.2403],
          [0.8067, 0.9891, 0.6602]],

         [[0.8591, 0.2459, 0.2786],
       ...86],
          [0.8956, 0.6815, 0.6887]],

         [[0.8716, 0.5595, 0.1567],
          [0.4289, 0.8926, 0.3568]]]]),)
trace_kwargs = {'n_pts': 50}
test_args = (tensor([[[[0.3736, 0.7089, 0.1145],
          [0.3552, 0.4975, 0.6857]],

         [[0.0051, 0.6760, 0.4196],
       ...01],
          [0.4783, 0.4422, 0.8525]],

         [[0.1247, 0.9345, 0.6265],
          [0.0759, 0.6788, 0.2117]]]]),)
test_kwargs = {'n_pts': 100}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function laf_to_boundary_points at 0x7fb87460dfc0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.laf_to_boundary_points
______________________________________________________________________________ test_ellipse_to_laf[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ellipse_to_laf(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 10, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2, 10, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.ellipse_to_laf,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature1.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function ellipse_to_laf at 0x7fb87460df30>
trace_args = (tensor([[[0.7934, 0.9572, 0.2151, 0.6336, 0.8236],
         [0.9327, 0.3729, 0.6597, 0.7644, 0.3261],
         [0.517...643, 0.5784],
         [0.0530, 0.6876, 0.8151, 0.8107, 0.9073],
         [0.8946, 0.3619, 0.3806, 0.5414, 0.5828]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.9605, 0.6224, 0.2724, 0.5120, 0.8467],
         [0.7648, 0.5169, 0.9501, 0.3712, 0.9255],
         [0.124...508, 0.5750],
         [0.7457, 0.4980, 0.8896, 0.4270, 0.1618],
         [0.5747, 0.3082, 0.0323, 0.2632, 0.5412]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function ellipse_to_laf at 0x7fb87460df30>
trace_args = (tensor([[[0.7934, 0.9572, 0.2151, 0.6336, 0.8236],
         [0.9327, 0.3729, 0.6597, 0.7644, 0.3261],
         [0.517...643, 0.5784],
         [0.0530, 0.6876, 0.8151, 0.8107, 0.9073],
         [0.8946, 0.3619, 0.3806, 0.5414, 0.5828]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.9605, 0.6224, 0.2724, 0.5120, 0.8467],
         [0.7648, 0.5169, 0.9501, 0.3712, 0.9255],
         [0.124...508, 0.5750],
         [0.7457, 0.4980, 0.8896, 0.4270, 0.1618],
         [0.5747, 0.3082, 0.0323, 0.2632, 0.5412]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function ellipse_to_laf at 0x7fb87460df30>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.ellipse_to_laf
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_feature1.py::test_gftt_response[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_feature1.py::test_get_laf_descriptors[tensorflow-s2s-False] - TypeError: tensor([[[[0.2204, 0.5424],
FAILED kornia/test_feature1.py::test_match_nn[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_feature1.py::test_match_snn[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_feature1.py::test_match_smnn[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_feature1.py::test_match_fginn[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_feature1.py::test_extract_patches_from_pyramid[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/test_feature1.py::test_extract_patches_simple[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you ...
FAILED kornia/test_feature1.py::test_laf_to_boundary_points[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you ...
FAILED kornia/test_feature1.py::test_ellipse_to_laf[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
=============================================================================== 10 failed, 9 passed in 374.67s (0:06:14) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 69 items

kornia/test_color.py FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...FFFFF.FFFF.FF                                                                                                       [100%]

=============================================================================================== FAILURES ===============================================================================================
_____________________________________________________________________________ test_rgb_to_grayscale[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_grayscale(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_grayscale,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_grayscale at 0x7f8e789c97e0>
trace_args = (tensor([[[[0.6720, 0.8756, 0.2471, 0.1418],
          [0.1444, 0.3820, 0.5585, 0.6823],
          [0.0702, 0.3556, 0...., 0.7825, 0.8890, 0.0082],
          [0.5193, 0.7279, 0.5627, 0.2162],
          [0.7211, 0.6262, 0.4940, 0.9242]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[1.2923e-01, 5.8807e-03, 5.6118e-01, 5.1603e-01],
          [5.8520e-01, 7.6456e-02, 1.3562e-01, 1.4522e-01...     [6.1828e-01, 3.2164e-01, 7.0125e-01, 9.6632e-01],
          [9.7225e-01, 5.3151e-01, 6.2265e-01, 6.3000e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_grayscale at 0x7f8e789c97e0>
trace_args = (tensor([[[[0.6720, 0.8756, 0.2471, 0.1418],
          [0.1444, 0.3820, 0.5585, 0.6823],
          [0.0702, 0.3556, 0...., 0.7825, 0.8890, 0.0082],
          [0.5193, 0.7279, 0.5627, 0.2162],
          [0.7211, 0.6262, 0.4940, 0.9242]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[1.2923e-01, 5.8807e-03, 5.6118e-01, 5.1603e-01],
          [5.8520e-01, 7.6456e-02, 1.3562e-01, 1.4522e-01...     [6.1828e-01, 3.2164e-01, 7.0125e-01, 9.6632e-01],
          [9.7225e-01, 5.3151e-01, 6.2265e-01, 6.3000e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_grayscale at 0x7f8e789c97e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.gray.rgb_to_grayscale
_____________________________________________________________________________ test_bgr_to_grayscale[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_bgr_to_grayscale(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.bgr_to_grayscale,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bgr_to_grayscale at 0x7f8e789c9e10>
trace_args = (tensor([[[[0.8327, 0.3242, 0.8410, 0.9698],
          [0.1448, 0.6049, 0.0545, 0.0033],
          [0.1724, 0.2157, 0...., 0.0447, 0.8261, 0.4229],
          [0.2350, 0.0026, 0.3270, 0.3515],
          [0.2460, 0.3909, 0.5548, 0.8861]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[7.4557e-01, 4.6163e-01, 9.9558e-02, 3.4915e-01],
          [2.4877e-02, 3.0760e-01, 8.0032e-02, 1.6840e-02...     [5.5172e-01, 4.7397e-01, 6.8933e-01, 6.5973e-01],
          [4.5391e-01, 1.6217e-01, 5.1983e-01, 2.1397e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bgr_to_grayscale at 0x7f8e789c9e10>
trace_args = (tensor([[[[0.8327, 0.3242, 0.8410, 0.9698],
          [0.1448, 0.6049, 0.0545, 0.0033],
          [0.1724, 0.2157, 0...., 0.0447, 0.8261, 0.4229],
          [0.2350, 0.0026, 0.3270, 0.3515],
          [0.2460, 0.3909, 0.5548, 0.8861]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[7.4557e-01, 4.6163e-01, 9.9558e-02, 3.4915e-01],
          [2.4877e-02, 3.0760e-01, 8.0032e-02, 1.6840e-02...     [5.5172e-01, 4.7397e-01, 6.8933e-01, 6.5973e-01],
          [4.5391e-01, 1.6217e-01, 5.1983e-01, 2.1397e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function bgr_to_grayscale at 0x7f8e789c9e10>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.gray.bgr_to_grayscale
_____________________________________________________________________________ test_grayscale_to_rgb[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_grayscale_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.grayscale_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function grayscale_to_rgb at 0x7f8e789c91b0>
trace_args = (tensor([[[[0.2888, 0.2844, 0.2859, 0.2865],
          [0.6917, 0.2627, 0.4516, 0.5047],
          [0.1342, 0.9322, 0.9577, 0.6632],
          [0.6537, 0.9528, 0.6577, 0.1639]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.7475, 0.5296, 0.0982, 0.1491],
          [0.8197, 0.4188, 0.0104, 0.8420],
          [0.6851, 0.6691, 0...., 0.4727, 0.1312, 0.6547],
          [0.5306, 0.3947, 0.0324, 0.8871],
          [0.7253, 0.3258, 0.2820, 0.0530]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function grayscale_to_rgb at 0x7f8e789c91b0>
trace_args = (tensor([[[[0.2888, 0.2844, 0.2859, 0.2865],
          [0.6917, 0.2627, 0.4516, 0.5047],
          [0.1342, 0.9322, 0.9577, 0.6632],
          [0.6537, 0.9528, 0.6577, 0.1639]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.7475, 0.5296, 0.0982, 0.1491],
          [0.8197, 0.4188, 0.0104, 0.8420],
          [0.6851, 0.6691, 0...., 0.4727, 0.1312, 0.6547],
          [0.5306, 0.3947, 0.0324, 0.8871],
          [0.7253, 0.3258, 0.2820, 0.0530]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function grayscale_to_rgb at 0x7f8e789c91b0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.gray.grayscale_to_rgb
________________________________________________________________________________ test_rgb_to_bgr[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_bgr(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 3, 5, 5),)
        trace_kwargs = {}
        test_args = (torch.rand(5, 3, 5, 5),)
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_bgr,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_bgr at 0x7f8e789c9360>
trace_args = (tensor([[[[0.2634, 0.0024, 0.0036, 0.6892, 0.2628],
          [0.1460, 0.6184, 0.5406, 0.9079, 0.6255],
          [0...., 0.9001],
          [0.1716, 0.1908, 0.5071, 0.5150, 0.8819],
          [0.4390, 0.6617, 0.0061, 0.7297, 0.6706]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.5521, 0.7817, 0.8281, 0.3983, 0.0430],
          [0.4060, 0.4421, 0.2440, 0.5697, 0.6884],
          [0...., 0.7166],
          [0.6954, 0.6149, 0.9146, 0.5953, 0.2813],
          [0.7803, 0.2324, 0.2499, 0.5669, 0.2412]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_bgr at 0x7f8e789c9360>
trace_args = (tensor([[[[0.2634, 0.0024, 0.0036, 0.6892, 0.2628],
          [0.1460, 0.6184, 0.5406, 0.9079, 0.6255],
          [0...., 0.9001],
          [0.1716, 0.1908, 0.5071, 0.5150, 0.8819],
          [0.4390, 0.6617, 0.0061, 0.7297, 0.6706]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.5521, 0.7817, 0.8281, 0.3983, 0.0430],
          [0.4060, 0.4421, 0.2440, 0.5697, 0.6884],
          [0...., 0.7166],
          [0.6954, 0.6149, 0.9146, 0.5953, 0.2813],
          [0.7803, 0.2324, 0.2499, 0.5669, 0.2412]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_bgr at 0x7f8e789c9360>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.rgb_to_bgr
________________________________________________________________________________ test_bgr_to_rgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_bgr_to_rgb(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 3, 5, 5),)
        trace_kwargs = {}
        test_args = (torch.rand(5, 3, 5, 5),)
        test_kwargs = {}
>       _test_function(
            kornia.color.bgr_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bgr_to_rgb at 0x7f8e789c93f0>
trace_args = (tensor([[[[0.4272, 0.2747, 0.2550, 0.6055, 0.5352],
          [0.3202, 0.5395, 0.8814, 0.6844, 0.4645],
          [0...., 0.3090],
          [0.0432, 0.0368, 0.5823, 0.0505, 0.4624],
          [0.7517, 0.0340, 0.2076, 0.0051, 0.9906]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[9.0905e-01, 8.1508e-02, 4.1680e-01, 3.3125e-03, 7.5588e-01],
          [2.3815e-01, 9.7398e-01, 7.2350e-01...e-01, 2.3516e-01, 2.6034e-03, 4.7844e-01],
          [3.7921e-01, 4.7173e-01, 6.0564e-01, 2.2170e-01, 1.3793e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bgr_to_rgb at 0x7f8e789c93f0>
trace_args = (tensor([[[[0.4272, 0.2747, 0.2550, 0.6055, 0.5352],
          [0.3202, 0.5395, 0.8814, 0.6844, 0.4645],
          [0...., 0.3090],
          [0.0432, 0.0368, 0.5823, 0.0505, 0.4624],
          [0.7517, 0.0340, 0.2076, 0.0051, 0.9906]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[9.0905e-01, 8.1508e-02, 4.1680e-01, 3.3125e-03, 7.5588e-01],
          [2.3815e-01, 9.7398e-01, 7.2350e-01...e-01, 2.3516e-01, 2.6034e-03, 4.7844e-01],
          [3.7921e-01, 4.7173e-01, 6.0564e-01, 2.2170e-01, 1.3793e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function bgr_to_rgb at 0x7f8e789c93f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.bgr_to_rgb
_____________________________________________________________________________ test_rgb_to_linear_rgb[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_linear_rgb(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 3, 5, 5),)
        trace_kwargs = {}
        test_args = (torch.rand(5, 3, 5, 5),)
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_linear_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_linear_rgb at 0x7f8e789c96c0>
trace_args = (tensor([[[[0.2185, 0.1526, 0.4834, 0.7050, 0.5345],
          [0.9429, 0.8066, 0.9376, 0.6349, 0.3729],
          [0...., 0.8265],
          [0.2400, 0.5907, 0.7334, 0.2816, 0.1217],
          [0.7587, 0.5106, 0.7146, 0.8327, 0.4432]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.0292, 0.1178, 0.3653, 0.5630, 0.9804],
          [0.2562, 0.7362, 0.9507, 0.7888, 0.3949],
          [0...., 0.3095],
          [0.7113, 0.9168, 0.3914, 0.0469, 0.9644],
          [0.6013, 0.8292, 0.3938, 0.1550, 0.9967]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_linear_rgb at 0x7f8e789c96c0>
trace_args = (tensor([[[[0.2185, 0.1526, 0.4834, 0.7050, 0.5345],
          [0.9429, 0.8066, 0.9376, 0.6349, 0.3729],
          [0...., 0.8265],
          [0.2400, 0.5907, 0.7334, 0.2816, 0.1217],
          [0.7587, 0.5106, 0.7146, 0.8327, 0.4432]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.0292, 0.1178, 0.3653, 0.5630, 0.9804],
          [0.2562, 0.7362, 0.9507, 0.7888, 0.3949],
          [0...., 0.3095],
          [0.7113, 0.9168, 0.3914, 0.0469, 0.9644],
          [0.6013, 0.8292, 0.3938, 0.1550, 0.9967]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_linear_rgb at 0x7f8e789c96c0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.rgb_to_linear_rgb
_____________________________________________________________________________ test_linear_rgb_to_rgb[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_linear_rgb_to_rgb(target_framework, mode, backend_compile):
        trace_args = (torch.rand(1, 3, 5, 5),)
        trace_kwargs = {}
        test_args = (torch.rand(5, 3, 5, 5),)
        test_kwargs = {}
>       _test_function(
            kornia.color.linear_rgb_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function linear_rgb_to_rgb at 0x7f8e789c9750>
trace_args = (tensor([[[[0.6420, 0.1239, 0.6960, 0.3363, 0.2382],
          [0.2287, 0.1063, 0.8585, 0.9406, 0.8341],
          [0...., 0.4068],
          [0.3676, 0.3840, 0.9544, 0.5433, 0.0216],
          [0.9327, 0.3877, 0.1373, 0.7993, 0.4196]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.8037, 0.0883, 0.5483, 0.5753, 0.3497],
          [0.6115, 0.7923, 0.5506, 0.7872, 0.5664],
          [0...., 0.8798],
          [0.1771, 0.0140, 0.2450, 0.6496, 0.1622],
          [0.4384, 0.3247, 0.3846, 0.5746, 0.3942]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function linear_rgb_to_rgb at 0x7f8e789c9750>
trace_args = (tensor([[[[0.6420, 0.1239, 0.6960, 0.3363, 0.2382],
          [0.2287, 0.1063, 0.8585, 0.9406, 0.8341],
          [0...., 0.4068],
          [0.3676, 0.3840, 0.9544, 0.5433, 0.0216],
          [0.9327, 0.3877, 0.1373, 0.7993, 0.4196]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.8037, 0.0883, 0.5483, 0.5753, 0.3497],
          [0.6115, 0.7923, 0.5506, 0.7872, 0.5664],
          [0...., 0.8798],
          [0.1771, 0.0140, 0.2450, 0.6496, 0.1622],
          [0.4384, 0.3247, 0.3846, 0.5746, 0.3942]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function linear_rgb_to_rgb at 0x7f8e789c9750>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.linear_rgb_to_rgb
________________________________________________________________________________ test_bgr_to_rgba[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_bgr_to_rgba(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
            1.0,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 4),
            0.5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.bgr_to_rgba,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bgr_to_rgba at 0x7f8e789c9510>
trace_args = (tensor([[[[0.5635, 0.9086, 0.1924, 0.7409],
          [0.0652, 0.0780, 0.7415, 0.5968],
          [0.7383, 0.1726, 0....0713, 0.8216, 0.9465],
          [0.8148, 0.6578, 0.3805, 0.1620],
          [0.5685, 0.8471, 0.7096, 0.0871]]]]), 1.0)
trace_kwargs = {}
test_args = (tensor([[[[0.1496, 0.1083, 0.8042, 0.2545],
          [0.7735, 0.0969, 0.0574, 0.9240],
          [0.6576, 0.8356, 0....8449, 0.1746, 0.9695],
          [0.0938, 0.1477, 0.7745, 0.1697],
          [0.9713, 0.0907, 0.6407, 0.5639]]]]), 0.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function bgr_to_rgba at 0x7f8e789c9510>
trace_args = (tensor([[[[0.5635, 0.9086, 0.1924, 0.7409],
          [0.0652, 0.0780, 0.7415, 0.5968],
          [0.7383, 0.1726, 0....0713, 0.8216, 0.9465],
          [0.8148, 0.6578, 0.3805, 0.1620],
          [0.5685, 0.8471, 0.7096, 0.0871]]]]), 1.0)
trace_kwargs = {}
test_args = (tensor([[[[0.1496, 0.1083, 0.8042, 0.2545],
          [0.7735, 0.0969, 0.0574, 0.9240],
          [0.6576, 0.8356, 0....8449, 0.1746, 0.9695],
          [0.0938, 0.1477, 0.7745, 0.1697],
          [0.9713, 0.0907, 0.6407, 0.5639]]]]), 0.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function bgr_to_rgba at 0x7f8e789c9510>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.bgr_to_rgba
________________________________________________________________________________ test_rgb_to_rgba[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_rgba(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
            1.0,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 4),
            0.5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_rgba,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_rgba at 0x7f8e789c9480>
trace_args = (tensor([[[[9.9202e-01, 8.0611e-01, 9.1731e-01, 2.8279e-01],
          [8.7525e-01, 9.3360e-01, 2.6379e-01, 2.5282e-01... [9.9090e-01, 7.5704e-01, 5.5419e-01, 4.6942e-01],
          [2.7005e-01, 7.5001e-01, 7.5574e-01, 4.5822e-01]]]]), 1.0)
trace_kwargs = {}
test_args = (tensor([[[[4.1841e-01, 9.2986e-01, 6.4936e-01, 4.3991e-01],
          [2.4616e-01, 3.8923e-01, 6.7901e-01, 6.6209e-01... [5.7396e-01, 7.0501e-01, 9.6914e-01, 5.6863e-02],
          [5.4675e-01, 7.5244e-01, 2.2651e-01, 6.9538e-01]]]]), 0.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_rgba at 0x7f8e789c9480>
trace_args = (tensor([[[[9.9202e-01, 8.0611e-01, 9.1731e-01, 2.8279e-01],
          [8.7525e-01, 9.3360e-01, 2.6379e-01, 2.5282e-01... [9.9090e-01, 7.5704e-01, 5.5419e-01, 4.6942e-01],
          [2.7005e-01, 7.5001e-01, 7.5574e-01, 4.5822e-01]]]]), 1.0)
trace_kwargs = {}
test_args = (tensor([[[[4.1841e-01, 9.2986e-01, 6.4936e-01, 4.3991e-01],
          [2.4616e-01, 3.8923e-01, 6.7901e-01, 6.6209e-01... [5.7396e-01, 7.0501e-01, 9.6914e-01, 5.6863e-02],
          [5.4675e-01, 7.5244e-01, 2.2651e-01, 6.9538e-01]]]]), 0.5)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_rgba at 0x7f8e789c9480>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.rgb_to_rgba
________________________________________________________________________________ test_rgba_to_rgb[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgba_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 4, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgba_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgba_to_rgb at 0x7f8e789c95a0>
trace_args = (tensor([[[[0.5532, 0.6591, 0.7844, 0.4487],
          [0.3970, 0.8068, 0.4592, 0.8346],
          [0.0095, 0.3526, 0...., 0.6661, 0.0907, 0.8264],
          [0.1718, 0.5554, 0.7564, 0.1816],
          [0.0546, 0.1003, 0.1985, 0.1749]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[2.2305e-01, 3.6254e-01, 9.5834e-01, 3.2006e-01],
          [1.6220e-01, 4.7442e-02, 5.4863e-02, 2.3695e-01...     [3.6732e-01, 7.1510e-01, 9.7727e-01, 8.9193e-01],
          [2.1308e-01, 2.4235e-01, 5.2418e-02, 1.2760e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgba_to_rgb at 0x7f8e789c95a0>
trace_args = (tensor([[[[0.5532, 0.6591, 0.7844, 0.4487],
          [0.3970, 0.8068, 0.4592, 0.8346],
          [0.0095, 0.3526, 0...., 0.6661, 0.0907, 0.8264],
          [0.1718, 0.5554, 0.7564, 0.1816],
          [0.0546, 0.1003, 0.1985, 0.1749]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[2.2305e-01, 3.6254e-01, 9.5834e-01, 3.2006e-01],
          [1.6220e-01, 4.7442e-02, 5.4863e-02, 2.3695e-01...     [3.6732e-01, 7.1510e-01, 9.7727e-01, 8.9193e-01],
          [2.1308e-01, 2.4235e-01, 5.2418e-02, 1.2760e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgba_to_rgb at 0x7f8e789c95a0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.rgba_to_rgb
________________________________________________________________________________ test_rgba_to_bgr[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgba_to_bgr(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 4, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgba_to_bgr,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgba_to_bgr at 0x7f8e789c9630>
trace_args = (tensor([[[[3.1690e-01, 7.4664e-01, 5.3848e-01, 8.5798e-01],
          [8.9270e-01, 6.4440e-01, 4.1024e-01, 6.6855e-02...     [9.7548e-01, 6.1601e-01, 2.2229e-01, 9.9740e-01],
          [2.9640e-01, 7.2964e-02, 5.9700e-01, 6.2603e-01]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[3.7070e-01, 3.9843e-01, 1.7073e-01, 7.0992e-01],
          [7.2516e-01, 7.8088e-01, 5.8208e-01, 5.7699e-01...     [4.4507e-01, 2.8617e-03, 4.3617e-01, 7.1675e-01],
          [9.5481e-01, 7.7540e-01, 2.6847e-01, 2.2907e-02]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgba_to_bgr at 0x7f8e789c9630>
trace_args = (tensor([[[[3.1690e-01, 7.4664e-01, 5.3848e-01, 8.5798e-01],
          [8.9270e-01, 6.4440e-01, 4.1024e-01, 6.6855e-02...     [9.7548e-01, 6.1601e-01, 2.2229e-01, 9.9740e-01],
          [2.9640e-01, 7.2964e-02, 5.9700e-01, 6.2603e-01]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[3.7070e-01, 3.9843e-01, 1.7073e-01, 7.0992e-01],
          [7.2516e-01, 7.8088e-01, 5.8208e-01, 5.7699e-01...     [4.4507e-01, 2.8617e-03, 4.3617e-01, 7.1675e-01],
          [9.5481e-01, 7.7540e-01, 2.6847e-01, 2.2907e-02]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgba_to_bgr at 0x7f8e789c9630>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.rgba_to_bgr
________________________________________________________________________________ test_rgb_to_hls[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_hls(target_framework, mode, backend_compile):
        # Note: We test this function with requires_grad=True,
        # because otherwise we simply get an empty_like tensor
        # with garbage values on each run leading to test failures
        trace_args = (
            torch.rand(1, 3, 4, 5).requires_grad_(True),
        )
        trace_kwargs = {'eps': 1e-8}
        test_args = (
            torch.rand(5, 3, 4, 5).requires_grad_(True),
        )
        test_kwargs = {'eps': 1e-8}
>       _test_function(
            kornia.color.rgb_to_hls,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_hls at 0x7f8e789c9ea0>
trace_args = (tensor([[[[0.9598, 0.8853, 0.1985, 0.3545, 0.2420],
          [0.9131, 0.2010, 0.5566, 0.7083, 0.4121],
          [0.... [0.3473, 0.7021, 0.9124, 0.6334, 0.7127],
          [0.5593, 0.9495, 0.9959, 0.2609, 0.3504]]]], requires_grad=True),)
trace_kwargs = {'eps': 1e-08}
test_args = (tensor([[[[0.5077, 0.1132, 0.7981, 0.1459, 0.0043],
          [0.2937, 0.8238, 0.0951, 0.1753, 0.7117],
          [0.... [0.3563, 0.0324, 0.0604, 0.6601, 0.3949],
          [0.5635, 0.0734, 0.3558, 0.8520, 0.7139]]]], requires_grad=True),)
test_kwargs = {'eps': 1e-08}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_hls at 0x7f8e789c9ea0>
trace_args = (tensor([[[[0.9598, 0.8853, 0.1985, 0.3545, 0.2420],
          [0.9131, 0.2010, 0.5566, 0.7083, 0.4121],
          [0.... [0.3473, 0.7021, 0.9124, 0.6334, 0.7127],
          [0.5593, 0.9495, 0.9959, 0.2609, 0.3504]]]], requires_grad=True),)
trace_kwargs = {'eps': 1e-08}
test_args = (tensor([[[[0.5077, 0.1132, 0.7981, 0.1459, 0.0043],
          [0.2937, 0.8238, 0.0951, 0.1753, 0.7117],
          [0.... [0.3563, 0.0324, 0.0604, 0.6601, 0.3949],
          [0.5635, 0.0734, 0.3558, 0.8520, 0.7139]]]], requires_grad=True),)
test_kwargs = {'eps': 1e-08}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_hls at 0x7f8e789c9ea0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.hls.rgb_to_hls
________________________________________________________________________________ test_hls_to_rgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_hls_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.hls_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function hls_to_rgb at 0x7f8e789ca170>
trace_args = (tensor([[[[0.7040, 0.7323, 0.4786, 0.6519, 0.2602],
          [0.1434, 0.3097, 0.8663, 0.2889, 0.4921],
          [0...., 0.5010],
          [0.4100, 0.6567, 0.8792, 0.1424, 0.9694],
          [0.7193, 0.1787, 0.6681, 0.7007, 0.2882]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.6990, 0.6278, 0.2324, 0.0285, 0.0708],
          [0.4711, 0.2205, 0.6405, 0.4743, 0.4216],
          [0...., 0.6702],
          [0.8847, 0.6849, 0.1002, 0.0105, 0.3981],
          [0.0620, 0.7992, 0.1498, 0.8365, 0.3411]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function hls_to_rgb at 0x7f8e789ca170>
trace_args = (tensor([[[[0.7040, 0.7323, 0.4786, 0.6519, 0.2602],
          [0.1434, 0.3097, 0.8663, 0.2889, 0.4921],
          [0...., 0.5010],
          [0.4100, 0.6567, 0.8792, 0.1424, 0.9694],
          [0.7193, 0.1787, 0.6681, 0.7007, 0.2882]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.6990, 0.6278, 0.2324, 0.0285, 0.0708],
          [0.4711, 0.2205, 0.6405, 0.4743, 0.4216],
          [0...., 0.6702],
          [0.8847, 0.6849, 0.1002, 0.0105, 0.3981],
          [0.0620, 0.7992, 0.1498, 0.8365, 0.3411]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function hls_to_rgb at 0x7f8e789ca170>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.hls.hls_to_rgb
________________________________________________________________________________ test_rgb_to_hsv[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_hsv(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {'eps': 1e-8}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {'eps': 1e-2}
>       _test_function(
            kornia.color.rgb_to_hsv,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_hsv at 0x7f8e789ca4d0>
trace_args = (tensor([[[[0.6784, 0.4299, 0.6917, 0.6032, 0.5820],
          [0.4913, 0.5664, 0.2386, 0.2934, 0.3318],
          [0...., 0.3529],
          [0.4103, 0.9266, 0.2147, 0.9971, 0.0842],
          [0.9780, 0.3873, 0.0026, 0.3733, 0.8137]]]]),)
trace_kwargs = {'eps': 1e-08}
test_args = (tensor([[[[0.9798, 0.2676, 0.7148, 0.5599, 0.5156],
          [0.8998, 0.7182, 0.9251, 0.8192, 0.7175],
          [0...., 0.0754],
          [0.8434, 0.3517, 0.0909, 0.1786, 0.3421],
          [0.4310, 0.6253, 0.7387, 0.6736, 0.1320]]]]),)
test_kwargs = {'eps': 0.01}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_hsv at 0x7f8e789ca4d0>
trace_args = (tensor([[[[0.6784, 0.4299, 0.6917, 0.6032, 0.5820],
          [0.4913, 0.5664, 0.2386, 0.2934, 0.3318],
          [0...., 0.3529],
          [0.4103, 0.9266, 0.2147, 0.9971, 0.0842],
          [0.9780, 0.3873, 0.0026, 0.3733, 0.8137]]]]),)
trace_kwargs = {'eps': 1e-08}
test_args = (tensor([[[[0.9798, 0.2676, 0.7148, 0.5599, 0.5156],
          [0.8998, 0.7182, 0.9251, 0.8192, 0.7175],
          [0...., 0.0754],
          [0.8434, 0.3517, 0.0909, 0.1786, 0.3421],
          [0.4310, 0.6253, 0.7387, 0.6736, 0.1320]]]]),)
test_kwargs = {'eps': 0.01}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_hsv at 0x7f8e789ca4d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.hsv.rgb_to_hsv
________________________________________________________________________________ test_hsv_to_rgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_hsv_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.hsv_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function hsv_to_rgb at 0x7f8e789ca560>
trace_args = (tensor([[[[0.7540, 0.4050, 0.8195, 0.7636, 0.2479],
          [0.0266, 0.0242, 0.0372, 0.1074, 0.2268],
          [0...., 0.6213],
          [0.4881, 0.0849, 0.8823, 0.7366, 0.5431],
          [0.4921, 0.2252, 0.9920, 0.6225, 0.5875]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[9.0976e-01, 9.5902e-01, 7.6384e-01, 4.6712e-01, 4.0626e-01],
          [2.4779e-01, 7.9151e-01, 7.3054e-02...e-01, 6.7015e-02, 7.7522e-02, 4.3177e-01],
          [5.1525e-01, 1.5087e-01, 3.3138e-01, 8.6426e-01, 9.0389e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function hsv_to_rgb at 0x7f8e789ca560>
trace_args = (tensor([[[[0.7540, 0.4050, 0.8195, 0.7636, 0.2479],
          [0.0266, 0.0242, 0.0372, 0.1074, 0.2268],
          [0...., 0.6213],
          [0.4881, 0.0849, 0.8823, 0.7366, 0.5431],
          [0.4921, 0.2252, 0.9920, 0.6225, 0.5875]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[9.0976e-01, 9.5902e-01, 7.6384e-01, 4.6712e-01, 4.0626e-01],
          [2.4779e-01, 7.9151e-01, 7.3054e-02...e-01, 6.7015e-02, 7.7522e-02, 4.3177e-01],
          [5.1525e-01, 1.5087e-01, 3.3138e-01, 8.6426e-01, 9.0389e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function hsv_to_rgb at 0x7f8e789ca560>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.hsv.hsv_to_rgb
________________________________________________________________________________ test_rgb_to_luv[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_luv(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {
            'eps': 1e-12
        }
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {
            'eps': 1e-12
        }
>       _test_function(
            kornia.color.rgb_to_luv,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:383: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_luv at 0x7f8e789caa70>
trace_args = (tensor([[[[0.2160, 0.6152, 0.1044, 0.8232, 0.0116],
          [0.1061, 0.8622, 0.8276, 0.6611, 0.7602],
          [0...., 0.6588],
          [0.8427, 0.0771, 0.0843, 0.5337, 0.5065],
          [0.0151, 0.4792, 0.6457, 0.3143, 0.9369]]]]),)
trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[[[0.2139, 0.9485, 0.2070, 0.6442, 0.4059],
          [0.4286, 0.1412, 0.4627, 0.1437, 0.5601],
          [0...., 0.2311],
          [0.0111, 0.4116, 0.8367, 0.3311, 0.2430],
          [0.9275, 0.7215, 0.5566, 0.8063, 0.7052]]]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_luv at 0x7f8e789caa70>
trace_args = (tensor([[[[0.2160, 0.6152, 0.1044, 0.8232, 0.0116],
          [0.1061, 0.8622, 0.8276, 0.6611, 0.7602],
          [0...., 0.6588],
          [0.8427, 0.0771, 0.0843, 0.5337, 0.5065],
          [0.0151, 0.4792, 0.6457, 0.3143, 0.9369]]]]),)
trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[[[0.2139, 0.9485, 0.2070, 0.6442, 0.4059],
          [0.4286, 0.1412, 0.4627, 0.1437, 0.5601],
          [0...., 0.2311],
          [0.0111, 0.4116, 0.8367, 0.3311, 0.2430],
          [0.9275, 0.7215, 0.5566, 0.8063, 0.7052]]]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_luv at 0x7f8e789caa70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.luv.rgb_to_luv
________________________________________________________________________________ test_luv_to_rgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_luv_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {'eps': 1e-12}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {'eps': 1e-12}
>       _test_function(
            kornia.color.luv_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:405: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function luv_to_rgb at 0x7f8e789cad40>
trace_args = (tensor([[[[0.6843, 0.2225, 0.4882, 0.9915, 0.9624],
          [0.6117, 0.9476, 0.8993, 0.0523, 0.1146],
          [0...., 0.7484],
          [0.8131, 0.6006, 0.8464, 0.0254, 0.7019],
          [0.9895, 0.2466, 0.9520, 0.0910, 0.6699]]]]),)
trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[[[7.6947e-01, 8.2887e-01, 8.0083e-01, 2.3012e-01, 9.2056e-01],
          [2.3210e-01, 9.9610e-02, 4.9629e-01...e-01, 8.5354e-01, 1.4235e-01, 8.2396e-01],
          [9.4225e-01, 3.9142e-02, 8.4274e-01, 6.2733e-01, 6.6916e-01]]]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function luv_to_rgb at 0x7f8e789cad40>
trace_args = (tensor([[[[0.6843, 0.2225, 0.4882, 0.9915, 0.9624],
          [0.6117, 0.9476, 0.8993, 0.0523, 0.1146],
          [0...., 0.7484],
          [0.8131, 0.6006, 0.8464, 0.0254, 0.7019],
          [0.9895, 0.2466, 0.9520, 0.0910, 0.6699]]]]),)
trace_kwargs = {'eps': 1e-12}
test_args = (tensor([[[[7.6947e-01, 8.2887e-01, 8.0083e-01, 2.3012e-01, 9.2056e-01],
          [2.3210e-01, 9.9610e-02, 4.9629e-01...e-01, 8.5354e-01, 1.4235e-01, 8.2396e-01],
          [9.4225e-01, 3.9142e-02, 8.4274e-01, 6.2733e-01, 6.6916e-01]]]]),)
test_kwargs = {'eps': 1e-12}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function luv_to_rgb at 0x7f8e789cad40>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.luv.luv_to_rgb
________________________________________________________________________________ test_rgb_to_lab[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_lab(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_lab,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_lab at 0x7f8e789ca5f0>
trace_args = (tensor([[[[0.1017, 0.2105, 0.4823, 0.3459, 0.2550],
          [0.5759, 0.4238, 0.7584, 0.5347, 0.3008],
          [0...., 0.6970],
          [0.2871, 0.1708, 0.3005, 0.3714, 0.4021],
          [0.8937, 0.5698, 0.1886, 0.9182, 0.6045]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.1957, 0.6797, 0.4630, 0.5191, 0.1377],
          [0.7572, 0.0711, 0.6460, 0.4461, 0.3796],
          [0...., 0.5619],
          [0.4844, 0.4107, 0.5509, 0.8378, 0.3694],
          [0.8446, 0.8229, 0.8829, 0.7502, 0.4288]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_lab at 0x7f8e789ca5f0>
trace_args = (tensor([[[[0.1017, 0.2105, 0.4823, 0.3459, 0.2550],
          [0.5759, 0.4238, 0.7584, 0.5347, 0.3008],
          [0...., 0.6970],
          [0.2871, 0.1708, 0.3005, 0.3714, 0.4021],
          [0.8937, 0.5698, 0.1886, 0.9182, 0.6045]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.1957, 0.6797, 0.4630, 0.5191, 0.1377],
          [0.7572, 0.0711, 0.6460, 0.4461, 0.3796],
          [0...., 0.5619],
          [0.4844, 0.4107, 0.5509, 0.8378, 0.3694],
          [0.8446, 0.8229, 0.8829, 0.7502, 0.4288]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_lab at 0x7f8e789ca5f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.lab.rgb_to_lab
________________________________________________________________________________ test_lab_to_rgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_lab_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {'clip': True}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {'clip': True}
>       _test_function(
            kornia.color.lab_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function lab_to_rgb at 0x7f8e789ca830>
trace_args = (tensor([[[[0.8012, 0.0484, 0.4906, 0.8255, 0.5850],
          [0.0872, 0.3813, 0.4119, 0.8638, 0.2143],
          [0...., 0.9976],
          [0.3880, 0.9606, 0.0875, 0.7403, 0.8877],
          [0.7037, 0.2583, 0.0727, 0.3295, 0.4940]]]]),)
trace_kwargs = {'clip': True}
test_args = (tensor([[[[0.8125, 0.1347, 0.6469, 0.9210, 0.9354],
          [0.1945, 0.4949, 0.6947, 0.9893, 0.0407],
          [0...., 0.1720],
          [0.9977, 0.7542, 0.4968, 0.3601, 0.5714],
          [0.7267, 0.3107, 0.6343, 0.4664, 0.5586]]]]),)
test_kwargs = {'clip': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function lab_to_rgb at 0x7f8e789ca830>
trace_args = (tensor([[[[0.8012, 0.0484, 0.4906, 0.8255, 0.5850],
          [0.0872, 0.3813, 0.4119, 0.8638, 0.2143],
          [0...., 0.9976],
          [0.3880, 0.9606, 0.0875, 0.7403, 0.8877],
          [0.7037, 0.2583, 0.0727, 0.3295, 0.4940]]]]),)
trace_kwargs = {'clip': True}
test_args = (tensor([[[[0.8125, 0.1347, 0.6469, 0.9210, 0.9354],
          [0.1945, 0.4949, 0.6947, 0.9893, 0.0407],
          [0...., 0.1720],
          [0.9977, 0.7542, 0.4968, 0.3601, 0.5714],
          [0.7267, 0.3107, 0.6343, 0.4664, 0.5586]]]]),)
test_kwargs = {'clip': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function lab_to_rgb at 0x7f8e789ca830>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.lab.lab_to_rgb
_______________________________________________________________________________ test_rgb_to_ycbcr[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_ycbcr(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_ycbcr,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_ycbcr at 0x7f8e789cb7f0>
trace_args = (tensor([[[[0.7008, 0.6030, 0.3860, 0.8185, 0.0120],
          [0.2190, 0.4322, 0.8172, 0.8377, 0.3028],
          [0...., 0.8359],
          [0.8647, 0.1150, 0.3131, 0.6256, 0.0944],
          [0.8115, 0.2712, 0.2964, 0.2279, 0.6479]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[2.8036e-01, 8.9576e-01, 8.8600e-01, 3.2393e-01, 9.7194e-01],
          [4.7899e-01, 8.3363e-01, 1.2903e-01...e-01, 2.0218e-01, 7.2767e-01, 8.7402e-01],
          [5.4746e-01, 3.9561e-01, 8.2140e-01, 7.3981e-01, 5.8644e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_ycbcr at 0x7f8e789cb7f0>
trace_args = (tensor([[[[0.7008, 0.6030, 0.3860, 0.8185, 0.0120],
          [0.2190, 0.4322, 0.8172, 0.8377, 0.3028],
          [0...., 0.8359],
          [0.8647, 0.1150, 0.3131, 0.6256, 0.0944],
          [0.8115, 0.2712, 0.2964, 0.2279, 0.6479]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[2.8036e-01, 8.9576e-01, 8.8600e-01, 3.2393e-01, 9.7194e-01],
          [4.7899e-01, 8.3363e-01, 1.2903e-01...e-01, 2.0218e-01, 7.2767e-01, 8.7402e-01],
          [5.4746e-01, 3.9561e-01, 8.2140e-01, 7.3981e-01, 5.8644e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_ycbcr at 0x7f8e789cb7f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.ycbcr.rgb_to_ycbcr
_______________________________________________________________________________ test_ycbcr_to_rgb[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ycbcr_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.ycbcr_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function ycbcr_to_rgb at 0x7f8e789cb910>
trace_args = (tensor([[[[0.5495, 0.6034, 0.6275, 0.4585, 0.1614],
          [0.4903, 0.0524, 0.0496, 0.3663, 0.7136],
          [0...., 0.0884],
          [0.3803, 0.2132, 0.1699, 0.9080, 0.3120],
          [0.5430, 0.0901, 0.4453, 0.8817, 0.1874]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.5303, 0.0062, 0.7823, 0.9169, 0.3913],
          [0.6442, 0.0233, 0.0338, 0.0323, 0.8965],
          [0...., 0.4054],
          [0.3843, 0.0867, 0.7203, 0.6259, 0.6134],
          [0.6384, 0.4497, 0.7793, 0.5593, 0.9323]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function ycbcr_to_rgb at 0x7f8e789cb910>
trace_args = (tensor([[[[0.5495, 0.6034, 0.6275, 0.4585, 0.1614],
          [0.4903, 0.0524, 0.0496, 0.3663, 0.7136],
          [0...., 0.0884],
          [0.3803, 0.2132, 0.1699, 0.9080, 0.3120],
          [0.5430, 0.0901, 0.4453, 0.8817, 0.1874]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.5303, 0.0062, 0.7823, 0.9169, 0.3913],
          [0.6442, 0.0233, 0.0338, 0.0323, 0.8965],
          [0...., 0.4054],
          [0.3843, 0.0867, 0.7203, 0.6259, 0.6134],
          [0.6384, 0.4497, 0.7793, 0.5593, 0.9323]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function ycbcr_to_rgb at 0x7f8e789cb910>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.ycbcr.ycbcr_to_rgb
________________________________________________________________________________ test_rgb_to_yuv[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_yuv(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_yuv,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:515: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_yuv at 0x7f8e789cbb50>
trace_args = (tensor([[[[0.8547, 0.8049, 0.5285, 0.9241, 0.6785],
          [0.1799, 0.3643, 0.1091, 0.9686, 0.7203],
          [0...., 0.0859],
          [0.4646, 0.3183, 0.9272, 0.8966, 0.6378],
          [0.8413, 0.1603, 0.1258, 0.8898, 0.7160]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.4627, 0.7493, 0.8298, 0.9277, 0.0124],
          [0.3619, 0.0063, 0.8103, 0.7057, 0.4273],
          [0...., 0.5811],
          [0.1099, 0.9056, 0.1034, 0.9137, 0.8928],
          [0.5767, 0.2467, 0.4328, 0.1714, 0.4920]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_yuv at 0x7f8e789cbb50>
trace_args = (tensor([[[[0.8547, 0.8049, 0.5285, 0.9241, 0.6785],
          [0.1799, 0.3643, 0.1091, 0.9686, 0.7203],
          [0...., 0.0859],
          [0.4646, 0.3183, 0.9272, 0.8966, 0.6378],
          [0.8413, 0.1603, 0.1258, 0.8898, 0.7160]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.4627, 0.7493, 0.8298, 0.9277, 0.0124],
          [0.3619, 0.0063, 0.8103, 0.7057, 0.4273],
          [0...., 0.5811],
          [0.1099, 0.9056, 0.1034, 0.9137, 0.8928],
          [0.5767, 0.2467, 0.4328, 0.1714, 0.4920]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_yuv at 0x7f8e789cbb50>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.rgb_to_yuv
________________________________________________________________________________ test_yuv_to_rgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_yuv_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.yuv_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:537: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function yuv_to_rgb at 0x7f8e789cbd00>
trace_args = (tensor([[[[0.3838, 0.2221, 0.6117, 0.6560, 0.4209],
          [0.8878, 0.4928, 0.1844, 0.9707, 0.6957],
          [0...., 0.5982],
          [0.2896, 0.6534, 0.3698, 0.1247, 0.9164],
          [0.8461, 0.6812, 0.4287, 0.5920, 0.4607]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.1169, 0.2917, 0.2865, 0.7742, 0.1491],
          [0.6098, 0.0949, 0.2757, 0.5671, 0.2576],
          [0...., 0.1121],
          [0.8557, 0.2400, 0.7209, 0.3510, 0.7045],
          [0.1141, 0.2338, 0.7712, 0.5859, 0.1825]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function yuv_to_rgb at 0x7f8e789cbd00>
trace_args = (tensor([[[[0.3838, 0.2221, 0.6117, 0.6560, 0.4209],
          [0.8878, 0.4928, 0.1844, 0.9707, 0.6957],
          [0...., 0.5982],
          [0.2896, 0.6534, 0.3698, 0.1247, 0.9164],
          [0.8461, 0.6812, 0.4287, 0.5920, 0.4607]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.1169, 0.2917, 0.2865, 0.7742, 0.1491],
          [0.6098, 0.0949, 0.2757, 0.5671, 0.2576],
          [0...., 0.1121],
          [0.8557, 0.2400, 0.7209, 0.3510, 0.7045],
          [0.1141, 0.2338, 0.7712, 0.5859, 0.1825]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function yuv_to_rgb at 0x7f8e789cbd00>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.yuv_to_rgb
_______________________________________________________________________________ test_rgb_to_yuv420[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_yuv420(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 6),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 4, 6),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_yuv420,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_yuv420 at 0x7f8e789cbbe0>
trace_args = (tensor([[[[2.3261e-01, 1.5935e-02, 7.6423e-01, 2.7263e-01, 7.7991e-01,
           2.5775e-01],
          [6.7794e-01,...       1.3722e-01],
          [9.0456e-01, 6.6665e-01, 4.2367e-04, 2.2534e-01, 3.0160e-01,
           7.8154e-01]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.9645, 0.5466, 0.0039, 0.8097, 0.5773, 0.9015],
          [0.9219, 0.4941, 0.4041, 0.0501, 0.0393, 0.5747...     [0.3621, 0.1306, 0.0810, 0.0647, 0.8585, 0.5015],
          [0.7433, 0.4378, 0.2917, 0.8755, 0.2680, 0.9124]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_yuv420 at 0x7f8e789cbbe0>
trace_args = (tensor([[[[2.3261e-01, 1.5935e-02, 7.6423e-01, 2.7263e-01, 7.7991e-01,
           2.5775e-01],
          [6.7794e-01,...       1.3722e-01],
          [9.0456e-01, 6.6665e-01, 4.2367e-04, 2.2534e-01, 3.0160e-01,
           7.8154e-01]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.9645, 0.5466, 0.0039, 0.8097, 0.5773, 0.9015],
          [0.9219, 0.4941, 0.4041, 0.0501, 0.0393, 0.5747...     [0.3621, 0.1306, 0.0810, 0.0647, 0.8585, 0.5015],
          [0.7433, 0.4378, 0.2917, 0.8755, 0.2680, 0.9124]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_yuv420 at 0x7f8e789cbbe0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.rgb_to_yuv420
_______________________________________________________________________________ test_yuv420_to_rgb[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_yuv420_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 4, 6),
            torch.rand(1, 2, 2, 3) * 2.0 - 0.5,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 4, 6),
            torch.rand(5, 2, 2, 3) * 2.0 - 0.5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.yuv420_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:583: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function yuv420_to_rgb at 0x7f8e789cbd90>
trace_args = (tensor([[[[0.2009, 0.5439, 0.7814, 0.3072, 0.5594, 0.0732],
          [0.1201, 0.8682, 0.6021, 0.9123, 0.6437, 0.2367...       [-0.2335,  0.0740, -0.2988]],

         [[ 0.1624,  0.5468,  1.2533],
          [ 0.7249,  0.5486,  0.9549]]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.9240, 0.3144, 0.9730, 0.6591, 0.5788, 0.4285],
          [0.9030, 0.6904, 0.2697, 0.8638, 0.2584, 0.9593...       [ 1.0645, -0.2306, -0.2936]],

         [[-0.4154,  0.7116,  1.2146],
          [-0.0757,  0.3537,  0.8353]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function yuv420_to_rgb at 0x7f8e789cbd90>
trace_args = (tensor([[[[0.2009, 0.5439, 0.7814, 0.3072, 0.5594, 0.0732],
          [0.1201, 0.8682, 0.6021, 0.9123, 0.6437, 0.2367...       [-0.2335,  0.0740, -0.2988]],

         [[ 0.1624,  0.5468,  1.2533],
          [ 0.7249,  0.5486,  0.9549]]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.9240, 0.3144, 0.9730, 0.6591, 0.5788, 0.4285],
          [0.9030, 0.6904, 0.2697, 0.8638, 0.2584, 0.9593...       [ 1.0645, -0.2306, -0.2936]],

         [[-0.4154,  0.7116,  1.2146],
          [-0.0757,  0.3537,  0.8353]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function yuv420_to_rgb at 0x7f8e789cbd90>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.yuv420_to_rgb
_______________________________________________________________________________ test_rgb_to_yuv422[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_yuv422(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 6, 8),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 6, 8),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_yuv422,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_yuv422 at 0x7f8e789cbc70>
trace_args = (tensor([[[[0.8706, 0.5135, 0.8346, 0.3138, 0.5187, 0.5735, 0.2244, 0.9573],
          [0.4412, 0.3041, 0.6244, 0.8127...3823, 0.9005, 0.0804, 0.8327, 0.5492],
          [0.5888, 0.5807, 0.4490, 0.2881, 0.6267, 0.8622, 0.5626, 0.8856]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.5224, 0.7885, 0.3997, 0.9131, 0.1648, 0.9090, 0.3447, 0.8825],
          [0.2235, 0.7379, 0.0461, 0.5451...1158, 0.3409, 0.5407, 0.1350, 0.2319],
          [0.7665, 0.4797, 0.8341, 0.0950, 0.3358, 0.5061, 0.4347, 0.3916]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_yuv422 at 0x7f8e789cbc70>
trace_args = (tensor([[[[0.8706, 0.5135, 0.8346, 0.3138, 0.5187, 0.5735, 0.2244, 0.9573],
          [0.4412, 0.3041, 0.6244, 0.8127...3823, 0.9005, 0.0804, 0.8327, 0.5492],
          [0.5888, 0.5807, 0.4490, 0.2881, 0.6267, 0.8622, 0.5626, 0.8856]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.5224, 0.7885, 0.3997, 0.9131, 0.1648, 0.9090, 0.3447, 0.8825],
          [0.2235, 0.7379, 0.0461, 0.5451...1158, 0.3409, 0.5407, 0.1350, 0.2319],
          [0.7665, 0.4797, 0.8341, 0.0950, 0.3358, 0.5061, 0.4347, 0.3916]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_yuv422 at 0x7f8e789cbc70>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.rgb_to_yuv422
_______________________________________________________________________________ test_yuv422_to_rgb[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_yuv422_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 2, 6),
            torch.rand(1, 2, 2, 3) - 0.5,
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 2, 6),
            torch.rand(5, 2, 2, 3) - 0.5,
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.yuv422_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function yuv422_to_rgb at 0x7f8e789cbe20>
trace_args = (tensor([[[[0.8479, 0.5580, 0.3110, 0.8497, 0.0947, 0.8494],
          [0.8268, 0.5155, 0.1912, 0.0524, 0.3844, 0.9762...       [ 0.3941,  0.0212,  0.0378]],

         [[ 0.0451, -0.0231, -0.1736],
          [ 0.3743,  0.0764,  0.3864]]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.2777, 0.0957, 0.8674, 0.3706, 0.8422, 0.3207],
          [0.5634, 0.0457, 0.5081, 0.4798, 0.1687, 0.5128...       [-0.3295, -0.0542, -0.2801]],

         [[ 0.4400, -0.2513,  0.2726],
          [ 0.0858, -0.1880,  0.4201]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function yuv422_to_rgb at 0x7f8e789cbe20>
trace_args = (tensor([[[[0.8479, 0.5580, 0.3110, 0.8497, 0.0947, 0.8494],
          [0.8268, 0.5155, 0.1912, 0.0524, 0.3844, 0.9762...       [ 0.3941,  0.0212,  0.0378]],

         [[ 0.0451, -0.0231, -0.1736],
          [ 0.3743,  0.0764,  0.3864]]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.2777, 0.0957, 0.8674, 0.3706, 0.8422, 0.3207],
          [0.5634, 0.0457, 0.5081, 0.4798, 0.1687, 0.5128...       [-0.3295, -0.0542, -0.2801]],

         [[ 0.4400, -0.2513,  0.2726],
          [ 0.0858, -0.1880,  0.4201]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function yuv422_to_rgb at 0x7f8e789cbe20>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.yuv422_to_rgb
________________________________________________________________________________ test_rgb_to_xyz[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_xyz(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.rgb_to_xyz,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:651: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_xyz at 0x7f8e789ca950>
trace_args = (tensor([[[[0.5462, 0.5374, 0.5101, 0.4473, 0.1788],
          [0.9543, 0.4849, 0.7325, 0.3302, 0.8875],
          [0...., 0.9816],
          [0.5421, 0.9491, 0.1154, 0.0051, 0.4251],
          [0.8259, 0.0827, 0.1924, 0.2913, 0.6368]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[6.9360e-01, 2.9219e-01, 9.8500e-01, 5.2391e-01, 4.4439e-01],
          [1.8740e-02, 6.2713e-01, 1.8487e-01...e-01, 9.1520e-01, 4.8502e-01, 5.2435e-01],
          [4.0658e-01, 8.8471e-01, 3.0235e-01, 2.1413e-01, 6.3858e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rgb_to_xyz at 0x7f8e789ca950>
trace_args = (tensor([[[[0.5462, 0.5374, 0.5101, 0.4473, 0.1788],
          [0.9543, 0.4849, 0.7325, 0.3302, 0.8875],
          [0...., 0.9816],
          [0.5421, 0.9491, 0.1154, 0.0051, 0.4251],
          [0.8259, 0.0827, 0.1924, 0.2913, 0.6368]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[6.9360e-01, 2.9219e-01, 9.8500e-01, 5.2391e-01, 4.4439e-01],
          [1.8740e-02, 6.2713e-01, 1.8487e-01...e-01, 9.1520e-01, 4.8502e-01, 5.2435e-01],
          [4.0658e-01, 8.8471e-01, 3.0235e-01, 2.1413e-01, 6.3858e-01]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rgb_to_xyz at 0x7f8e789ca950>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.xyz.rgb_to_xyz
________________________________________________________________________________ test_xyz_to_rgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_xyz_to_rgb(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 5, 5),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3, 5, 5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.color.xyz_to_rgb,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:673: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function xyz_to_rgb at 0x7f8e789ca9e0>
trace_args = (tensor([[[[0.1292, 0.3122, 0.9940, 0.4028, 0.6194],
          [0.8937, 0.7557, 0.6215, 0.6302, 0.5405],
          [0...., 0.1221],
          [0.5459, 0.6738, 0.0493, 0.5872, 0.3095],
          [0.1285, 0.7887, 0.7181, 0.7092, 0.8076]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.6442, 0.8529, 0.7264, 0.4849, 0.2800],
          [0.0552, 0.2505, 0.0956, 0.7218, 0.3973],
          [0...., 0.6150],
          [0.5822, 0.2687, 0.6213, 0.0123, 0.7632],
          [0.2144, 0.1440, 0.5375, 0.4014, 0.2087]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function xyz_to_rgb at 0x7f8e789ca9e0>
trace_args = (tensor([[[[0.1292, 0.3122, 0.9940, 0.4028, 0.6194],
          [0.8937, 0.7557, 0.6215, 0.6302, 0.5405],
          [0...., 0.1221],
          [0.5459, 0.6738, 0.0493, 0.5872, 0.3095],
          [0.1285, 0.7887, 0.7181, 0.7092, 0.8076]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.6442, 0.8529, 0.7264, 0.4849, 0.2800],
          [0.0552, 0.2505, 0.0956, 0.7218, 0.3973],
          [0...., 0.6150],
          [0.5822, 0.2687, 0.6213, 0.0123, 0.7632],
          [0.2144, 0.1440, 0.5375, 0.4014, 0.2087]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function xyz_to_rgb at 0x7f8e789ca9e0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.xyz.xyz_to_rgb
________________________________________________________________________________ test_rgb_to_raw[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rgb_to_raw(target_framework, mode, backend_compile):
        print("kornia.color.rgb_to_raw")
    
>       TranspiledCFA = ivy.transpile(kornia.color.CFA, source="torch", target=target_framework)

kornia/test_color.py:689: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <enum 'CFA'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb_to_raw
________________________________________________________________________________ test_raw_to_rgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_raw_to_rgb(target_framework, mode, backend_compile):
        print("kornia.color.raw_to_rgb")
    
>       transpiled_raw_to_rgb = ivy.transpile(kornia.color.raw_to_rgb, source="torch", target=target_framework)

kornia/test_color.py:704: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function raw_to_rgb at 0x7f8e789cadd0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.raw_to_rgb
_________________________________________________________________________ test_raw_to_rgb_2x2_downscaled[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_raw_to_rgb_2x2_downscaled(target_framework, mode, backend_compile):
        print("kornia.color.raw_to_rgb_2x2_downscaled")
    
>       transpiled_raw_to_rgb_2x2_downscaled = ivy.transpile(kornia.color.raw_to_rgb_2x2_downscaled, source="torch", target=target_framework)

kornia/test_color.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function raw_to_rgb_2x2_downscaled at 0x7f8e789cb010>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.raw_to_rgb_2x2_downscaled
___________________________________________________________________________________ test_sepia[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_sepia(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 3, 4, 4),
        )
        trace_kwargs = {
            'rescale': True,
            'eps': 1e-6,
        }
        test_args = (
            torch.rand(5, 3, 4, 4),
        )
        test_kwargs = {
            'rescale': True,
            'eps': 1e-6,
        }
>       _test_function(
            kornia.color.sepia,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_color.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function sepia_from_rgb at 0x7f8e789cb490>
trace_args = (tensor([[[[0.5218, 0.2214, 0.8396, 0.7086],
          [0.5858, 0.6433, 0.9304, 0.7488],
          [0.9438, 0.2340, 0...., 0.2094, 0.0333, 0.9010],
          [0.8185, 0.3648, 0.5095, 0.1691],
          [0.9443, 0.5696, 0.9466, 0.5756]]]]),)
trace_kwargs = {'eps': 1e-06, 'rescale': True}
test_args = (tensor([[[[0.3840, 0.6106, 0.6796, 0.2552],
          [0.2646, 0.2670, 0.9019, 0.3541],
          [0.3182, 0.5405, 0...., 0.8570, 0.2227, 0.4395],
          [0.4551, 0.0757, 0.3385, 0.8867],
          [0.3522, 0.7489, 0.2359, 0.1553]]]]),)
test_kwargs = {'eps': 1e-06, 'rescale': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function sepia_from_rgb at 0x7f8e789cb490>
trace_args = (tensor([[[[0.5218, 0.2214, 0.8396, 0.7086],
          [0.5858, 0.6433, 0.9304, 0.7488],
          [0.9438, 0.2340, 0...., 0.2094, 0.0333, 0.9010],
          [0.8185, 0.3648, 0.5095, 0.1691],
          [0.9443, 0.5696, 0.9466, 0.5756]]]]),)
trace_kwargs = {'eps': 1e-06, 'rescale': True}
test_args = (tensor([[[[0.3840, 0.6106, 0.6796, 0.2552],
          [0.2646, 0.2670, 0.9019, 0.3541],
          [0.3182, 0.5405, 0...., 0.8570, 0.2227, 0.4395],
          [0.4551, 0.0757, 0.3385, 0.8867],
          [0.3522, 0.7489, 0.2359, 0.1553]]]]),)
test_kwargs = {'eps': 1e-06, 'rescale': True}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function sepia_from_rgb at 0x7f8e789cb490>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.sepia.sepia_from_rgb
______________________________________________________________________________ test_GrayscaleToRgb[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_GrayscaleToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(5, 1, 4, 4),
        )
>       _test_color_class(
            kornia.color.GrayscaleToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:763: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.gray.GrayscaleToRgb'>
args = (tensor([[[[0.8017, 0.0027, 0.4664, 0.6184],
          [0.2435, 0.4204, 0.1531, 0.5552],
          [0.8108, 0.4235, 0...., 0.0018, 0.9749, 0.8358],
          [0.7624, 0.8828, 0.8949, 0.6031],
          [0.7519, 0.2187, 0.9840, 0.2471]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.gray.GrayscaleToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.gray.GrayscaleToRgb
______________________________________________________________________________ test_RgbToGrayscale[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToGrayscale(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToGrayscale,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:776: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.gray.RgbToGrayscale'>
args = (tensor([[[[0.3846, 0.0575, 0.9188, 0.1898, 0.9365],
          [0.8309, 0.4946, 0.0154, 0.5472, 0.8818],
          [0...., 0.8398],
          [0.8977, 0.0270, 0.1760, 0.2350, 0.1279],
          [0.0526, 0.0392, 0.4352, 0.3664, 0.7110]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.gray.RgbToGrayscale'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.gray.RgbToGrayscale
______________________________________________________________________________ test_BgrToGrayscale[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_BgrToGrayscale(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.BgrToGrayscale,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.gray.BgrToGrayscale'>
args = (tensor([[[[0.1569, 0.3122, 0.7013, 0.8289, 0.7804],
          [0.0881, 0.4343, 0.6572, 0.7852, 0.3929],
          [0...., 0.8817],
          [0.1381, 0.7585, 0.7244, 0.6897, 0.7001],
          [0.5509, 0.2667, 0.7537, 0.7437, 0.9323]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.gray.BgrToGrayscale'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.gray.BgrToGrayscale
_________________________________________________________________________________ test_RgbToBgr[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToBgr(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToBgr,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.rgb.RgbToBgr'>
args = (tensor([[[[1.5346e-01, 5.3606e-01, 1.3284e-02, 2.4116e-01, 8.0137e-01],
          [1.6829e-01, 2.2728e-01, 8.2254e-01...e-01, 1.6544e-01, 4.8559e-01, 9.2300e-01],
          [3.8028e-01, 5.7147e-01, 4.7284e-01, 8.0233e-01, 8.4580e-01]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.rgb.RgbToBgr'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.RgbToBgr
_________________________________________________________________________________ test_BgrToRgb[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_BgrToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.BgrToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:815: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.rgb.BgrToRgb'>
args = (tensor([[[[5.2420e-02, 7.2691e-01, 7.0898e-01, 3.9567e-01, 8.9138e-01],
          [3.8512e-01, 8.9946e-01, 8.0024e-01...e-01, 9.2758e-01, 1.6820e-02, 3.8864e-01],
          [1.5369e-01, 7.7303e-01, 7.1857e-01, 7.7397e-01, 4.4682e-01]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.rgb.BgrToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.BgrToRgb
______________________________________________________________________________ test_LinearRgbToRgb[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LinearRgbToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.LinearRgbToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.rgb.LinearRgbToRgb'>
args = (tensor([[[[0.2717, 0.4754, 0.8572, 0.5817, 0.3587],
          [0.7834, 0.1610, 0.3766, 0.4349, 0.8629],
          [0...., 0.8876],
          [0.5521, 0.6917, 0.9071, 0.0303, 0.2995],
          [0.4223, 0.3569, 0.2101, 0.3560, 0.4499]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.rgb.LinearRgbToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.LinearRgbToRgb
______________________________________________________________________________ test_RgbToLinearRgb[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToLinearRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToLinearRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.rgb.RgbToLinearRgb'>
args = (tensor([[[[0.0704, 0.5666, 0.2844, 0.0746, 0.2280],
          [0.0763, 0.7661, 0.6398, 0.2244, 0.5738],
          [0...., 0.4654],
          [0.7366, 0.6289, 0.0404, 0.7439, 0.4456],
          [0.5815, 0.9540, 0.2546, 0.5776, 0.2634]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.rgb.RgbToLinearRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.RgbToLinearRgb
_________________________________________________________________________________ test_RgbToRgba[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToRgba(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToRgba,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            init_args=(1.,),
        )

kornia/test_color.py:854: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.rgb.RgbToRgba'>
args = (tensor([[[[0.0315, 0.4890, 0.0624, 0.1227, 0.9010],
          [0.9064, 0.7779, 0.8821, 0.9159, 0.1520],
          [0...., 0.6756],
          [0.9930, 0.5969, 0.1485, 0.0709, 0.4510],
          [0.6513, 0.4509, 0.8988, 0.1969, 0.2679]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = (1.0,)

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.rgb.RgbToRgba'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.RgbToRgba
_________________________________________________________________________________ test_BgrToRgba[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_BgrToRgba(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.BgrToRgba,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            init_args=(1.,),
        )

kornia/test_color.py:868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.rgb.BgrToRgba'>
args = (tensor([[[[0.7888, 0.2867, 0.2941, 0.4558, 0.4568],
          [0.6925, 0.5472, 0.5887, 0.9056, 0.2016],
          [0...., 0.5836],
          [0.3691, 0.4311, 0.7918, 0.6058, 0.5951],
          [0.3361, 0.1797, 0.9128, 0.2492, 0.6702]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = (1.0,)

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.rgb.BgrToRgba'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.BgrToRgba
_________________________________________________________________________________ test_RgbaToRgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbaToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 4, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbaToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:882: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.rgb.RgbaToRgb'>
args = (tensor([[[[3.0241e-01, 4.7569e-01, 1.1549e-03, 3.8112e-01, 9.7908e-01],
          [5.1369e-01, 8.3240e-01, 4.6359e-01...e-01, 3.6358e-01, 7.0884e-01, 2.3395e-01],
          [4.1527e-01, 4.1250e-01, 4.2972e-01, 2.5493e-01, 1.2459e-01]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.rgb.RgbaToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.RgbaToRgb
_________________________________________________________________________________ test_RgbaToBgr[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbaToBgr(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 4, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbaToBgr,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:895: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.rgb.RgbaToBgr'>
args = (tensor([[[[0.1717, 0.2478, 0.7986, 0.7472, 0.3919],
          [0.3856, 0.8674, 0.9357, 0.7349, 0.8510],
          [0...., 0.4369],
          [0.5819, 0.4779, 0.0306, 0.4798, 0.3170],
          [0.4572, 0.3827, 0.5937, 0.0555, 0.4178]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.rgb.RgbaToBgr'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.rgb.RgbaToBgr
_________________________________________________________________________________ test_RgbToHls[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToHls(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToHls,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:908: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.hls.RgbToHls'>
args = (tensor([[[[0.8241, 0.2568, 0.3695, 0.7696, 0.1648],
          [0.2680, 0.5376, 0.4409, 0.4600, 0.5723],
          [0...., 0.7606],
          [0.0390, 0.8638, 0.2073, 0.0425, 0.1859],
          [0.1211, 0.6311, 0.9043, 0.6667, 0.7763]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.hls.RgbToHls'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.hls.RgbToHls
_________________________________________________________________________________ test_HlsToRgb[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_HlsToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.HlsToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.hls.HlsToRgb'>
args = (tensor([[[[0.2738, 0.0978, 0.9731, 0.7176, 0.5477],
          [0.1535, 0.1403, 0.7432, 0.7399, 0.4342],
          [0...., 0.7639],
          [0.3108, 0.1354, 0.0611, 0.6277, 0.2151],
          [0.6015, 0.3887, 0.1747, 0.7852, 0.0774]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.hls.HlsToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.hls.HlsToRgb
_________________________________________________________________________________ test_RgbToHsv[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToHsv(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToHsv,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:934: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.hsv.RgbToHsv'>
args = (tensor([[[[0.1869, 0.6339, 0.6212, 0.0946, 0.8383],
          [0.1512, 0.4500, 0.9188, 0.4553, 0.5391],
          [0...., 0.0164],
          [0.7945, 0.8117, 0.8311, 0.8719, 0.5656],
          [0.2109, 0.8423, 0.6724, 0.5113, 0.0502]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.hsv.RgbToHsv'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.hsv.RgbToHsv
_________________________________________________________________________________ test_HsvToRgb[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_HsvToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.HsvToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:947: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.hsv.HsvToRgb'>
args = (tensor([[[[0.5426, 0.3171, 0.6066, 0.3384, 0.7233],
          [0.7385, 0.4131, 0.4071, 0.0013, 0.3845],
          [0...., 0.7008],
          [0.4697, 0.6600, 0.6595, 0.0085, 0.1866],
          [0.4614, 0.0569, 0.6560, 0.0768, 0.9309]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.hsv.HsvToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.hsv.HsvToRgb
_________________________________________________________________________________ test_RgbToLuv[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToLuv(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToLuv,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:960: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.luv.RgbToLuv'>
args = (tensor([[[[0.1633, 0.7463, 0.7671, 0.9924, 0.2310],
          [0.0611, 0.2109, 0.6497, 0.9296, 0.4491],
          [0...., 0.0922],
          [0.9227, 0.6383, 0.4300, 0.0075, 0.6837],
          [0.7893, 0.4038, 0.1847, 0.2823, 0.4106]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.luv.RgbToLuv'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.luv.RgbToLuv
_________________________________________________________________________________ test_LuvToRgb[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LuvToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.LuvToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:973: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.luv.LuvToRgb'>
args = (tensor([[[[0.3052, 0.8861, 0.6719, 0.1470, 0.9303],
          [0.5027, 0.2296, 0.8245, 0.6520, 0.4150],
          [0...., 0.6803],
          [0.6610, 0.8093, 0.9001, 0.2469, 0.6338],
          [0.0395, 0.9005, 0.4667, 0.7496, 0.3673]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.luv.LuvToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.luv.LuvToRgb
_________________________________________________________________________________ test_RgbToLab[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToLab(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToLab,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.lab.RgbToLab'>
args = (tensor([[[[0.7270, 0.3265, 0.2034, 0.0360, 0.1976],
          [0.5757, 0.9394, 0.4094, 0.9160, 0.5820],
          [0...., 0.5175],
          [0.8155, 0.6968, 0.0706, 0.3860, 0.1777],
          [0.2103, 0.2980, 0.2329, 0.4384, 0.3160]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.lab.RgbToLab'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.lab.RgbToLab
_________________________________________________________________________________ test_LabToRgb[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LabToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.LabToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:999: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.lab.LabToRgb'>
args = (tensor([[[[0.1583, 0.5253, 0.7726, 0.2422, 0.3682],
          [0.7451, 0.0143, 0.9603, 0.3545, 0.2601],
          [0...., 0.0108],
          [0.6000, 0.0291, 0.4306, 0.9627, 0.6084],
          [0.0374, 0.2436, 0.5444, 0.3316, 0.7498]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.lab.LabToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.lab.LabToRgb
________________________________________________________________________________ test_YcbcrToRgb[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_YcbcrToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.YcbcrToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:1012: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.ycbcr.YcbcrToRgb'>
args = (tensor([[[[0.8625, 0.5696, 0.1582, 0.3417, 0.0263],
          [0.5975, 0.2392, 0.6226, 0.5234, 0.6459],
          [0...., 0.0819],
          [0.3108, 0.6606, 0.1079, 0.3007, 0.2904],
          [0.2844, 0.3538, 0.5313, 0.9260, 0.7191]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.ycbcr.YcbcrToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.ycbcr.YcbcrToRgb
________________________________________________________________________________ test_RgbToYuv420[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToYuv420(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 6),
        )
>       _test_color_class(
            kornia.color.RgbToYuv420,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:1064: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.yuv.RgbToYuv420'>
args = (tensor([[[[0.3002, 0.7743, 0.0948, 0.5534, 0.9322, 0.4096],
          [0.8956, 0.6744, 0.5625, 0.7620, 0.8670, 0.0997...     [0.0605, 0.0242, 0.7226, 0.4013, 0.5349, 0.2721],
          [0.2811, 0.5217, 0.1478, 0.1016, 0.0548, 0.8657]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.yuv.RgbToYuv420'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.RgbToYuv420
________________________________________________________________________________ test_Yuv420ToRgb[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Yuv420ToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 1, 4, 6),
            torch.rand(2, 2, 2, 3),
        )
>       _test_color_class(
            kornia.color.Yuv420ToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:1078: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.yuv.Yuv420ToRgb'>
args = (tensor([[[[0.5180, 0.7325, 0.5972, 0.2525, 0.2918, 0.0576],
          [0.3473, 0.6950, 0.4246, 0.2486, 0.1116, 0.3260...674],
          [0.7550, 0.7883, 0.1061]],

         [[0.9833, 0.0363, 0.4841],
          [0.0297, 0.5138, 0.3348]]]]))
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.yuv.Yuv420ToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.Yuv420ToRgb
________________________________________________________________________________ test_RgbToYuv422[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToYuv422(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 6),
        )
>       _test_color_class(
            kornia.color.RgbToYuv422,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:1091: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.yuv.RgbToYuv422'>
args = (tensor([[[[0.7473, 0.5502, 0.3075, 0.0947, 0.4600, 0.8018],
          [0.4439, 0.8042, 0.4118, 0.3338, 0.6761, 0.9609...     [0.2571, 0.1582, 0.2407, 0.9694, 0.3696, 0.3455],
          [0.9329, 0.8710, 0.8108, 0.5810, 0.1487, 0.5835]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.yuv.RgbToYuv422'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.RgbToYuv422
________________________________________________________________________________ test_Yuv422ToRgb[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Yuv422ToRgb(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 1, 4, 6),
            torch.rand(2, 2, 4, 3),
        )
>       _test_color_class(
            kornia.color.Yuv422ToRgb,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:1105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.yuv.Yuv422ToRgb'>
args = (tensor([[[[0.4262, 0.9439, 0.6829, 0.7458, 0.1195, 0.0076],
          [0.2469, 0.6229, 0.5147, 0.7122, 0.5337, 0.5846....8836],
          [0.4154, 0.5967, 0.3312],
          [0.6673, 0.6029, 0.5166],
          [0.7080, 0.3845, 0.1622]]]]))
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.yuv.Yuv422ToRgb'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.yuv.Yuv422ToRgb
_________________________________________________________________________________ test_RgbToXyz[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToXyz(target_framework, mode, backend_compile):
        args = (
            torch.rand(2, 3, 4, 5),
        )
>       _test_color_class(
            kornia.color.RgbToXyz,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.xyz.RgbToXyz'>
args = (tensor([[[[0.4931, 0.0273, 0.7969, 0.7160, 0.3606],
          [0.3822, 0.2828, 0.8194, 0.8171, 0.6883],
          [0...., 0.4034],
          [0.3506, 0.7870, 0.9127, 0.2520, 0.5492],
          [0.5389, 0.6147, 0.0464, 0.1934, 0.1750]]]]),)
target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.xyz.RgbToXyz'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.xyz.RgbToXyz
_________________________________________________________________________________ test_RawToRgb[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RawToRgb(target_framework, mode, backend_compile):
        print("kornia.color.RawToRgb")
    
        transpiled_RawToRgb = ivy.transpile(kornia.color.RawToRgb, source="torch", target=target_framework)
        TranspiledCFA = ivy.transpile(kornia.color.CFA, source="torch", target=target_framework)
    
        torch_x = torch.rand(2, 1, 4, 6)
        transpiled_x = _array_to_new_backend(torch_x, target_framework)
    
        torch_out = kornia.color.RawToRgb(kornia.color.CFA.RG)(torch_x)
        transpiled_out = transpiled_RawToRgb(TranspiledCFA.RG)(transpiled_x)
    
>       _to_numpy_and_allclose(torch_out, transpiled_out)

kornia/test_color.py:1152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

torch_x = tensor([[[[0.5759, 0.5759, 0.3797, 0.1835, 0.5221, 0.8606],
          [0.5759, 0.5759, 0.3797, 0.1835, 0.5221, 0.8606]...       [0.5715, 0.4298, 0.2880, 0.2833, 0.2786, 0.2786],
          [0.5715, 0.4298, 0.2880, 0.2833, 0.2786, 0.2786]]]])
transpiled_x = <tf.Tensor: shape=(2, 3, 4, 6), dtype=float32, numpy=
array([[[[0.57594925, 0.57594925, 0.37973484, 0.23188657, 0.6188...61488],
         [0.57153726, 0.47028095, 0.30827084, 0.28331724, 0.27861488,
          0.27861488]]]], dtype=float32)>
tolerance = 0.001

    def _to_numpy_and_allclose(torch_x, transpiled_x, tolerance=1e-3):
        orig_data = _nest_array_to_numpy(torch_x)
        transpiled_data = _nest_array_to_numpy(transpiled_x)
>       _check_allclose(orig_data, transpiled_data, tolerance=tolerance)

helpers.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[[0.57594925, 0.57594925, 0.37973484, 0.18352044, 0.5220823 ,
          0.8606443 ],
         [0.57594925, 0.5...861488],
         [0.57153726, 0.42977846, 0.2880196 , 0.28331724, 0.27861488,
          0.27861488]]]], dtype=float32)
y = array([[[[0.57594925, 0.57594925, 0.37973484, 0.23188657, 0.61881447,
          0.8606443 ],
         [0.57594925, 0.5...861488],
         [0.57153726, 0.47028095, 0.30827084, 0.28331724, 0.27861488,
          0.27861488]]]], dtype=float32)
tolerance = 0.001

    def _check_allclose(x, y, tolerance=1e-3):
        """
        Checks that all values are close. Any arrays must already be in numpy format, rather than native framework.
        """
    
        if isinstance(x, np.ndarray):
>           assert np.allclose(x, y, atol=tolerance), "numpy array values are not all close"
E           AssertionError: numpy array values are not all close

helpers.py:22: AssertionError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.RawToRgb

Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RawToRgb from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                   
Transpilation of RawToRgb complete.
_________________________________________________________________________________ test_RgbToRaw[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RgbToRaw(target_framework, mode, backend_compile):
        print("kornia.color.RgbToRaw")
    
>       transpiled_RgbToRaw = ivy.transpile(kornia.color.RgbToRaw, source="torch", target=target_framework)

kornia/test_color.py:1158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.raw.RgbToRaw'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.RgbToRaw
___________________________________________________________________________ test_RawToRgb2x2Downscaled[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RawToRgb2x2Downscaled(target_framework, mode, backend_compile):
        print("kornia.color.RawToRgb2x2Downscaled")
    
>       transpiled_RawToRgb2x2Downscaled = ivy.transpile(kornia.color.RawToRgb2x2Downscaled, source="torch", target=target_framework)

kornia/test_color.py:1173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.raw.RawToRgb2x2Downscaled'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.RawToRgb2x2Downscaled
___________________________________________________________________________________ test_Sepia[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Sepia(target_framework, mode, backend_compile):
        args = (
            torch.ones(3, 1, 1),
        )
>       _test_color_class(
            kornia.color.Sepia,
            args,
            target_framework,
            backend_compile,
            tolerance=1e-3,
        )

kornia/test_color.py:1189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'kornia.color.sepia.Sepia'>, args = (tensor([[[1.]],

        [[1.]],

        [[1.]]]),), target = 'tensorflow', backend_compile = False, tolerance = 0.001, init_args = ()

    def _test_color_class(
        cls,
        args,
        target,
        backend_compile=False,
        tolerance=1e-3,
        init_args=(),
    ):
        print(f"{cls.__module__}.{cls.__name__}")
    
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(cls, source="torch", target=target)

kornia/test_color.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.sepia.Sepia'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.sepia.Sepia
_________________________________________________________________________________ test_ColorMap[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_ColorMap(target_framework, mode, backend_compile):
        print("kornia.color.ColorMap")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledColorMap = ivy.transpile(kornia.color.ColorMap, source="torch", target=target_framework)

kornia/test_color.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.colormap.ColorMap'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.ColorMap
______________________________________________________________________________ test_apply_colormap[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_apply_colormap(target_framework, mode, backend_compile):
        print("kornia.color.ColorMap")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledColorMapType = ivy.transpile(kornia.color.ColorMapType, source="torch", target=target_framework)
>       TranspiledColorMap = ivy.transpile(kornia.color.ColorMap, source="torch", target=target_framework)

kornia/test_color.py:1240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.color.colormap.ColorMap'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.color.ColorMap

Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling ColorMapType from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                       
Transpilation of ColorMapType complete.
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_color.py::test_rgb_to_grayscale[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_color.py::test_bgr_to_grayscale[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_color.py::test_grayscale_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_color.py::test_rgb_to_bgr[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_bgr_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_rgb_to_linear_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
FAILED kornia/test_color.py::test_linear_rgb_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
FAILED kornia/test_color.py::test_bgr_to_rgba[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_color.py::test_rgb_to_rgba[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_color.py::test_rgba_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_color.py::test_rgba_to_bgr[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_color.py::test_rgb_to_hls[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_hls_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_rgb_to_hsv[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_hsv_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_rgb_to_luv[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_luv_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_rgb_to_lab[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_lab_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_rgb_to_ycbcr[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_color.py::test_ycbcr_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_color.py::test_rgb_to_yuv[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_yuv_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_rgb_to_yuv420[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_color.py::test_yuv420_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_color.py::test_rgb_to_yuv422[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_color.py::test_yuv422_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_color.py::test_rgb_to_xyz[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_xyz_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_rgb_to_raw[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_raw_to_rgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_color.py::test_raw_to_rgb_2x2_downscaled[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you ...
FAILED kornia/test_color.py::test_sepia[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_K...
FAILED kornia/test_color.py::test_GrayscaleToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_color.py::test_RgbToGrayscale[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_color.py::test_BgrToGrayscale[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_color.py::test_RgbToBgr[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_BgrToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_LinearRgbToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_color.py::test_RgbToLinearRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_color.py::test_RgbToRgba[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_color.py::test_BgrToRgba[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_color.py::test_RgbaToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_color.py::test_RgbaToBgr[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_color.py::test_RgbToHls[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_HlsToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_RgbToHsv[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_HsvToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_RgbToLuv[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_LuvToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_RgbToLab[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_LabToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_color.py::test_YcbcrToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_color.py::test_RgbToYuv420[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_color.py::test_Yuv420ToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_color.py::test_RgbToYuv422[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_color.py::test_Yuv422ToRgb[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_color.py::test_RgbToXyz[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_RawToRgb[tensorflow-s2s-False] - AssertionError: numpy array values are not all close
FAILED kornia/test_color.py::test_RgbToRaw[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_RawToRgb2x2Downscaled[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do n...
FAILED kornia/test_color.py::test_Sepia[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_K...
FAILED kornia/test_color.py::test_ColorMap[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_color.py::test_apply_colormap[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
=============================================================================== 64 failed, 5 passed in 204.22s (0:03:24) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 4 items

kornia/geometry/test_liegroup.py FFFF                                                                                                                                                            [100%]

=============================================================================================== FAILURES ===============================================================================================
____________________________________________________________________________________ test_So3[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_So3(target_framework, mode, backend_compile):
        print("kornia.geometry.liegroup.So3")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSo3 = ivy.transpile(kornia.geometry.liegroup.So3, source="torch", target=target_framework)

kornia/geometry/test_liegroup.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.liegroup.so3.So3'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.liegroup.So3
____________________________________________________________________________________ test_Se3[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Se3(target_framework, mode, backend_compile):
        print("kornia.geometry.liegroup.Se3")
    
        if backend_compile:
            pytest.skip()
    
        quaternion_data = torch.tensor([1., 0., 0., 0.])
        translation_data = torch.tensor([1., 1., 1.])
        torch_quaternion = kornia.geometry.quaternion.Quaternion(quaternion_data)
        torch_se3 = kornia.geometry.liegroup.Se3(torch_quaternion, translation_data)
    
>       TranspiledSe3 = ivy.transpile(kornia.geometry.liegroup.Se3, source="torch", target=target_framework)

kornia/geometry/test_liegroup.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.liegroup.se3.Se3'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.liegroup.Se3
____________________________________________________________________________________ test_So2[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_So2(target_framework, mode, backend_compile):
        print("kornia.geometry.liegroup.So2")
    
        if backend_compile:
            pytest.skip()
    
        real_part = torch.tensor([1.0], requires_grad=True)
        imaginary_part = torch.tensor([2.0], requires_grad=True)
        complex_number = torch.complex(real_part, imaginary_part)
        torch_so2 = kornia.geometry.liegroup.So2(complex_number)
    
>       TranspiledSo2 = ivy.transpile(kornia.geometry.liegroup.So2, source="torch", target=target_framework)

kornia/geometry/test_liegroup.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.liegroup.so2.So2'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.liegroup.So2
____________________________________________________________________________________ test_Se2[tensorflow-s2s-False] ____________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Se2(target_framework, mode, backend_compile):
        print("kornia.geometry.liegroup.Se2")
    
        if backend_compile:
            pytest.skip()
    
        so2_rotation = kornia.geometry.liegroup.So2.identity(1)
        translation_vector = torch.ones((1, 2), requires_grad=True)
        torch_se2 = kornia.geometry.liegroup.Se2(so2_rotation, translation_vector)
    
>       TranspiledSe2 = ivy.transpile(kornia.geometry.liegroup.Se2, source="torch", target=target_framework)

kornia/geometry/test_liegroup.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.geometry.liegroup.se2.Se2'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.liegroup.Se2
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_liegroup.py::test_So3[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/geometry/test_liegroup.py::test_Se3[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/geometry/test_liegroup.py::test_So2[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/geometry/test_liegroup.py::test_Se2[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
========================================================================================== 4 failed in 6.09s ===========================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 17 items

kornia/test_feature2.py ...FFFFFFFFFFFFFF                                                                                                                                                        [100%]

=============================================================================================== FAILURES ===============================================================================================
________________________________________________________________________________ test_rotate_laf[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_rotate_laf(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 5, 2, 3)),
            torch.randn((1, 5, 1)),
        )
        trace_kwargs = {}
        test_args = (
            torch.randn((2, 10, 2, 3)),
            torch.randn((2, 10, 1)),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.rotate_laf,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature2.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rotate_laf at 0x7f992fb1dd80>
trace_args = (tensor([[[[ 0.9598, -2.8855,  0.5757],
          [-2.1045, -1.6902,  1.1566]],

         [[ 0.6510,  0.6183, -0.4334]...4,  0.4062]]]]), tensor([[[-1.3709],
         [-0.2265],
         [-1.2100],
         [-0.4299],
         [ 0.3235]]]))
trace_kwargs = {}
test_args = (tensor([[[[ 1.5798,  1.3048, -0.1192],
          [ 1.4592, -0.3660,  1.3835]],

         [[ 0.3307,  0.6129,  0.0575]...      [-2.0935e+00],
         [-3.9904e-02],
         [-2.2739e-02],
         [-1.2775e+00],
         [ 5.2446e-01]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function rotate_laf at 0x7f992fb1dd80>
trace_args = (tensor([[[[ 0.9598, -2.8855,  0.5757],
          [-2.1045, -1.6902,  1.1566]],

         [[ 0.6510,  0.6183, -0.4334]...4,  0.4062]]]]), tensor([[[-1.3709],
         [-0.2265],
         [-1.2100],
         [-0.4299],
         [ 0.3235]]]))
trace_kwargs = {}
test_args = (tensor([[[[ 1.5798,  1.3048, -0.1192],
          [ 1.4592, -0.3660,  1.3835]],

         [[ 0.3307,  0.6129,  0.0575]...      [-2.0935e+00],
         [-3.9904e-02],
         [-2.2739e-02],
         [-1.2775e+00],
         [ 5.2446e-01]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function rotate_laf at 0x7f992fb1dd80>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.rotate_laf
____________________________________________________________________________ test_get_laf_orientation[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_get_laf_orientation(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 5, 2, 3)),
        )
        trace_kwargs = {}
        test_args = (
            torch.randn((2, 10, 2, 3)),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.get_laf_orientation,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature2.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_laf_orientation at 0x7f992fb1dcf0>
trace_args = (tensor([[[[-1.0377, -0.6499, -0.1260],
          [ 0.1098,  0.9841, -0.6478]],

         [[-0.1410, -0.6374, -0.7117]...      [-0.2143,  0.5069, -1.2725]],

         [[-0.1102, -0.2496, -0.9913],
          [-1.6220,  0.8156, -0.3702]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[ 2.3938e-01, -9.3232e-01,  1.0727e-01],
          [ 9.3349e-01, -1.6415e-02,  2.2655e-01]],

         [[-1...0346e-01]],

         [[-8.3499e-02, -4.0851e-01, -8.4377e-01],
          [-3.7941e-03,  1.3543e-02, -1.2625e+00]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function get_laf_orientation at 0x7f992fb1dcf0>
trace_args = (tensor([[[[-1.0377, -0.6499, -0.1260],
          [ 0.1098,  0.9841, -0.6478]],

         [[-0.1410, -0.6374, -0.7117]...      [-0.2143,  0.5069, -1.2725]],

         [[-0.1102, -0.2496, -0.9913],
          [-1.6220,  0.8156, -0.3702]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[ 2.3938e-01, -9.3232e-01,  1.0727e-01],
          [ 9.3349e-01, -1.6415e-02,  2.2655e-01]],

         [[-1...0346e-01]],

         [[-8.3499e-02, -4.0851e-01, -8.4377e-01],
          [-3.7941e-03,  1.3543e-02, -1.2625e+00]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function get_laf_orientation at 0x7f992fb1dcf0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.get_laf_orientation
____________________________________________________________________________ test_set_laf_orientation[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_set_laf_orientation(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 5, 2, 3)),
            torch.randn((1, 5, 1)),
        )
        trace_kwargs = {}
        test_args = (
            torch.randn((2, 10, 2, 3)),
            torch.randn((2, 10, 1)),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.set_laf_orientation,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature2.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function set_laf_orientation at 0x7f992fb1de10>
trace_args = (tensor([[[[-1.3601, -0.7397, -1.7032],
          [-0.9313,  0.9971,  0.4681]],

         [[ 0.2065,  0.3762,  0.2437]...4,  1.5955]]]]), tensor([[[-0.6027],
         [-0.6990],
         [-2.2125],
         [-1.2369],
         [ 0.0344]]]))
trace_kwargs = {}
test_args = (tensor([[[[-0.3101, -1.1713,  0.5879],
          [ 0.0964, -0.1597, -0.8203]],

         [[ 1.6716,  0.0585, -0.0207]...      [-0.2143],
         [-1.0443],
         [-0.5927],
         [-1.5585],
         [-1.9684],
         [ 0.4862]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function set_laf_orientation at 0x7f992fb1de10>
trace_args = (tensor([[[[-1.3601, -0.7397, -1.7032],
          [-0.9313,  0.9971,  0.4681]],

         [[ 0.2065,  0.3762,  0.2437]...4,  1.5955]]]]), tensor([[[-0.6027],
         [-0.6990],
         [-2.2125],
         [-1.2369],
         [ 0.0344]]]))
trace_kwargs = {}
test_args = (tensor([[[[-0.3101, -1.1713,  0.5879],
          [ 0.0964, -0.1597, -0.8203]],

         [[ 1.6716,  0.0585, -0.0207]...      [-0.2143],
         [-1.0443],
         [-0.5927],
         [-1.5585],
         [-1.9684],
         [ 0.4862]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function set_laf_orientation at 0x7f992fb1de10>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.set_laf_orientation
_________________________________________________________________________ test_laf_from_center_scale_ori[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_laf_from_center_scale_ori(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 5, 2),
            torch.randn(1, 5, 1, 1),
            torch.randn(1, 5, 1),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 10, 2),
            torch.randn(5, 10, 1, 1),
            torch.randn(5, 10, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.laf_from_center_scale_ori,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature2.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_from_center_scale_ori at 0x7f992fb1dea0>
trace_args = (tensor([[[0.8733, 0.9611],
         [0.2028, 0.7928],
         [0.9256, 0.0836],
         [0.4923, 0.4178],
         ... [[-0.1792]]]]), tensor([[[-1.0584],
         [ 0.1061],
         [-0.7052],
         [-0.4607],
         [-1.0905]]]))
trace_kwargs = {}
test_args = (tensor([[[0.4898, 0.4552],
         [0.3233, 0.7391],
         [0.1954, 0.5231],
         [0.5480, 0.0039],
         ...      [-0.7098],
         [ 0.1107],
         [ 1.0451],
         [-1.2316],
         [-0.6605],
         [ 0.1326]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_from_center_scale_ori at 0x7f992fb1dea0>
trace_args = (tensor([[[0.8733, 0.9611],
         [0.2028, 0.7928],
         [0.9256, 0.0836],
         [0.4923, 0.4178],
         ... [[-0.1792]]]]), tensor([[[-1.0584],
         [ 0.1061],
         [-0.7052],
         [-0.4607],
         [-1.0905]]]))
trace_kwargs = {}
test_args = (tensor([[[0.4898, 0.4552],
         [0.3233, 0.7391],
         [0.1954, 0.5231],
         [0.5480, 0.0039],
         ...      [-0.7098],
         [ 0.1107],
         [ 1.0451],
         [-1.2316],
         [-0.6605],
         [ 0.1326]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function laf_from_center_scale_ori at 0x7f992fb1dea0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.laf_from_center_scale_ori
____________________________________________________________________________ test_laf_is_inside_image[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_laf_is_inside_image(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 5, 2, 3),
            torch.rand(1, 1, 32, 32),
        )
        trace_kwargs = {'border': 0}
        test_args = (
            torch.rand(2, 10, 2, 3),
            torch.rand(2, 1, 64, 64),
        )
        test_kwargs = {'border': 1}
>       _test_function(
            kornia.feature.laf_is_inside_image,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature2.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_is_inside_image at 0x7f992fb1e4d0>
trace_args = (tensor([[[[0.1644, 0.2055, 0.9830],
          [0.5615, 0.6696, 0.7495]],

         [[0.4610, 0.5737, 0.9293],
       ...5, 0.8044, 0.1872,  ..., 0.5794, 0.5108, 0.7918],
          [0.7480, 0.2245, 0.1429,  ..., 0.7420, 0.4424, 0.4124]]]]))
trace_kwargs = {'border': 0}
test_args = (tensor([[[[0.0238, 0.9317, 0.2865],
          [0.9599, 0.9522, 0.0767]],

         [[0.3693, 0.7275, 0.9283],
       ...7, 0.2146, 0.5254,  ..., 0.2169, 0.1730, 0.6738],
          [0.8880, 0.5560, 0.1627,  ..., 0.6204, 0.1596, 0.6744]]]]))
test_kwargs = {'border': 1}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_is_inside_image at 0x7f992fb1e4d0>
trace_args = (tensor([[[[0.1644, 0.2055, 0.9830],
          [0.5615, 0.6696, 0.7495]],

         [[0.4610, 0.5737, 0.9293],
       ...5, 0.8044, 0.1872,  ..., 0.5794, 0.5108, 0.7918],
          [0.7480, 0.2245, 0.1429,  ..., 0.7420, 0.4424, 0.4124]]]]))
trace_kwargs = {'border': 0}
test_args = (tensor([[[[0.0238, 0.9317, 0.2865],
          [0.9599, 0.9522, 0.0767]],

         [[0.3693, 0.7275, 0.9283],
       ...7, 0.2146, 0.5254,  ..., 0.2169, 0.1730, 0.6738],
          [0.8880, 0.5560, 0.1627,  ..., 0.6204, 0.1596, 0.6744]]]]))
test_kwargs = {'border': 1}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function laf_is_inside_image at 0x7f992fb1e4d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.laf_is_inside_image
____________________________________________________________________________ test_laf_to_three_points[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_laf_to_three_points(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 5, 2, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2, 10, 2, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.laf_to_three_points,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature2.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_to_three_points at 0x7f992fb1e560>
trace_args = (tensor([[[[0.3600, 0.5775, 0.4847],
          [0.7763, 0.8622, 0.1283]],

         [[0.2705, 0.9054, 0.2801],
       ...81],
          [0.1467, 0.1505, 0.8654]],

         [[0.4568, 0.1850, 0.9830],
          [0.6554, 0.0482, 0.7726]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.5540, 0.6274, 0.4580],
          [0.9429, 0.1170, 0.5301]],

         [[0.2260, 0.7268, 0.9262],
       ...81],
          [0.5058, 0.0955, 0.4728]],

         [[0.9283, 0.9677, 0.5051],
          [0.1261, 0.6227, 0.4622]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_to_three_points at 0x7f992fb1e560>
trace_args = (tensor([[[[0.3600, 0.5775, 0.4847],
          [0.7763, 0.8622, 0.1283]],

         [[0.2705, 0.9054, 0.2801],
       ...81],
          [0.1467, 0.1505, 0.8654]],

         [[0.4568, 0.1850, 0.9830],
          [0.6554, 0.0482, 0.7726]]]]),)
trace_kwargs = {}
test_args = (tensor([[[[0.5540, 0.6274, 0.4580],
          [0.9429, 0.1170, 0.5301]],

         [[0.2260, 0.7268, 0.9262],
       ...81],
          [0.5058, 0.0955, 0.4728]],

         [[0.9283, 0.9677, 0.5051],
          [0.1261, 0.6227, 0.4622]]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function laf_to_three_points at 0x7f992fb1e560>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.laf_to_three_points
___________________________________________________________________________ test_laf_from_three_points[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_laf_from_three_points(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 5, 6),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2, 10, 6),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.laf_from_three_points,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature2.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_from_three_points at 0x7f992fb1e5f0>
trace_args = (tensor([[[0.7912, 0.0330, 0.3378, 0.4647, 0.7696, 0.3038],
         [0.0184, 0.8565, 0.8743, 0.0126, 0.6390, 0.7149],...       [0.3090, 0.6033, 0.5916, 0.7781, 0.4278, 0.8215],
         [0.6802, 0.0584, 0.4950, 0.9175, 0.9627, 0.7133]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.4440, 0.8304, 0.4739, 0.9985, 0.7650, 0.3204],
         [0.4509, 0.5915, 0.1109, 0.5186, 0.2527, 0.4812],...       [0.8868, 0.4857, 0.4409, 0.2276, 0.5896, 0.4580],
         [0.2809, 0.8118, 0.0935, 0.1637, 0.2472, 0.1495]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function laf_from_three_points at 0x7f992fb1e5f0>
trace_args = (tensor([[[0.7912, 0.0330, 0.3378, 0.4647, 0.7696, 0.3038],
         [0.0184, 0.8565, 0.8743, 0.0126, 0.6390, 0.7149],...       [0.3090, 0.6033, 0.5916, 0.7781, 0.4278, 0.8215],
         [0.6802, 0.0584, 0.4950, 0.9175, 0.9627, 0.7133]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.4440, 0.8304, 0.4739, 0.9985, 0.7650, 0.3204],
         [0.4509, 0.5915, 0.1109, 0.5186, 0.2527, 0.4812],...       [0.8868, 0.4857, 0.4409, 0.2276, 0.5896, 0.4580],
         [0.2809, 0.8118, 0.0935, 0.1637, 0.2472, 0.1495]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function laf_from_three_points at 0x7f992fb1e5f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.laf_from_three_points
________________________________________________________________________ test_perspective_transform_lafs[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_perspective_transform_lafs(target_framework, mode, backend_compile):
        trace_args = (
            torch.eye(3).repeat(1, 1, 1),
            torch.rand(1, 5, 2, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.eye(3).repeat(2, 1, 1),
            torch.rand(2, 10, 2, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.feature.perspective_transform_lafs,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_feature2.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function perspective_transform_lafs at 0x7f992fb1e680>
trace_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[[[0.5176, 0.8768, 0.5284],
         ...117],
          [0.9679, 0.1104, 0.0063]],

         [[0.0508, 0.4343, 0.3692],
          [0.3303, 0.4870, 0.6864]]]]))
trace_kwargs = {}
test_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
...063],
          [0.1358, 0.0277, 0.9121]],

         [[0.8593, 0.0078, 0.7159],
          [0.4614, 0.5195, 0.5876]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function perspective_transform_lafs at 0x7f992fb1e680>
trace_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]), tensor([[[[0.5176, 0.8768, 0.5284],
         ...117],
          [0.9679, 0.1104, 0.0063]],

         [[0.0508, 0.4343, 0.3692],
          [0.3303, 0.4870, 0.6864]]]]))
trace_kwargs = {}
test_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
...063],
          [0.1358, 0.0277, 0.9121]],

         [[0.8593, 0.0078, 0.7159],
          [0.4614, 0.5195, 0.5876]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function perspective_transform_lafs at 0x7f992fb1e680>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.laf.perspective_transform_lafs
____________________________________________________________________________ test_DenseSIFTDescriptor[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_DenseSIFTDescriptor(target_framework, mode, backend_compile):
        print("kornia.feature.DenseSIFTDescriptor")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledDenseSIFTDescriptor = ivy.transpile(kornia.feature.DenseSIFTDescriptor, source="torch", target=target_framework)

kornia/test_feature2.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.siftdesc.DenseSIFTDescriptor'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.DenseSIFTDescriptor
______________________________________________________________________________ test_SIFTDescriptor[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SIFTDescriptor(target_framework, mode, backend_compile):
        print("kornia.feature.SIFTDescriptor")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSIFTDescriptor = ivy.transpile(kornia.feature.SIFTDescriptor, source="torch", target=target_framework)

kornia/test_feature2.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.siftdesc.SIFTDescriptor'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.SIFTDescriptor
_______________________________________________________________________________ test_MKDDescriptor[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_MKDDescriptor(target_framework, mode, backend_compile):
        print("kornia.feature.MKDDescriptor")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledMKDDescriptor = ivy.transpile(kornia.feature.MKDDescriptor, source="torch", target=target_framework)

kornia/test_feature2.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.mkd.MKDDescriptor'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.MKDDescriptor
__________________________________________________________________________________ test_HardNet[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_HardNet(target_framework, mode, backend_compile):
        print("kornia.feature.HardNet")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledHardNet = ivy.transpile(kornia.feature.HardNet, source="torch", target=target_framework)

kornia/test_feature2.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.hardnet.HardNet'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.HardNet
_________________________________________________________________________________ test_HardNet8[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_HardNet8(target_framework, mode, backend_compile):
        print("kornia.feature.HardNet8")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledHardNet8 = ivy.transpile(kornia.feature.HardNet8, source="torch", target=target_framework)

kornia/test_feature2.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.hardnet.HardNet8'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.HardNet8
___________________________________________________________________________________ test_HyNet[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_HyNet(target_framework, mode, backend_compile):
        print("kornia.feature.HyNet")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledHyNet = ivy.transpile(kornia.feature.HyNet, source="torch", target=target_framework)

kornia/test_feature2.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.hynet.HyNet'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.HyNet
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_feature2.py::test_rotate_laf[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_feature2.py::test_get_laf_orientation[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_feature2.py::test_set_laf_orientation[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_feature2.py::test_laf_from_center_scale_ori[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure y...
FAILED kornia/test_feature2.py::test_laf_is_inside_image[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_feature2.py::test_laf_to_three_points[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_feature2.py::test_laf_from_three_points[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you d...
FAILED kornia/test_feature2.py::test_perspective_transform_lafs[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/test_feature2.py::test_DenseSIFTDescriptor[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_feature2.py::test_SIFTDescriptor[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_feature2.py::test_MKDDescriptor[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.
FAILED kornia/test_feature2.py::test_HardNet[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_feature2.py::test_HardNet8[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_feature2.py::test_HyNet[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
=============================================================================== 14 failed, 3 passed in 77.29s (0:01:17) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 68 items

kornia/augmentation/test_augmentation.py ....FF.FF..FF..F.FFFFFF.FF.F.F.FFFFF.FF...FFF.FFFFFFFFF..FF..FF..FFF                                                                                    [100%]

=============================================================================================== FAILURES ===============================================================================================
_____________________________________________________________________________ test_RandomBrightness[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomBrightness(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomBrightness")
    
        init_args = ()
        init_kwargs = {"brightness": (0.5, 2.), "p": 1.}
        call_args = (torch.rand(1, 3, 3, 3),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomBrightness,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.brightness.RandomBrightness'>, target = 'tensorflow', init_args = (), init_kwargs = {'brightness': (0.5, 2.0), 'p': 1.0}
call_args = (tensor([[[[0.7656, 0.7539, 0.8094],
          [0.6059, 0.8117, 0.2535],
          [0.2981, 0.9857, 0.6164]],

       ...49]],

         [[0.5502, 0.6481, 0.5835],
          [0.5820, 0.9362, 0.1339],
          [0.6442, 0.2251, 0.9950]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.brightness.RandomBrightness'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomBrightness
___________________________________________________________________________ test_RandomChannelDropout[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomChannelDropout(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomChannelDropout")
    
        init_args = ()
        init_kwargs = {"num_drop_channels": 1, "fill_value": 0.0, "p": 1.0}
        call_args = (torch.ones(1, 3, 3, 3),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomChannelDropout,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.channel_dropout.RandomChannelDropout'>, target = 'tensorflow', init_args = ()
init_kwargs = {'fill_value': 0.0, 'num_drop_channels': 1, 'p': 1.0}
call_args = (tensor([[[[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]],

         [[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]],

         [[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.channel_dropout.RandomChannelDropout'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomChannelDropout
________________________________________________________________________________ test_RandomClahe[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomClahe(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomClahe")
    
        init_args = ()
        init_kwargs = {}
        call_args = (torch.rand(2, 3, 10, 20),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomClahe,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.clahe.RandomClahe'>, target = 'tensorflow', init_args = (), init_kwargs = {}
call_args = (tensor([[[[2.2379e-01, 2.9696e-01, 6.3217e-01,  ..., 5.7760e-01,
           5.2018e-03, 2.4255e-01],
          [6.467... 4.3075e-01],
          [3.1085e-01, 9.2825e-01, 3.7193e-01,  ..., 8.3875e-01,
           4.2188e-02, 8.5942e-01]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.clahe.RandomClahe'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomClahe
______________________________________________________________________________ test_RandomContrast[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomContrast(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomContrast")
    
        init_args = ()
        init_kwargs = {"contrast": (0.5, 2.), "p": 1.}
        call_args = (torch.rand(1, 3, 3, 3),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomContrast,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.contrast.RandomContrast'>, target = 'tensorflow', init_args = (), init_kwargs = {'contrast': (0.5, 2.0), 'p': 1.0}
call_args = (tensor([[[[0.1913, 0.4407, 0.2708],
          [0.7877, 0.2851, 0.1589],
          [0.3607, 0.0302, 0.7777]],

       ...09]],

         [[0.5926, 0.4030, 0.6089],
          [0.9640, 0.4115, 0.2628],
          [0.7263, 0.0289, 0.7475]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.contrast.RandomContrast'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomContrast
____________________________________________________________________________ test_RandomGaussianBlur[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomGaussianBlur(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomGaussianBlur")
    
        init_args = ((3, 3), (0.1, 2.0))
        init_kwargs = {"p": 1.}
        call_args = (torch.rand(1, 1, 5, 5),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomGaussianBlur,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.gaussian_blur.RandomGaussianBlur'>, target = 'tensorflow', init_args = ((3, 3), (0.1, 2.0)), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[0.1111, 0.0458, 0.7126, 0.6520, 0.1808],
          [0.9751, 0.0057, 0.5288, 0.7430, 0.8963],
          [0...., 0.9025],
          [0.4975, 0.1066, 0.8658, 0.6126, 0.4121],
          [0.1807, 0.3765, 0.7923, 0.3224, 0.3359]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.gaussian_blur.RandomGaussianBlur'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomGaussianBlur
________________________________________________________________________ test_RandomGaussianIllumination[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomGaussianIllumination(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomGaussianIllumination")
    
        init_args = ()
        init_kwargs = {"gain": 0.5, "p": 1.}
        call_args = (torch.ones(1, 3, 3, 3) * 0.5,)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomGaussianIllumination,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.gaussian_illumination.RandomGaussianIllumination'>, target = 'tensorflow', init_args = (), init_kwargs = {'gain': 0.5, 'p': 1.0}
call_args = (tensor([[[[0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000]],

       ...00]],

         [[0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.gaussian_illumination.RandomGaussianIllumination'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomGaussianIllumination
_________________________________________________________________________________ test_RandomHue[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomHue(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomHue")
    
        init_args = ()
        init_kwargs = {"hue": (-0.5, 0.5), "p": 1.}
        call_args = (torch.rand(1, 3, 3, 3),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomHue,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.hue.RandomHue'>, target = 'tensorflow', init_args = (), init_kwargs = {'hue': (-0.5, 0.5), 'p': 1.0}
call_args = (tensor([[[[0.0688, 0.9003, 0.2582],
          [0.7742, 0.3788, 0.4906],
          [0.8538, 0.1029, 0.4213]],

       ...23]],

         [[0.9229, 0.6287, 0.4766],
          [0.1407, 0.4585, 0.9264],
          [0.5120, 0.4985, 0.0576]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.hue.RandomHue'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomHue
________________________________________________________________________________ test_RandomJPEG[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomJPEG(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomJPEG")
    
        init_args = ()
        init_kwargs = {"jpeg_quality": (1.0, 50.0), "p": 1.}
        call_args = (0.1904 * torch.ones(2, 3, 32, 32), )
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomJPEG,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.jpeg.RandomJPEG'>, target = 'tensorflow', init_args = (), init_kwargs = {'jpeg_quality': (1.0, 50.0), 'p': 1.0}
call_args = (tensor([[[[0.1904, 0.1904, 0.1904,  ..., 0.1904, 0.1904, 0.1904],
          [0.1904, 0.1904, 0.1904,  ..., 0.1904, 0...., 0.1904, 0.1904,  ..., 0.1904, 0.1904, 0.1904],
          [0.1904, 0.1904, 0.1904,  ..., 0.1904, 0.1904, 0.1904]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.jpeg.RandomJPEG'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomJPEG
______________________________________________________________________ test_RandomLinearCornerIllumination[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomLinearCornerIllumination(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomLinearCornerIllumination")
    
        init_args = ()
        init_kwargs = {"gain": 0.25, "p": 1.}
        call_args = (torch.ones(1, 3, 3, 3) * 0.5,)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomLinearCornerIllumination,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.linear_illumination.RandomLinearCornerIllumination'>, target = 'tensorflow', init_args = (), init_kwargs = {'gain': 0.25, 'p': 1.0}
call_args = (tensor([[[[0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000]],

       ...00]],

         [[0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
        transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)
    
        torch_aug = augmentation_cls(*init_args, **init_kwargs)
        transpiled_init_args = _nest_torch_tensor_to_new_framework(init_args, target)
        transpiled_init_kwargs = _nest_torch_tensor_to_new_framework(init_kwargs, target)
        transpiled_aug = transpiled_cls(*transpiled_init_args, **transpiled_init_kwargs)
    
        # assert dir(torch_aug) == dir(transpiled_aug), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_aug)} != transpiled: {dir(transpiled_aug)}"
    
        torch_out = torch_aug(*call_args, **call_kwargs)
        transpiled_call_args = _nest_torch_tensor_to_new_framework(call_args, target)
        transpiled_call_kwargs = _nest_torch_tensor_to_new_framework(call_kwargs, target)
>       transpiled_out = transpiled_aug(*transpiled_call_args, **transpiled_call_kwargs)

kornia/augmentation/test_augmentation.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=False)
args = (<tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0...  [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x55bd53dbe380, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...kexec', code_context=['        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=Fals...   [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=False), v = None, buffers = None
args = (<tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0...  [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=Fals...   [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=False), v = None, buffers = None
args = (<tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0...  [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>,)
kwargs = {}
first_arr = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0....    [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>
replace_v = False, replace_buffers = False, call_signature = <Signature (input, params=None, **kwargs)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=False),)
kwargs = {'input': <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
  ...   [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=False)
input = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0....    [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>
params = None, kwargs = {}, tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f996f594a60>, tensorflow_set_item_bknd = <function tensorflow_set_item_bknd at 0x7f996fad1b40>
tensor = <function tensorflow_tensor_frnt at 0x7f996dafc4c0>
in_tensor = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0....    [0.5, 0.5, 0.5]],

        [[0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5]]]], dtype=float32)>
input_shape = ivy.frontends.torch.Size([1, 3, 3, 3]), batch_shape = ivy.frontends.torch.Size([1, 3, 3, 3])

    def call(self, input, params=None, **kwargs):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ..core._backend import tensor
    
        in_tensor = self.__unpack_input__(input)
        input_shape = tensorflow_shape_frnt_(in_tensor)
        in_tensor = self.transform_tensor(in_tensor)
        batch_shape = tensorflow_shape_frnt_(in_tensor)
        if params is None:
>           params = self.forward_parameters(batch_shape)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=False), batch_shape = ivy.frontends.torch.Size([1, 3, 3, 3])

    def forward_parameters(self, batch_shape):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_sum_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_item_frnt_
        from ...ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ..core._backend import tensor
    
        batch_prob = self.__batch_prob_generator__(
            batch_shape, self.p, self.p_batch, self.same_on_batch
        )
        to_apply = batch_prob > 0.5
>       _params = self.generate_parameters(
            tuple(
                (
                    int(tensorflow_item_frnt_(tensorflow_sum_frnt_(to_apply))),
                    *batch_shape[1:],
                )
            )
        )

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomLinearCornerIllumination(gain=(0.25, 0.25), sign=(-1.0, 1.0), p=1.0, p_batch=1.0, same_on_batch=False), batch_shape = (1, 3, 3, 3)

    def generate_parameters(self, batch_shape):
        if self._param_generator is not None:
>           return self._param_generator(batch_shape, self.same_on_batch)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = gain=(0.25, 0.25), sign=(-1.0, 1.0), args = ((1, 3, 3, 3), False), kwargs = {}
stack = [FrameInfo(frame=<frame at 0x55bd573ca240, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...ion.py', lineno=46, function='__call__', code_context=['            return call_fn(*args, **kwargs)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = gain=(0.25, 0.25), sign=(-1.0, 1.0), v = None, buffers = None, args = ((1, 3, 3, 3), False), kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = gain=(0.25, 0.25), sign=(-1.0, 1.0), v = None, buffers = None, args = ((1, 3, 3, 3), False), kwargs = {}, replace_v = False, replace_buffers = False
call_signature = <Signature (batch_shape, same_on_batch=False)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = gain=(0.25, 0.25), sign=(-1.0, 1.0), batch_shape = (1, 3, 3, 3), same_on_batch = False

    def call(self, batch_shape, same_on_batch=False):
        from .....ivy.functional.frontends.torch.tensor import tensorflow_to_frnt_
        from ...utils.param_validation import tensorflow__common_param_check
        from ....utils.helpers import tensorflow__extract_device_dtype
        from ...utils.helpers import tensorflow__adapted_rsampling
        from .....ivy.functional.frontends.torch.indexing_slicing_joining_mutating_ops import (
            tensorflow_where_frnt,
        )
        from .....ivy.functional.frontends.torch.creation_ops import (
            tensorflow_tensor_frnt,
        )
        from .....ivy.functional.frontends.torch.tensor import tensorflow_expand_frnt_
        from .....ivy.functional.frontends.torch.tensor import (
            tensorflow_unsqueeze_frnt_,
        )
        from .....ivy.functional.frontends.torch.creation_ops import (
            tensorflow_linspace_frnt,
        )
        from .....ivy.functional.frontends.torch.creation_ops import (
            tensorflow_zeros_frnt,
        )
        from .....ivy.functional.backends.tensorflow.general import tensorflow_get_item
        from .....ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ....enhance.normalize import tensorflow_normalize
    
        batch_size, channels, height, width = (
            batch_shape[0],
            batch_shape[1],
            batch_shape[2],
            batch_shape[3],
        )
        tensorflow__common_param_check(batch_size, same_on_batch)
        _device, _dtype = tensorflow__extract_device_dtype([self.gain, self.sign])
        gain_factor = tensorflow_to_frnt_(
            tensorflow__adapted_rsampling(
                (batch_size, 1, 1, 1), self.gain_sampler, same_on_batch
            ),
            device=_device,
            dtype=_dtype,
        )
        sign = tensorflow_to_frnt_(
            tensorflow_where_frnt(
                tensorflow__adapted_rsampling(
                    (batch_size, 1, 1, 1), self.sign_sampler, same_on_batch
                )
                >= 0.0,
                tensorflow_tensor_frnt(1),
                tensorflow_tensor_frnt(-1),
            ),
            device=_device,
            dtype=_dtype,
        )
        directions = tensorflow_to_frnt_(
            tensorflow__adapted_rsampling(
                (batch_size, 1, 1, 1), self.directions_sampler, same_on_batch
            ),
            device=_device,
            dtype=tf.int8,
        )
        y_grad = tensorflow_expand_frnt_(
            tensorflow_unsqueeze_frnt_(tensorflow_linspace_frnt(0, 1, height), 1),
            channels,
            height,
            width,
        )
        x_grad = tensorflow_expand_frnt_(
            tensorflow_unsqueeze_frnt_(tensorflow_linspace_frnt(0, 1, width), 0),
            channels,
            height,
            width,
        )
        gradient = tensorflow_zeros_frnt(batch_shape)
        for _b in range(batch_size):
            if tensorflow_get_item(directions, _b) == 0:
                gradient = tensorflow_set_item_bknd(gradient, _b, x_grad + y_grad)
            elif tensorflow_get_item(directions, _b) == 1:
                gradient = tensorflow_set_item_bknd(gradient, _b, -x_grad + y_grad)
            elif tensorflow_get_item(directions, _b) == 2:
                gradient = tensorflow_set_item_bknd(gradient, _b, x_grad - y_grad)
            elif tensorflow_get_item(directions, _b) == 3:
                gradient = tensorflow_set_item_bknd(gradient, _b, 1 - (x_grad + y_grad))
>       gradient = sign * gain_factor * tensorflow_normalize.normalize_min_max(gradient)
E       AttributeError: Exception encountered when calling tensorflow_LinearCornerIlluminationGenerator.call().
E       
E       [1m'function' object has no attribute 'normalize_min_max'[0m
E       
E       Arguments received by tensorflow_LinearCornerIlluminationGenerator.call():
E          batch_shape=('1', '3', '3', '3')
E          same_on_batch=False

Translated_Outputs/tensorflow_outputs/kornia/augmentation/random_generator/_2d/linear_illumination.py:147: AttributeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomLinearCornerIllumination

Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomLinearCornerIllumination from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                                         
Transpilation of RandomLinearCornerIllumination complete.
_________________________________________________________________________ test_RandomLinearIllumination[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomLinearIllumination(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomLinearIllumination")
    
        init_args = ()
        init_kwargs = {"gain": 0.25, "p": 1.}
        call_args = (torch.ones(1, 3, 3, 3) * 0.5,)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomLinearIllumination,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:455: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.linear_illumination.RandomLinearIllumination'>, target = 'tensorflow', init_args = (), init_kwargs = {'gain': 0.25, 'p': 1.0}
call_args = (tensor([[[[0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000]],

       ...00]],

         [[0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000],
          [0.5000, 0.5000, 0.5000]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.linear_illumination.RandomLinearIllumination'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomLinearIllumination
_____________________________________________________________________________ test_RandomMedianBlur[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomMedianBlur(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomMedianBlur")
    
        init_args = ((3, 3),)
        init_kwargs = {"p": 1}
        call_args = (torch.ones(1, 1, 4, 4),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomMedianBlur,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:475: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.median_blur.RandomMedianBlur'>, target = 'tensorflow', init_args = ((3, 3),), init_kwargs = {'p': 1}
call_args = (tensor([[[[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]]]]),), call_kwargs = {}, deterministic_output = False
backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.median_blur.RandomMedianBlur'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomMedianBlur
_____________________________________________________________________________ test_RandomMotionBlur[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomMotionBlur(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomMotionBlur")
    
        init_args = (3, 35., 0.5)
        init_kwargs = {"p": 1.}
        call_args = (torch.ones(1, 1, 5, 5),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomMotionBlur,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.motion_blur.RandomMotionBlur'>, target = 'tensorflow', init_args = (3, 35.0, 0.5), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.]]]]),), call_kwargs = {}
deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
        transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)
    
        torch_aug = augmentation_cls(*init_args, **init_kwargs)
        transpiled_init_args = _nest_torch_tensor_to_new_framework(init_args, target)
        transpiled_init_kwargs = _nest_torch_tensor_to_new_framework(init_kwargs, target)
        transpiled_aug = transpiled_cls(*transpiled_init_args, **transpiled_init_kwargs)
    
        # assert dir(torch_aug) == dir(transpiled_aug), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_aug)} != transpiled: {dir(transpiled_aug)}"
    
        torch_out = torch_aug(*call_args, **call_kwargs)
        transpiled_call_args = _nest_torch_tensor_to_new_framework(call_args, target)
        transpiled_call_kwargs = _nest_torch_tensor_to_new_framework(call_kwargs, target)
>       transpiled_out = transpiled_aug(*transpiled_call_args, **transpiled_call_kwargs)

kornia/augmentation/test_augmentation.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border_type=constant, resample=nearest)
args = (<tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7f996ed8ac40, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...kexec', code_context=['        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border..., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border_type=constant, resample=nearest), v = None, buffers = None
args = (<tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border..., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border_type=constant, resample=nearest), v = None, buffers = None
args = (<tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>,)
kwargs = {}
first_arr = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>
replace_v = False, replace_buffers = False, call_signature = <Signature (input, params=None, **kwargs)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border_type=constant, resample=nearest),)
kwargs = {'input': <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border_type=constant, resample=nearest)
input = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>
params = None, kwargs = {}, tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f996e7a0e50>, tensorflow_set_item_bknd = <function tensorflow_set_item_bknd at 0x7f996ea672e0>
tensor = <function tensorflow_tensor_frnt at 0x7f996fa6b250>
in_tensor = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]]], dtype=float32)>
input_shape = ivy.frontends.torch.Size([1, 1, 5, 5]), batch_shape = ivy.frontends.torch.Size([1, 1, 5, 5])

    def call(self, input, params=None, **kwargs):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ..core._backend import tensor
    
        in_tensor = self.__unpack_input__(input)
        input_shape = tensorflow_shape_frnt_(in_tensor)
        in_tensor = self.transform_tensor(in_tensor)
        batch_shape = tensorflow_shape_frnt_(in_tensor)
        if params is None:
>           params = self.forward_parameters(batch_shape)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border_type=constant, resample=nearest)
batch_shape = ivy.frontends.torch.Size([1, 1, 5, 5])

    def forward_parameters(self, batch_shape):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_sum_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_item_frnt_
        from ...ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ..core._backend import tensor
    
        batch_prob = self.__batch_prob_generator__(
            batch_shape, self.p, self.p_batch, self.same_on_batch
        )
        to_apply = batch_prob > 0.5
>       _params = self.generate_parameters(
            tuple(
                (
                    int(tensorflow_item_frnt_(tensorflow_sum_frnt_(to_apply))),
                    *batch_shape[1:],
                )
            )
        )

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomMotionBlur(kernel_size=3, angle=35.0, direction=0.5, p=1.0, p_batch=1.0, same_on_batch=False, border_type=constant, resample=nearest), batch_shape = (1, 1, 5, 5)

    def generate_parameters(self, batch_shape):
        from ....core._backend import tensor
        from .....ivy.functional.ivy.general import tensorflow_set_item_bknd
        from .....ivy.functional.frontends.torch.random_sampling import (
            tensorflow_randint_frnt,
        )
    
        params = super().generate_parameters(batch_shape)
        params = tensorflow_set_item_bknd(
            params,
            "idx",
            tensor([0])
            if batch_shape[0] == 0
>           else tensorflow_randint_frnt(batch_shape[0], (1,)),
        )
E       TypeError: Exception encountered when calling tensorflow_RandomMotionBlur.call().
E       
E       [1mtensorflow_randint_frnt() missing 1 required positional argument: 'size'[0m
E       
E       Arguments received by tensorflow_RandomMotionBlur.call():
E          input=tf.Tensor(shape=(1, 1, 5, 5), dtype=float32)
E          params=None
E          kwargs=<class 'inspect._empty'>

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/intensity/motion_blur.py:70: TypeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomMotionBlur

Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomMotionBlur from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                           
Transpilation of RandomMotionBlur complete.
___________________________________________________________________________ test_RandomPlanckianJitter[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomPlanckianJitter(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomPlanckianJitter")
    
        init_args = ()
        init_kwargs = {"mode": "blackbody", "select_from": [23, 24, 1, 2]}
        call_args = (torch.randn(2, 3, 2, 2),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomPlanckianJitter,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:515: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.planckian_jitter.RandomPlanckianJitter'>, target = 'tensorflow', init_args = ()
init_kwargs = {'mode': 'blackbody', 'select_from': [23, 24, 1, 2]}
call_args = (tensor([[[[-0.9314, -1.6777],
          [ 0.2512,  1.1181]],

         [[ 1.1132, -0.1307],
          [ 0.6266,  0.08...  [[-0.2341,  2.9565],
          [-0.1889, -0.4499]],

         [[-0.3237,  1.3221],
          [ 0.1347, -0.0868]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.planckian_jitter.RandomPlanckianJitter'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomPlanckianJitter
___________________________________________________________________________ test_RandomPlasmaContrast[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomPlasmaContrast(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomPlasmaContrast")
    
        init_args = ()
        init_kwargs = {"roughness": (0.1, 0.7), "p": 1.}
        call_args = (torch.ones(1, 1, 3, 4),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomPlasmaContrast,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:555: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.plasma.RandomPlasmaContrast'>, target = 'tensorflow', init_args = (), init_kwargs = {'p': 1.0, 'roughness': (0.1, 0.7)}
call_args = (tensor([[[[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]]]]),), call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.plasma.RandomPlasmaContrast'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomPlasmaContrast
____________________________________________________________________________ test_RandomPlasmaShadow[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomPlasmaShadow(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomPlasmaShadow")
    
        init_args = ()
        init_kwargs = {"roughness": (0.1, 0.7), "p": 1.}
        call_args = (torch.ones(1, 1, 3, 4),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomPlasmaShadow,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:575: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.plasma.RandomPlasmaShadow'>, target = 'tensorflow', init_args = (), init_kwargs = {'p': 1.0, 'roughness': (0.1, 0.7)}
call_args = (tensor([[[[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]]]]),), call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.plasma.RandomPlasmaShadow'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomPlasmaShadow
________________________________________________________________________________ test_RandomRain[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomRain(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomRain")
    
        init_args = ()
        init_kwargs = {"p": 1, "drop_height": (1,2), "drop_width": (1,2), "number_of_drops": (1,1)}
        call_args = (torch.rand(1, 1, 5, 5),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomRain,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.random_rain.RandomRain'>, target = 'tensorflow', init_args = ()
init_kwargs = {'drop_height': (1, 2), 'drop_width': (1, 2), 'number_of_drops': (1, 1), 'p': 1}
call_args = (tensor([[[[0.0231, 0.4817, 0.8917, 0.6536, 0.6582],
          [0.7912, 0.0049, 0.6668, 0.7231, 0.0843],
          [0...., 0.4754],
          [0.4788, 0.6456, 0.2916, 0.1606, 0.7526],
          [0.9017, 0.0199, 0.9290, 0.7143, 0.8814]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.random_rain.RandomRain'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomRain
_________________________________________________________________________ test_RandomSaltAndPepperNoise[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomSaltAndPepperNoise(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomSaltAndPepperNoise")
    
        init_args = ()
        init_kwargs = {"amount": 0.5, "salt_vs_pepper": 0.5, "p": 1.}
        call_args = (torch.rand(1, 3, 3, 3),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomSaltAndPepperNoise,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.salt_pepper_noise.RandomSaltAndPepperNoise'>, target = 'tensorflow', init_args = ()
init_kwargs = {'amount': 0.5, 'p': 1.0, 'salt_vs_pepper': 0.5}
call_args = (tensor([[[[0.3809, 0.2295, 0.5185],
          [0.3133, 0.8304, 0.9787],
          [0.3489, 0.0609, 0.8220]],

       ...82]],

         [[0.1562, 0.4379, 0.3732],
          [0.9685, 0.8886, 0.0372],
          [0.9934, 0.9040, 0.7027]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
        transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)
    
        torch_aug = augmentation_cls(*init_args, **init_kwargs)
        transpiled_init_args = _nest_torch_tensor_to_new_framework(init_args, target)
        transpiled_init_kwargs = _nest_torch_tensor_to_new_framework(init_kwargs, target)
        transpiled_aug = transpiled_cls(*transpiled_init_args, **transpiled_init_kwargs)
    
        # assert dir(torch_aug) == dir(transpiled_aug), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_aug)} != transpiled: {dir(transpiled_aug)}"
    
        torch_out = torch_aug(*call_args, **call_kwargs)
        transpiled_call_args = _nest_torch_tensor_to_new_framework(call_args, target)
        transpiled_call_kwargs = _nest_torch_tensor_to_new_framework(call_kwargs, target)
>       transpiled_out = transpiled_aug(*transpiled_call_args, **transpiled_call_kwargs)

kornia/augmentation/test_augmentation.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=False)
args = (<tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.3132...97],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7f996fd0aa40, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...kexec', code_context=['        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=...597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=False), v = None, buffers = None
args = (<tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.3132...97],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=...597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=False), v = None, buffers = None
args = (<tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.3132...97],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>,)
kwargs = {}
first_arr = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.31326...1597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>
replace_v = False, replace_buffers = False, call_signature = <Signature (input, params=None, **kwargs)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=False),)
kwargs = {'input': <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
       ...597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=False)
input = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.31326...1597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>
params = {'amount_factor': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.5], dtype=float32)>, 'batch_prob': <tf.Tensor:...se, False]],

        [[ True,  True, False],
         [False, False,  True],
         [False, False, False]]]])>, ...}
kwargs = {}, tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f996eca1870>, tensorflow_set_item_bknd = <function tensorflow_set_item_bknd at 0x7f996de9b9a0>
tensor = <function tensorflow_tensor_frnt at 0x7f996effdc60>
in_tensor = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.31326...1597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>
input_shape = ivy.frontends.torch.Size([1, 3, 3, 3]), batch_shape = ivy.frontends.torch.Size([1, 3, 3, 3]), flags = {}

    def call(self, input, params=None, **kwargs):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ..core._backend import tensor
    
        in_tensor = self.__unpack_input__(input)
        input_shape = tensorflow_shape_frnt_(in_tensor)
        in_tensor = self.transform_tensor(in_tensor)
        batch_shape = tensorflow_shape_frnt_(in_tensor)
        if params is None:
            params = self.forward_parameters(batch_shape)
        if "batch_prob" not in params:
            params = tensorflow_set_item_bknd(
                params, "batch_prob", tensor([True] * batch_shape[0])
            )
        params, flags = self._process_kwargs_to_params_and_flags(
            params, self.flags, **kwargs
        )
>       output = self.apply_func(in_tensor, params, flags)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=False)
in_tensor = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.31326...1597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>
params = {'amount_factor': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.5], dtype=float32)>, 'batch_prob': <tf.Tensor:...se, False]],

        [[ True,  True, False],
         [False, False,  True],
         [False, False, False]]]])>, ...}
flags = {}

    def apply_func(self, in_tensor, params, flags=None):
        if flags is None:
            flags = self.flags
        trans_matrix = self.generate_transformation_matrix(in_tensor, params, flags)
>       output = self.transform_inputs(in_tensor, params, flags, trans_matrix)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/base.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=False)
input = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.31326...1597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>
params = {'amount_factor': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.5], dtype=float32)>, 'batch_prob': <tf.Tensor:...se, False]],

        [[ True,  True, False],
         [False, False,  True],
         [False, False, False]]]])>, ...}
flags = {}, transform = <tf.Tensor: shape=(1, 3, 3), dtype=float32, numpy=
array([[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]], dtype=float32)>, kwargs = {}
tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f996eca1870>, tensorflow_all_frnt_ = <function tensorflow_all_frnt_ at 0x7f996eca2200>
tensorflow_any_frnt_ = <function tensorflow_any_frnt_ at 0x7f996ea64430>, tensorflow_get_item = <function tensorflow_get_item at 0x7f996e696200>
tensorflow_is_autocast_enabled = <function tensorflow_is_autocast_enabled at 0x7f996e0ecd30>, tensorflow_type_frnt_ = <function tensorflow_type_frnt_ at 0x7f996ea64040>
tensorflow_index_put_frnt_ = <function tensorflow_index_put_frnt_ at 0x7f996ea65cf0>

    def transform_inputs(self, input, params, flags, transform=None, **kwargs):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_all_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_any_frnt_
        from ...ivy.functional.backends.tensorflow.general import tensorflow_get_item
        from ..utils.helpers import tensorflow_is_autocast_enabled
        from ...ivy.functional.frontends.torch.tensor import tensorflow_type_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_index_put_frnt_
        from .utils.helpers import tensorflow__transform_output_shape
    
        params, flags = self._process_kwargs_to_params_and_flags(
            self._params if params is None else params, flags, **kwargs
        )
        batch_prob = params["batch_prob"]
        to_apply = batch_prob > 0.5
        ori_shape = tensorflow_shape_frnt_(input)
        in_tensor = self.transform_tensor(input)
        self.validate_tensor(in_tensor)
        if tensorflow_all_frnt_(to_apply):
>           output = self.apply_transform(in_tensor, params, flags, transform=transform)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:607: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSaltAndPepperNoise(amount=(0.5, 0.5), salt_and_pepper=(0.5, 0.5), p=1.0, p_batch=1.0, same_on_batch=False)
input = <tf.Tensor: shape=(1, 3, 3, 3), dtype=float32, numpy=
array([[[[0.38088083, 0.22946817, 0.51847845],
         [0.31326...1597],
         [0.9685172 , 0.88856375, 0.03724295],
         [0.9933713 , 0.9039882 , 0.70273316]]]], dtype=float32)>
params = {'amount_factor': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.5], dtype=float32)>, 'batch_prob': <tf.Tensor:...se, False]],

        [[ True,  True, False],
         [False, False,  True],
         [False, False, False]]]])>, ...}
flags = {}, transform = <tf.Tensor: shape=(1, 3, 3), dtype=float32, numpy=
array([[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]], dtype=float32)>

    def apply_transform(self, input, params, flags, transform=None):
        from ....core.check import tensorflow_KORNIA_CHECK
        from .....ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from .....ivy.functional.frontends.torch.tensor import tensorflow_clone_frnt_
        from .....ivy.functional.ivy.general import tensorflow_set_item_bknd
    
        tensorflow_KORNIA_CHECK(
            len(tensorflow_shape_frnt_(input)) in (3, 4), "Wrong input dimension."
        )
        if len(tensorflow_shape_frnt_(input)) == 3:
            input = input[None, :, :, :]
        tensorflow_KORNIA_CHECK(
            tensorflow_shape_frnt_(input)[1] in {3, 1},
            "Number of color channels should be 1 or 3.",
        )
        noisy_image = tensorflow_clone_frnt_(input)
        noisy_image = tensorflow_set_item_bknd(
>           noisy_image, params["mask_salt"].to(input.device), 1.0
        )
E       AttributeError: Exception encountered when calling tensorflow_RandomSaltAndPepperNoise.call().
E       
E       [1m'tensorflow.python.framework.ops.EagerTensor' object has no attribute 'to'[0m
E       
E       Arguments received by tensorflow_RandomSaltAndPepperNoise.call():
E          input=tf.Tensor(shape=(1, 3, 3, 3), dtype=float32)
E          params=None
E          kwargs=<class 'inspect._empty'>

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/intensity/salt_pepper_noise.py:96: AttributeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomSaltAndPepperNoise

Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSaltAndPepperNoise from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
                                                                                                                                                   
Transpilation of RandomSaltAndPepperNoise complete.
______________________________________________________________________________ test_RandomSharpness[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomSharpness(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomSharpness")
    
        init_args = (1.,)
        init_kwargs = {"p": 1.}
        call_args = (torch.rand(1, 1, 5, 5),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomSharpness,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:695: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.sharpness.RandomSharpness'>, target = 'tensorflow', init_args = (1.0,), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[0.6047, 0.0987, 0.4145, 0.5366, 0.8132],
          [0.7589, 0.8596, 0.5801, 0.0752, 0.2177],
          [0...., 0.8472],
          [0.4522, 0.3120, 0.8679, 0.9209, 0.4453],
          [0.2397, 0.5794, 0.8084, 0.5224, 0.9114]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.sharpness.RandomSharpness'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomSharpness
________________________________________________________________________________ test_RandomSnow[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomSnow(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomSnow")
    
        init_args = ()
        init_kwargs = {"p": 1.0, "snow_coefficient": (0.1, 0.6), "brightness": (1.0, 5.0)}
        call_args = (torch.rand(2, 3, 4, 4),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomSnow,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:715: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.random_snow.RandomSnow'>, target = 'tensorflow', init_args = ()
init_kwargs = {'brightness': (1.0, 5.0), 'p': 1.0, 'snow_coefficient': (0.1, 0.6)}
call_args = (tensor([[[[0.4776, 0.4945, 0.1356, 0.5651],
          [0.4523, 0.7602, 0.3171, 0.5997],
          [0.3945, 0.8941, 0...., 0.4532, 0.6130, 0.2554],
          [0.0664, 0.8662, 0.2561, 0.7952],
          [0.3483, 0.9894, 0.9014, 0.3217]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.intensity.random_snow.RandomSnow'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomSnow
______________________________________________________________________________ test_RandomSolarize[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomSolarize(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomSolarize")
    
        init_args = (0.1, 0.1)
        init_kwargs = {"p": 1.}
        call_args = (torch.rand(1, 1, 5, 5),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomSolarize,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:735: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.intensity.solarize.RandomSolarize'>, target = 'tensorflow', init_args = (0.1, 0.1), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[0.1671, 0.2314, 0.2623, 0.5175, 0.3785],
          [0.7948, 0.6254, 0.5254, 0.6849, 0.9398],
          [0...., 0.9051],
          [0.9460, 0.2388, 0.6511, 0.1044, 0.9570],
          [0.2909, 0.5195, 0.7623, 0.7796, 0.7975]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
        transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)
    
        torch_aug = augmentation_cls(*init_args, **init_kwargs)
        transpiled_init_args = _nest_torch_tensor_to_new_framework(init_args, target)
        transpiled_init_kwargs = _nest_torch_tensor_to_new_framework(init_kwargs, target)
        transpiled_aug = transpiled_cls(*transpiled_init_args, **transpiled_init_kwargs)
    
        # assert dir(torch_aug) == dir(transpiled_aug), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_aug)} != transpiled: {dir(transpiled_aug)}"
    
        torch_out = torch_aug(*call_args, **call_kwargs)
        transpiled_call_args = _nest_torch_tensor_to_new_framework(call_args, target)
        transpiled_call_kwargs = _nest_torch_tensor_to_new_framework(call_kwargs, target)
>       transpiled_out = transpiled_aug(*transpiled_call_args, **transpiled_call_kwargs)

kornia/augmentation/test_augmentation.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False)
args = (<tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.378...0439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7f996dc81440, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...kexec', code_context=['        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False), <tf.Tensor: shape=...10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False), v = None, buffers = None
args = (<tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.378...0439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False), <tf.Tensor: shape=...10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False), v = None, buffers = None
args = (<tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.378...0439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>,)
kwargs = {}
first_arr = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.3785....10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>
replace_v = False, replace_buffers = False, call_signature = <Signature (input, params=None, **kwargs)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False),)
kwargs = {'input': <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.517529...10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False)
input = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.3785....10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>
params = {'additions': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([-0.00283392], dtype=float32)>, 'batch_prob': <tf.Ten...y=array([1, 1, 5, 5])>, 'thresholds': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.53417903], dtype=float32)>}
kwargs = {}, tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f996daa7370>, tensorflow_set_item_bknd = <function tensorflow_set_item_bknd at 0x7f996ebbeef0>
tensor = <function tensorflow_tensor_frnt at 0x7f996f596440>
in_tensor = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.3785....10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>
input_shape = ivy.frontends.torch.Size([1, 1, 5, 5]), batch_shape = ivy.frontends.torch.Size([1, 1, 5, 5]), flags = {}

    def call(self, input, params=None, **kwargs):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ..core._backend import tensor
    
        in_tensor = self.__unpack_input__(input)
        input_shape = tensorflow_shape_frnt_(in_tensor)
        in_tensor = self.transform_tensor(in_tensor)
        batch_shape = tensorflow_shape_frnt_(in_tensor)
        if params is None:
            params = self.forward_parameters(batch_shape)
        if "batch_prob" not in params:
            params = tensorflow_set_item_bknd(
                params, "batch_prob", tensor([True] * batch_shape[0])
            )
        params, flags = self._process_kwargs_to_params_and_flags(
            params, self.flags, **kwargs
        )
>       output = self.apply_func(in_tensor, params, flags)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False)
in_tensor = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.3785....10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>
params = {'additions': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([-0.00283392], dtype=float32)>, 'batch_prob': <tf.Ten...y=array([1, 1, 5, 5])>, 'thresholds': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.53417903], dtype=float32)>}
flags = {}

    def apply_func(self, in_tensor, params, flags=None):
        if flags is None:
            flags = self.flags
        trans_matrix = self.generate_transformation_matrix(in_tensor, params, flags)
>       output = self.transform_inputs(in_tensor, params, flags, trans_matrix)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/base.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False)
input = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.3785....10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>
params = {'additions': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([-0.00283392], dtype=float32)>, 'batch_prob': <tf.Ten...y=array([1, 1, 5, 5])>, 'thresholds': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.53417903], dtype=float32)>}
flags = {}, transform = <tf.Tensor: shape=(1, 3, 3), dtype=float32, numpy=
array([[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]], dtype=float32)>, kwargs = {}
tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f996daa7370>, tensorflow_all_frnt_ = <function tensorflow_all_frnt_ at 0x7f996daa6950>
tensorflow_any_frnt_ = <function tensorflow_any_frnt_ at 0x7f996ec0a5f0>, tensorflow_get_item = <function tensorflow_get_item at 0x7f996eb7e710>
tensorflow_is_autocast_enabled = <function tensorflow_is_autocast_enabled at 0x7f996f9eb1c0>, tensorflow_type_frnt_ = <function tensorflow_type_frnt_ at 0x7f996ec0a440>
tensorflow_index_put_frnt_ = <function tensorflow_index_put_frnt_ at 0x7f996ec0a290>

    def transform_inputs(self, input, params, flags, transform=None, **kwargs):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_all_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_any_frnt_
        from ...ivy.functional.backends.tensorflow.general import tensorflow_get_item
        from ..utils.helpers import tensorflow_is_autocast_enabled
        from ...ivy.functional.frontends.torch.tensor import tensorflow_type_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_index_put_frnt_
        from .utils.helpers import tensorflow__transform_output_shape
    
        params, flags = self._process_kwargs_to_params_and_flags(
            self._params if params is None else params, flags, **kwargs
        )
        batch_prob = params["batch_prob"]
        to_apply = batch_prob > 0.5
        ori_shape = tensorflow_shape_frnt_(input)
        in_tensor = self.transform_tensor(input)
        self.validate_tensor(in_tensor)
        if tensorflow_all_frnt_(to_apply):
>           output = self.apply_transform(in_tensor, params, flags, transform=transform)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:607: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomSolarize(thresholds=0.1, additions=0.1, p=1.0, p_batch=1.0, same_on_batch=False)
input = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.3785....10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>
params = {'additions': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([-0.00283392], dtype=float32)>, 'batch_prob': <tf.Ten...y=array([1, 1, 5, 5])>, 'thresholds': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.53417903], dtype=float32)>}
flags = {}, transform = <tf.Tensor: shape=(1, 3, 3), dtype=float32, numpy=
array([[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]], dtype=float32)>

    def apply_transform(self, input, params, flags, transform=None):
        from ....enhance.adjust import tensorflow_solarize
    
        thresholds = params["thresholds"]
        additions: typing.Any
        if "additions" in params:
            additions = params["additions"]
        else:
            additions = None
>       return tensorflow_solarize(input, thresholds, additions)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/intensity/solarize.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = <tf.Tensor: shape=(1, 1, 5, 5), dtype=float32, numpy=
array([[[[0.1671254 , 0.23144561, 0.2623182 , 0.5175292 , 0.3785....10439038, 0.9569793 ],
         [0.29085767, 0.5194797 , 0.7622647 , 0.7795547 , 0.7974819 ]]]],
      dtype=float32)>
thresholds = <tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.53417903], dtype=float32)>, additions = <tf.Tensor: shape=(1,), dtype=float32, numpy=array([-0.00283392], dtype=float32)>

    def tensorflow_solarize(input, thresholds=0.5, additions=None):
        from ...ivy.functional.frontends.torch.creation_ops import tensorflow_as_tensor_frnt
        from ...ivy.functional.frontends.torch.reduction_ops import tensorflow_all_frnt
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_size_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_to_frnt_
        from ...ivy.functional.frontends.torch.indexing_slicing_joining_mutating_ops import (
            tensorflow_stack_frnt,
        )
        from ...ivy.functional.frontends.torch.tensor import tensorflow_expand_frnt_
        from ...ivy.functional.frontends.torch.tensor import tensorflow_clamp_frnt_
    
        if not isinstance(input, (tensorflow.Tensor, tensorflow.Variable)):
            raise TypeError(f"Input type is not a Tensor. Got {type(input)}")
        if not isinstance(thresholds, (float, tensorflow.Tensor, tensorflow.Variable)):
            raise TypeError(
                f"The factor should be either a float or Tensor. Got {type(thresholds)}"
            )
        if isinstance(thresholds, (float,)):
            thresholds = tensorflow_as_tensor_frnt(thresholds)
        if additions is not None:
            if not isinstance(additions, (float, tensorflow.Tensor, tensorflow.Variable)):
                raise TypeError(
                    f"The factor should be either a float or Tensor. Got {type(additions)}"
                )
            if isinstance(additions, (float,)):
                additions = tensorflow_as_tensor_frnt(additions)
>           if not tensorflow_all_frnt((additions < 0.5) * (additions > -0.5)):

Translated_Outputs/tensorflow_outputs/kornia/enhance/adjust.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<tf.Tensor: shape=(1,), dtype=bool, numpy=array([ True])>, <tf.Tensor: shape=(1,), dtype=bool, numpy=array([ True])>), kwargs = {}
arg = <tf.Tensor: shape=(1,), dtype=bool, numpy=array([ True])>

    def rep_method(*args, **kwargs):
        for arg in args:
            if ivy.is_ivy_array(arg):
                return NotImplemented
>       return func(*args, **kwargs)
E       tensorflow.python.framework.errors_impl.InvalidArgumentError: Exception encountered when calling tensorflow_RandomSolarize.call().
E       
E       [1mValue for attr 'T' of bool is not in the list of allowed values: bfloat16, half, float, double, uint8, int8, uint16, int16, int32, uint32, uint64, int64, complex64, complex128
E       	; NodeDef: {{node Mul}}; Op<name=Mul; signature=x:T, y:T -> z:T; attr=T:type,allowed=[DT_BFLOAT16, DT_HALF, DT_FLOAT, DT_DOUBLE, DT_UINT8, DT_INT8, DT_UINT16, DT_INT16, DT_INT32, DT_UINT32, DT_UINT64, DT_INT64, DT_COMPLEX64, DT_COMPLEX128]; is_commutative=true> [Op:Mul] name: [0m
E       
E       Arguments received by tensorflow_RandomSolarize.call():
E          input=tf.Tensor(shape=(1, 1, 5, 5), dtype=float32)
E          params=None
E          kwargs=<class 'inspect._empty'>

../ivy/ivy/functional/backends/tensorflow/__init__.py:40: InvalidArgumentError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomSolarize

Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomSolarize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                         
Transpilation of RandomSolarize complete.
________________________________________________________________________________ test_CenterCrop[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_CenterCrop(target_framework, mode, backend_compile):
        print("kornia.augmentation.CenterCrop")
    
        init_args = (2,)
        init_kwargs = {"p": 1., "cropping_mode": "resample"}
        call_args = (torch.randn(1, 1, 4, 4),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.CenterCrop,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.center_crop.CenterCrop'>, target = 'tensorflow', init_args = (2,), init_kwargs = {'cropping_mode': 'resample', 'p': 1.0}
call_args = (tensor([[[[ 1.0971,  1.4895,  0.3803, -0.7936],
          [-0.2056, -1.4566,  1.8180, -1.2982],
          [ 1.2170, -0.3980,  0.0202,  0.2263],
          [ 0.4348,  2.4527,  1.3735,  1.3700]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.center_crop.CenterCrop'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.CenterCrop
___________________________________________________________________________________ test_PadTo[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PadTo(target_framework, mode, backend_compile):
        print("kornia.augmentation.PadTo")
    
        init_args = ((4, 5),)
        init_kwargs = {"pad_value": 1.}
        call_args = (torch.tensor([[[[0., 0., 0.],
                                     [0., 0., 0.],
                                     [0., 0., 0.]]]]),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.PadTo,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.pad.PadTo'>, target = 'tensorflow', init_args = ((4, 5),), init_kwargs = {'pad_value': 1.0}
call_args = (tensor([[[[0., 0., 0.],
          [0., 0., 0.],
          [0., 0., 0.]]]]),), call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.pad.PadTo'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.PadTo
________________________________________________________________________________ test_RandomCrop[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomCrop(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomCrop")
    
        init_args = ((2, 2),)
        init_kwargs = {"p": 1., "cropping_mode": "resample"}
        call_args = (torch.arange(1*1*3*3.).view(1, 1, 3, 3),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomCrop,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:821: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.crop.RandomCrop'>, target = 'tensorflow', init_args = ((2, 2),), init_kwargs = {'cropping_mode': 'resample', 'p': 1.0}
call_args = (tensor([[[[0., 1., 2.],
          [3., 4., 5.],
          [6., 7., 8.]]]]),), call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.crop.RandomCrop'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomCrop
__________________________________________________________________________ test_RandomElasticTransform[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomElasticTransform(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomElasticTransform")
    
        init_args = ()
        init_kwargs = {}
        call_args = (torch.ones(1, 1, 2, 2),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomElasticTransform,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.elastic_transform.RandomElasticTransform'>, target = 'tensorflow', init_args = (), init_kwargs = {}
call_args = (tensor([[[[1., 1.],
          [1., 1.]]]]),), call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.elastic_transform.RandomElasticTransform'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomElasticTransform
_____________________________________________________________________________ test_RandomPerspective[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomPerspective(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomPerspective")
    
        init_args = (0.5,)
        init_kwargs = {"p": 0.5}
        call_args = (torch.tensor([[[[1., 0., 0.],
                                     [0., 1., 0.],
                                     [0., 0., 1.]]]]),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomPerspective,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:929: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.perspective.RandomPerspective'>, target = 'tensorflow', init_args = (0.5,), init_kwargs = {'p': 0.5}
call_args = (tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]]),), call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.perspective.RandomPerspective'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomPerspective
_____________________________________________________________________________ test_RandomResizedCrop[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomResizedCrop(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomResizedCrop")
    
        init_args = ()
        init_kwargs = {"size": (3, 3), "scale": (3., 3.), "ratio": (2., 2.), "p": 1., "cropping_mode": "resample"}
        call_args = (torch.tensor([[[0., 1., 2.],
                                    [3., 4., 5.],
                                    [6., 7., 8.]]]),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomResizedCrop,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:951: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.resized_crop.RandomResizedCrop'>, target = 'tensorflow', init_args = ()
init_kwargs = {'cropping_mode': 'resample', 'p': 1.0, 'ratio': (2.0, 2.0), 'scale': (3.0, 3.0), ...}, call_args = (tensor([[[0., 1., 2.],
         [3., 4., 5.],
         [6., 7., 8.]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.resized_crop.RandomResizedCrop'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomResizedCrop
______________________________________________________________________________ test_RandomRotation[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomRotation(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomRotation")
    
        init_args = ()
        init_kwargs = {"degrees": 45.0, "p": 1.}
        call_args = (torch.tensor([[1., 0., 0., 2.],
                                   [0., 0., 0., 0.],
                                   [0., 1., 2., 0.],
                                   [0., 0., 1., 2.]]),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomRotation,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:974: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.rotation.RandomRotation'>, target = 'tensorflow', init_args = (), init_kwargs = {'degrees': 45.0, 'p': 1.0}
call_args = (tensor([[1., 0., 0., 2.],
        [0., 0., 0., 0.],
        [0., 1., 2., 0.],
        [0., 0., 1., 2.]]),), call_kwargs = {}, deterministic_output = False, backend_compile = False
tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
        transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)
    
        torch_aug = augmentation_cls(*init_args, **init_kwargs)
        transpiled_init_args = _nest_torch_tensor_to_new_framework(init_args, target)
        transpiled_init_kwargs = _nest_torch_tensor_to_new_framework(init_kwargs, target)
        transpiled_aug = transpiled_cls(*transpiled_init_args, **transpiled_init_kwargs)
    
        # assert dir(torch_aug) == dir(transpiled_aug), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_aug)} != transpiled: {dir(transpiled_aug)}"
    
        torch_out = torch_aug(*call_args, **call_kwargs)
        transpiled_call_args = _nest_torch_tensor_to_new_framework(call_args, target)
        transpiled_call_kwargs = _nest_torch_tensor_to_new_framework(call_kwargs, target)
>       transpiled_out = transpiled_aug(*transpiled_call_args, **transpiled_call_kwargs)

kornia/augmentation/test_augmentation.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=True)
args = (<tf.Tensor: shape=(4, 4), dtype=float32, numpy=
array([[1., 0., 0., 2.],
       [0., 0., 0., 0.],
       [0., 1., 2., 0.],
       [0., 0., 1., 2.]], dtype=float32)>,), kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7f996e514440, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...kexec', code_context=['        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=Tru...=
array([[1., 0., 0., 2.],
       [0., 0., 0., 0.],
       [0., 1., 2., 0.],
       [0., 0., 1., 2.]], dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=True), v = None, buffers = None
args = (<tf.Tensor: shape=(4, 4), dtype=float32, numpy=
array([[1., 0., 0., 2.],
       [0., 0., 0., 0.],
       [0., 1., 2., 0.],
       [0., 0., 1., 2.]], dtype=float32)>,), kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=Tru...=
array([[1., 0., 0., 2.],
       [0., 0., 0., 0.],
       [0., 1., 2., 0.],
       [0., 0., 1., 2.]], dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=True), v = None, buffers = None
args = (<tf.Tensor: shape=(4, 4), dtype=float32, numpy=
array([[1., 0., 0., 2.],
       [0., 0., 0., 0.],
       [0., 1., 2., 0.],
       [0., 0., 1., 2.]], dtype=float32)>,), kwargs = {}
first_arr = <tf.Tensor: shape=(4, 4), dtype=float32, numpy=
array([[1., 0., 0., 2.],
       [0., 0., 0., 0.],
       [0., 1., 2., 0.],
       [0., 0., 1., 2.]], dtype=float32)>, replace_v = False
replace_buffers = False, call_signature = <Signature (input, params=None, **kwargs)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=True),)
kwargs = {'input': <tf.Tensor: shape=(4, 4), dtype=float32, numpy=
array([[1., 0., 0., 2.],
       [0., 0., 0., 0.],
       [0., 1., 2., 0.],
       [0., 0., 1., 2.]], dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=True)
input = <tf.Tensor: shape=(4, 4), dtype=float32, numpy=
array([[1., 0., 0., 2.],
       [0., 0., 0., 0.],
       [0., 1., 2., 0.],
       [0., 0., 1., 2.]], dtype=float32)>
params = {'batch_prob': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([1.], dtype=float32)>, 'degrees': <tf.Tensor: shape=...([-36.462463], dtype=float32)>, 'forward_input_shape': <tf.Tensor: shape=(4,), dtype=int64, numpy=array([1, 1, 4, 4])>}
kwargs = {}, tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f996ec560e0>, tensorflow_set_item_bknd = <function tensorflow_set_item_bknd at 0x7f996d8372e0>
tensor = <function tensorflow_tensor_frnt at 0x7f996e4d09d0>
in_tensor = <tf.Tensor: shape=(1, 1, 4, 4), dtype=float32, numpy=
array([[[[1., 0., 0., 2.],
         [0., 0., 0., 0.],
         [0., 1., 2., 0.],
         [0., 0., 1., 2.]]]], dtype=float32)>
input_shape = ivy.frontends.torch.Size([4, 4]), batch_shape = ivy.frontends.torch.Size([1, 1, 4, 4]), flags = {'align_corners': True, 'resample': <tensorflow_Resample.BILINEAR: 1>}

    def call(self, input, params=None, **kwargs):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ..core._backend import tensor
    
        in_tensor = self.__unpack_input__(input)
        input_shape = tensorflow_shape_frnt_(in_tensor)
        in_tensor = self.transform_tensor(in_tensor)
        batch_shape = tensorflow_shape_frnt_(in_tensor)
        if params is None:
            params = self.forward_parameters(batch_shape)
        if "batch_prob" not in params:
            params = tensorflow_set_item_bknd(
                params, "batch_prob", tensor([True] * batch_shape[0])
            )
        params, flags = self._process_kwargs_to_params_and_flags(
            params, self.flags, **kwargs
        )
>       output = self.apply_func(in_tensor, params, flags)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=True)
in_tensor = <tf.Tensor: shape=(1, 1, 4, 4), dtype=float32, numpy=
array([[[[1., 0., 0., 2.],
         [0., 0., 0., 0.],
         [0., 1., 2., 0.],
         [0., 0., 1., 2.]]]], dtype=float32)>
params = {'batch_prob': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([1.], dtype=float32)>, 'degrees': <tf.Tensor: shape=...([-36.462463], dtype=float32)>, 'forward_input_shape': <tf.Tensor: shape=(4,), dtype=int64, numpy=array([1, 1, 4, 4])>}
flags = {'align_corners': True, 'resample': <tensorflow_Resample.BILINEAR: 1>}

    def apply_func(self, in_tensor, params, flags=None):
        if flags is None:
            flags = self.flags
>       trans_matrix = self.generate_transformation_matrix(in_tensor, params, flags)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/base.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=True)
input = <tf.Tensor: shape=(1, 1, 4, 4), dtype=float32, numpy=
array([[[[1., 0., 0., 2.],
         [0., 0., 0., 0.],
         [0., 1., 2., 0.],
         [0., 0., 1., 2.]]]], dtype=float32)>
params = {'batch_prob': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([1.], dtype=float32)>, 'degrees': <tf.Tensor: shape=...([-36.462463], dtype=float32)>, 'forward_input_shape': <tf.Tensor: shape=(4,), dtype=int64, numpy=array([1, 1, 4, 4])>}
flags = {'align_corners': True, 'resample': <tensorflow_Resample.BILINEAR: 1>}

    def generate_transformation_matrix(self, input, params, flags):
        from ....ivy.functional.frontends.torch.tensor import tensorflow_any_frnt_
        from ....ivy.functional.frontends.torch.tensor import tensorflow_all_frnt_
        from ....ivy.functional.backends.tensorflow.general import tensorflow_get_item
        from ...utils.helpers import tensorflow_is_autocast_enabled
        from ....ivy.functional.frontends.torch.tensor import tensorflow_type_frnt_
        from ....ivy.functional.frontends.torch.tensor import tensorflow_index_put_frnt_
    
        batch_prob = params["batch_prob"]
        to_apply = batch_prob > 0.5
        in_tensor = self.transform_tensor(input)
        if not tensorflow_any_frnt_(to_apply):
            trans_matrix = self.identity_matrix(in_tensor)
        elif tensorflow_all_frnt_(to_apply):
>           trans_matrix = self.compute_transformation(
                in_tensor, params=params, flags=flags
            )

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/base.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomRotation(degrees=45.0, p=1.0, p_batch=1.0, same_on_batch=False, resample=bilinear, align_corners=True)
input = <tf.Tensor: shape=(1, 1, 4, 4), dtype=float32, numpy=
array([[[[1., 0., 0., 2.],
         [0., 0., 0., 0.],
         [0., 1., 2., 0.],
         [0., 0., 1., 2.]]]], dtype=float32)>
params = {'batch_prob': <tf.Tensor: shape=(1,), dtype=float32, numpy=array([1.], dtype=float32)>, 'degrees': <tf.Tensor: shape=...([-36.462463], dtype=float32)>, 'forward_input_shape': <tf.Tensor: shape=(4,), dtype=int64, numpy=array([1, 1, 4, 4])>}
flags = {'align_corners': True, 'resample': <tensorflow_Resample.BILINEAR: 1>}

    def compute_transformation(self, input, params, flags):
        from .....ivy.functional.frontends.torch.tensor import tensorflow_to_frnt_
        from ....geometry.transform.affwarp import tensorflow__compute_tensor_center
        from ....geometry.transform.affwarp import tensorflow__compute_rotation_matrix
        from .....ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ....utils.misc import tensorflow_eye_like
        from .....ivy.functional.ivy.general import tensorflow_set_item_bknd
    
        angles: typing.Any = tensorflow_to_frnt_(params["degrees"], input)
        center: typing.Any = tensorflow__compute_tensor_center(input)
        rotation_mat: typing.Any = tensorflow__compute_rotation_matrix(
>           angles, center.expand(tensorflow_shape_frnt_(angles)[0], -1)
        )
E       AttributeError: Exception encountered when calling tensorflow_RandomRotation.call().
E       
E       [1m'tensorflow.python.framework.ops.EagerTensor' object has no attribute 'expand'[0m
E       
E       Arguments received by tensorflow_RandomRotation.call():
E          input=tf.Tensor(shape=(4, 4), dtype=float32)
E          params=None
E          kwargs=<class 'inspect._empty'>

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/geometric/rotation.py:67: AttributeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomRotation

Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomRotation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                         
Transpilation of RandomRotation complete.
___________________________________________________________________________ test_RandomThinPlateSpline[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomThinPlateSpline(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomThinPlateSpline")
    
        init_args = ()
        init_kwargs = {}
        call_args = (torch.randn(1, 3, 32, 32),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomThinPlateSpline,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.thin_plate_spline.RandomThinPlateSpline'>, target = 'tensorflow', init_args = (), init_kwargs = {}
call_args = (tensor([[[[-0.7683,  0.8075,  0.7043,  ...,  0.5439,  0.9216, -1.3446],
          [-0.1379, -1.0056,  0.4376,  ..., -...-1.3904,  ..., -0.4168,  1.4056,  0.3710],
          [-0.0817,  0.4028, -0.1722,  ..., -0.5317,  1.8059, -0.2515]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.thin_plate_spline.RandomThinPlateSpline'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomThinPlateSpline
____________________________________________________________________________ test_RandomVerticalFlip[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomVerticalFlip(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomVerticalFlip")
    
        init_args = ()
        init_kwargs = {"p": 1.}
        call_args = (torch.randn(1, 3, 32, 32),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomVerticalFlip,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1034: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.vertical_flip.RandomVerticalFlip'>, target = 'tensorflow', init_args = (), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[ 9.5746e-01,  7.1898e-01,  2.6468e-01,  ..., -2.1606e+00,
           -8.0543e-02,  9.0345e-01],
          ...9e+00],
          [-2.4644e+00,  3.0303e+00, -5.1274e-02,  ...,  2.0805e-01,
           -2.3891e-01,  2.6922e+00]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.vertical_flip.RandomVerticalFlip'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomVerticalFlip
______________________________________________________________________________ test_RandomCutMixV2[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomCutMixV2(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomCutMixV2")
    
        input = torch.rand(2, 1, 3, 3)
        input[0] = torch.ones((1, 3, 3))
        label = torch.tensor([0, 1])
    
        init_args = ()
        init_kwargs = {"data_keys": ["input", "class"]}
        call_args = (input, label)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomCutMixV2,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1058: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.mix.cutmix.RandomCutMixV2'>, target = 'tensorflow', init_args = (), init_kwargs = {'data_keys': ['input', 'class']}
call_args = (tensor([[[[1.0000, 1.0000, 1.0000],
          [1.0000, 1.0000, 1.0000],
          [1.0000, 1.0000, 1.0000]]],


        [[[0.7692, 0.4501, 0.7397],
          [0.0354, 0.3782, 0.8625],
          [0.5765, 0.6304, 0.9294]]]]), tensor([0, 1]))
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.mix.cutmix.RandomCutMixV2'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: source code not available

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomCutMixV2

Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomCutMixV2 from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                         
_______________________________________________________________________________ test_RandomJigsaw[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomJigsaw(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomJigsaw")
    
        init_args = ((4, 4),)
        init_kwargs = {}
        call_args = (torch.randn(8, 3, 256, 256),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomJigsaw,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1078: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.mix.jigsaw.RandomJigsaw'>, target = 'tensorflow', init_args = ((4, 4),), init_kwargs = {}
call_args = (tensor([[[[ 7.7170e-01,  4.3589e-01, -4.8907e-01,  ..., -1.2441e+00,
           -4.5059e-01,  1.4217e+00],
          ...2e+00],
          [ 6.0465e-01, -1.6005e+00, -1.0840e+00,  ...,  7.2859e-01,
           -4.8642e-01, -9.3090e-01]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
        transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)
    
        torch_aug = augmentation_cls(*init_args, **init_kwargs)
        transpiled_init_args = _nest_torch_tensor_to_new_framework(init_args, target)
        transpiled_init_kwargs = _nest_torch_tensor_to_new_framework(init_kwargs, target)
        transpiled_aug = transpiled_cls(*transpiled_init_args, **transpiled_init_kwargs)
    
        # assert dir(torch_aug) == dir(transpiled_aug), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_aug)} != transpiled: {dir(transpiled_aug)}"
    
        torch_out = torch_aug(*call_args, **call_kwargs)
        transpiled_call_args = _nest_torch_tensor_to_new_framework(call_args, target)
        transpiled_call_kwargs = _nest_torch_tensor_to_new_framework(call_kwargs, target)
>       transpiled_out = transpiled_aug(*transpiled_call_args, **transpiled_call_kwargs)

kornia/augmentation/test_augmentation.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomJigsaw(grid=(4, 4), p=0.5, p_batch=1.0, same_on_batch=False, grid=(4, 4))
args = (<tf.Tensor: shape=(8, 3, 256, 256), dtype=float32, numpy=
array([[[[ 7.71701932e-01,  4.35894787e-01, -4.89066035e-01...306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7f996e638a40, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...kexec', code_context=['        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomJigsaw(grid=(4, 4), p=0.5, p_batch=1.0, same_on_batch=False, grid=(4, 4)), <tf.Tensor: shape=(8, 3, ...8306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomJigsaw(grid=(4, 4), p=0.5, p_batch=1.0, same_on_batch=False, grid=(4, 4)), v = None, buffers = None
args = (<tf.Tensor: shape=(8, 3, 256, 256), dtype=float32, numpy=
array([[[[ 7.71701932e-01,  4.35894787e-01, -4.89066035e-01...306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomJigsaw(grid=(4, 4), p=0.5, p_batch=1.0, same_on_batch=False, grid=(4, 4)), <tf.Tensor: shape=(8, 3, ...8306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomJigsaw(grid=(4, 4), p=0.5, p_batch=1.0, same_on_batch=False, grid=(4, 4)), v = None, buffers = None
args = (<tf.Tensor: shape=(8, 3, 256, 256), dtype=float32, numpy=
array([[[[ 7.71701932e-01,  4.35894787e-01, -4.89066035e-01...306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>,)
kwargs = {}
first_arr = <tf.Tensor: shape=(8, 3, 256, 256), dtype=float32, numpy=
array([[[[ 7.71701932e-01,  4.35894787e-01, -4.89066035e-01,...48306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>
replace_v = False, replace_buffers = False, call_signature = <Signature (*input, params=None, data_keys=None)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomJigsaw(grid=(4, 4), p=0.5, p_batch=1.0, same_on_batch=False, grid=(4, 4)),)
kwargs = {'input': <tf.Tensor: shape=(8, 3, 256, 256), dtype=float32, numpy=
array([[[[ 7.71701932e-01,  4.35894787e-01, -4.890...8306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Signature (*input, params=None, data_keys=None)>, args = ()
kwargs = {'input': <tf.Tensor: shape=(8, 3, 256, 256), dtype=float32, numpy=
array([[[[ 7.71701932e-01,  4.35894787e-01, -4.890...8306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>}

    def bind(self, /, *args, **kwargs):
        """Get a BoundArguments object, that maps the passed `args`
        and `kwargs` to the function's signature.  Raises `TypeError`
        if the passed arguments can not be bound.
        """
>       return self._bind(args, kwargs)

/opt/miniconda/envs/multienv/lib/python3.10/inspect.py:3177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Signature (*input, params=None, data_keys=None)>, args = ()
kwargs = {'input': <tf.Tensor: shape=(8, 3, 256, 256), dtype=float32, numpy=
array([[[[ 7.71701932e-01,  4.35894787e-01, -4.890...8306e+00, -1.08400011e+00, ...,
           7.28591681e-01, -4.86416310e-01, -9.30901349e-01]]]],
      dtype=float32)>}

    def _bind(self, args, kwargs, *, partial=False):
        """Private method. Don't use directly."""
    
        arguments = {}
    
        parameters = iter(self.parameters.values())
        parameters_ex = ()
        arg_vals = iter(args)
    
        while True:
            # Let's iterate through the positional arguments and corresponding
            # parameters
            try:
                arg_val = next(arg_vals)
            except StopIteration:
                # No more positional arguments
                try:
                    param = next(parameters)
                except StopIteration:
                    # No more parameters. That's it. Just need to check that
                    # we have no `kwargs` after this while loop
                    break
                else:
                    if param.kind == _VAR_POSITIONAL:
                        # That's OK, just empty *args.  Let's start parsing
                        # kwargs
                        break
                    elif param.name in kwargs:
                        if param.kind == _POSITIONAL_ONLY:
                            msg = '{arg!r} parameter is positional only, ' \
                                  'but was passed as a keyword'
                            msg = msg.format(arg=param.name)
                            raise TypeError(msg) from None
                        parameters_ex = (param,)
                        break
                    elif (param.kind == _VAR_KEYWORD or
                                                param.default is not _empty):
                        # That's fine too - we have a default value for this
                        # parameter.  So, lets start parsing `kwargs`, starting
                        # with the current parameter
                        parameters_ex = (param,)
                        break
                    else:
                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,
                        # not in `kwargs`
                        if partial:
                            parameters_ex = (param,)
                            break
                        else:
                            msg = 'missing a required argument: {arg!r}'
                            msg = msg.format(arg=param.name)
                            raise TypeError(msg) from None
            else:
                # We have a positional argument to process
                try:
                    param = next(parameters)
                except StopIteration:
                    raise TypeError('too many positional arguments') from None
                else:
                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
                        # Looks like we have no parameter for this positional
                        # argument
                        raise TypeError(
                            'too many positional arguments') from None
    
                    if param.kind == _VAR_POSITIONAL:
                        # We have an '*args'-like argument, let's fill it with
                        # all positional arguments we have left and move on to
                        # the next phase
                        values = [arg_val]
                        values.extend(arg_vals)
                        arguments[param.name] = tuple(values)
                        break
    
                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:
                        raise TypeError(
                            'multiple values for argument {arg!r}'.format(
                                arg=param.name)) from None
    
                    arguments[param.name] = arg_val
    
        # Now, we iterate through the remaining parameters to process
        # keyword arguments
        kwargs_param = None
        for param in itertools.chain(parameters_ex, parameters):
            if param.kind == _VAR_KEYWORD:
                # Memorize that we have a '**kwargs'-like parameter
                kwargs_param = param
                continue
    
            if param.kind == _VAR_POSITIONAL:
                # Named arguments don't refer to '*args'-like parameters.
                # We only arrive here if the positional arguments ended
                # before reaching the last parameter before *args.
                continue
    
            param_name = param.name
            try:
                arg_val = kwargs.pop(param_name)
            except KeyError:
                # We have no value for this parameter.  It's fine though,
                # if it has a default value, or it is an '*args'-like
                # parameter, left alone by the processing of positional
                # arguments.
                if (not partial and param.kind != _VAR_POSITIONAL and
                                                    param.default is _empty):
                    raise TypeError('missing a required argument: {arg!r}'. \
                                    format(arg=param_name)) from None
    
            else:
                if param.kind == _POSITIONAL_ONLY:
                    # This should never happen in case of a properly built
                    # Signature object (but let's have this check here
                    # to ensure correct behaviour just in case)
                    raise TypeError('{arg!r} parameter is positional only, '
                                    'but was passed as a keyword'. \
                                    format(arg=param.name))
    
                arguments[param_name] = arg_val
    
        if kwargs:
            if kwargs_param is not None:
                # Process our '**kwargs'-like parameter
                arguments[kwargs_param.name] = kwargs
            else:
>               raise TypeError(
                    'got an unexpected keyword argument {arg!r}'.format(
                        arg=next(iter(kwargs))))
E               TypeError: got an unexpected keyword argument 'input'

/opt/miniconda/envs/multienv/lib/python3.10/inspect.py:3166: TypeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomJigsaw

Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomJigsaw from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                       
Transpilation of RandomJigsaw complete.
_______________________________________________________________________________ test_RandomMixUpV2[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomMixUpV2(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomMixUpV2")
    
        init_args = ()
        init_kwargs = {"data_keys": ["input", "class"]}
        call_args = (torch.rand(2, 1, 3, 3), torch.tensor([0, 1]))
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomMixUpV2,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1098: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.mix.mixup.RandomMixUpV2'>, target = 'tensorflow', init_args = (), init_kwargs = {'data_keys': ['input', 'class']}
call_args = (tensor([[[[0.9623, 0.8319, 0.0885],
          [0.9072, 0.0433, 0.3119],
          [0.6674, 0.2109, 0.4358]]],


        [[[0.3472, 0.2073, 0.0846],
          [0.3901, 0.4308, 0.4113],
          [0.8229, 0.6689, 0.5397]]]]), tensor([0, 1]))
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.mix.mixup.RandomMixUpV2'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomMixUpV2
_______________________________________________________________________________ test_RandomMosaic[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomMosaic(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomMosaic")
    
        init_args = ((300, 300),)
        init_kwargs = {"data_keys": ["input", "bbox_xyxy"]}
        call_args = (
            torch.randn(8, 3, 224, 224),
            torch.tensor([[
                [70, 5, 150, 100],
                [60, 180, 175, 220],
            ]]).repeat(8, 1, 1),
        )
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomMosaic,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.mix.mosaic.RandomMosaic'>, target = 'tensorflow', init_args = ((300, 300),), init_kwargs = {'data_keys': ['input', 'bbox_xyxy']}
call_args = (tensor([[[[ 7.4212e-01, -3.8790e-01, -2.4848e+00,  ..., -2.0935e-01,
            3.3792e-02, -5.3436e-03],
          ...[ 70,   5, 150, 100],
         [ 60, 180, 175, 220]],

        [[ 70,   5, 150, 100],
         [ 60, 180, 175, 220]]]))
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.mix.mosaic.RandomMosaic'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomMosaic
___________________________________________________________________________ test_RandomTransplantation[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomTransplantation(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomTransplantation")
    
        init_args = ()
        init_kwargs = {"p": 1.}
        call_args = (torch.randn(2, 3, 5, 5), torch.randint(0, 3, (2, 5, 5)))
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomTransplantation,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.mix.transplantation.RandomTransplantation'>, target = 'tensorflow', init_args = (), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[ 1.7161,  0.1897, -1.7843, -1.6939,  0.5456],
          [ 0.3502,  0.3311, -0.3730, -0.2191,  1.3636],
   ...0, 1, 1, 2],
         [0, 2, 0, 2, 2],
         [1, 0, 0, 0, 0],
         [2, 0, 2, 2, 0],
         [1, 1, 1, 2, 1]]]))
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
        transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)
    
        torch_aug = augmentation_cls(*init_args, **init_kwargs)
        transpiled_init_args = _nest_torch_tensor_to_new_framework(init_args, target)
        transpiled_init_kwargs = _nest_torch_tensor_to_new_framework(init_kwargs, target)
        transpiled_aug = transpiled_cls(*transpiled_init_args, **transpiled_init_kwargs)
    
        # assert dir(torch_aug) == dir(transpiled_aug), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_aug)} != transpiled: {dir(transpiled_aug)}"
    
        torch_out = torch_aug(*call_args, **call_kwargs)
        transpiled_call_args = _nest_torch_tensor_to_new_framework(call_args, target)
        transpiled_call_kwargs = _nest_torch_tensor_to_new_framework(call_kwargs, target)
>       transpiled_out = transpiled_aug(*transpiled_call_args, **transpiled_call_kwargs)

kornia/augmentation/test_augmentation.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomTransplantation(p=1.0, p_batch=1.0, same_on_batch=False)
args = (<tf.Tensor: shape=(2, 3, 5, 5), dtype=float32, numpy=
array([[[[ 1.7160689 ,  0.18971223, -1.7842503 , -1.6939318 ,
 ...1, 0, 1, 1, 2],
        [0, 2, 0, 2, 2],
        [1, 0, 0, 0, 0],
        [2, 0, 2, 2, 0],
        [1, 1, 1, 2, 1]]])>)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7f996d849240, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...kexec', code_context=['        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomTransplantation(p=1.0, p_batch=1.0, same_on_batch=False), <tf.Tensor: shape=(2, 3, 5, 5), dtype=floa...1, 0, 1, 1, 2],
        [0, 2, 0, 2, 2],
        [1, 0, 0, 0, 0],
        [2, 0, 2, 2, 0],
        [1, 1, 1, 2, 1]]])>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomTransplantation(p=1.0, p_batch=1.0, same_on_batch=False), v = None, buffers = None
args = (<tf.Tensor: shape=(2, 3, 5, 5), dtype=float32, numpy=
array([[[[ 1.7160689 ,  0.18971223, -1.7842503 , -1.6939318 ,
 ...1, 0, 1, 1, 2],
        [0, 2, 0, 2, 2],
        [1, 0, 0, 0, 0],
        [2, 0, 2, 2, 0],
        [1, 1, 1, 2, 1]]])>)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomTransplantation(p=1.0, p_batch=1.0, same_on_batch=False), <tf.Tensor: shape=(2, 3, 5, 5), dtype=floa...1, 0, 1, 1, 2],
        [0, 2, 0, 2, 2],
        [1, 0, 0, 0, 0],
        [2, 0, 2, 2, 0],
        [1, 1, 1, 2, 1]]])>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomTransplantation(p=1.0, p_batch=1.0, same_on_batch=False), v = None, buffers = None
args = (<tf.Tensor: shape=(2, 3, 5, 5), dtype=float32, numpy=
array([[[[ 1.7160689 ,  0.18971223, -1.7842503 , -1.6939318 ,
 ...1, 0, 1, 1, 2],
        [0, 2, 0, 2, 2],
        [1, 0, 0, 0, 0],
        [2, 0, 2, 2, 0],
        [1, 1, 1, 2, 1]]])>)
kwargs = {}
first_arr = <tf.Tensor: shape=(2, 3, 5, 5), dtype=float32, numpy=
array([[[[ 1.7160689 ,  0.18971223, -1.7842503 , -1.6939318 ,
  ...  1.1652881 ],
         [ 1.098211  , -0.6339601 , -0.0665732 ,  0.7921285 ,
           0.8569834 ]]]], dtype=float32)>
replace_v = False, replace_buffers = False, call_signature = <Signature (*input, params=None, data_keys=None, **kwargs)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_RandomTransplantation(p=1.0, p_batch=1.0, same_on_batch=False),)
kwargs = {'input': <tf.Tensor: shape=(2, 3, 5, 5), dtype=float32, numpy=
array([[[[ 1.7160689 ,  0.18971223, -1.7842503 , -1.69...1, 0, 1, 1, 2],
        [0, 2, 0, 2, 2],
        [1, 0, 0, 0, 0],
        [2, 0, 2, 2, 0],
        [1, 1, 1, 2, 1]]])>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_RandomTransplantation(p=1.0, p_batch=1.0, same_on_batch=False)
params = <tf.Tensor: shape=(2, 5, 5), dtype=int64, numpy=
array([[[0, 2, 2, 1, 2],
        [2, 2, 0, 2, 2],
        [0, 1, 1, 2...[1, 0, 1, 1, 2],
        [0, 2, 0, 2, 2],
        [1, 0, 0, 0, 0],
        [2, 0, 2, 2, 0],
        [1, 1, 1, 2, 1]]])>
data_keys = None, input = ()
kwargs = {'input': <tf.Tensor: shape=(2, 3, 5, 5), dtype=float32, numpy=
array([[[[ 1.7160689 ,  0.18971223, -1.7842503 , -1.69... 1.1652881 ],
         [ 1.098211  , -0.6339601 , -0.0665732 ,  0.7921285 ,
           0.8569834 ]]]], dtype=float32)>}
tensorflow_get_item = <function tensorflow_get_item at 0x7f9977c79120>, tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f996e5693f0>
tensorflow_clone_frnt_ = <function tensorflow_clone_frnt_ at 0x7f996d8e96c0>, tensorflow__validate_input_dtype = <function tensorflow__validate_input_dtype at 0x7f996d44d360>
tensorflow_index_put_frnt_ = <function tensorflow_index_put_frnt_ at 0x7f996d8ebc70>, keys = [<tensorflow_DataKey.IMAGE: 0>, <tensorflow_DataKey.MASK: 1>]

    def call(self, *input, params=None, data_keys=None, **kwargs):
        from ....constants import tensorflow_DataKey
        from .....ivy.functional.backends.tensorflow.general import tensorflow_get_item
        from .....ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from .....ivy.functional.frontends.torch.tensor import tensorflow_clone_frnt_
        from ...utils.helpers import tensorflow__validate_input_dtype
        from .....ivy.functional.frontends.torch.tensor import (
            tensorflow_index_put_frnt_,
        )
    
        keys: typing.Any
        if data_keys is None:
            keys = self.data_keys
        else:
            keys = [tensorflow_DataKey.get(inp) for inp in data_keys]
        if params is None:
            mask: typing.Any = tensorflow_get_item(
                input, keys.index(tensorflow_DataKey.MASK)
            )
            self._params = self.forward_parameters(tensorflow_shape_frnt_(mask))
        else:
            self._params = params
>       if any(
            k not in self._params
            for k in ["acceptor_indices", "donor_indices", "selection"]
        ):

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/mix/transplantation.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <tuple_iterator object at 0x7f996d789720>

    if any(
>       k not in self._params
        for k in ["acceptor_indices", "donor_indices", "selection"]
    ):

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/mix/transplantation.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<tf.Tensor: shape=(5, 5), dtype=int64, numpy=
array([[0, 2, 2, 1, 2],
       [2, 2, 0, 2, 2],
       [0, 1, 1, 2, 0],
       [2, 2, 1, 1, 0],
       [0, 2, 0, 2, 0]])>, 'acceptor_indices')
kwargs = {}, arg = 'acceptor_indices'

    def rep_method(*args, **kwargs):
        for arg in args:
            if ivy.is_ivy_array(arg):
                return NotImplemented
>       return func(*args, **kwargs)
E       TypeError: Exception encountered when calling tensorflow_RandomTransplantation.call().
E       
E       [1mdata type 'acceptor_indices' not understood[0m
E       
E       Arguments received by tensorflow_RandomTransplantation.call():
E          input=<class 'inspect._empty'>
E          params=tf.Tensor(shape=(2, 5, 5), dtype=int64)
E          data_keys=None
E          kwargs={'input': 'tf.Tensor(shape=(2, 3, 5, 5), dtype=float32)'}

../ivy/ivy/functional/backends/tensorflow/__init__.py:40: TypeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomTransplantation

Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling RandomTransplantation from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                                
Transpilation of RandomTransplantation complete.
_______________________________________________________________________________ test_CenterCrop3D[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_CenterCrop3D(target_framework, mode, backend_compile):
        print("kornia.augmentation.CenterCrop3D")
    
        init_args = (2,)
        init_kwargs = {"p": 1.}
        call_args = (torch.randn(1, 1, 2, 4, 6),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.CenterCrop3D,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._3d.geometric.center_crop.CenterCrop3D'>, target = 'tensorflow', init_args = (2,), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[[ 0.5986, -0.9749, -1.0636, -0.1300,  0.3749,  0.1670],
           [-0.4493, -0.1313, -1.3546, -0.6649, -0...  2.1233,  0.8436, -0.2902,  1.5495,  1.7433],
           [-0.1386, -1.0336, -1.1728, -0.3424, -0.5030, -2.3626]]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._3d.geometric.center_crop.CenterCrop3D'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.CenterCrop3D
______________________________________________________________________________ test_RandomAffine3D[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomAffine3D(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomAffine3D")
    
        init_args = ((15., 20., 20.),)
        init_kwargs = {"p": 1.}
        call_args = (torch.rand(1, 1, 3, 3, 3),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomAffine3D,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._3d.geometric.affine.RandomAffine3D'>, target = 'tensorflow', init_args = ((15.0, 20.0, 20.0),), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[[0.5633, 0.5458, 0.8512],
           [0.3457, 0.2530, 0.1577],
           [0.5331, 0.0626, 0.0687]],

    ...,

          [[0.2921, 0.4964, 0.9188],
           [0.6834, 0.0408, 0.9570],
           [0.2944, 0.1480, 0.9071]]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._3d.geometric.affine.RandomAffine3D'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomAffine3D
__________________________________________________________________________ test_RandomHorizontalFlip3D[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomHorizontalFlip3D(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomHorizontalFlip3D")
    
        init_args = ()
        init_kwargs = {"p": 1.}
        call_args = (torch.eye(3).repeat(3, 1, 1),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomHorizontalFlip3D,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._3d.geometric.horizontal_flip.RandomHorizontalFlip3D'>, target = 'tensorflow', init_args = (), init_kwargs = {'p': 1.0}
call_args = (tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._3d.geometric.horizontal_flip.RandomHorizontalFlip3D'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomHorizontalFlip3D
_____________________________________________________________________________ test_RandomRotation3D[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomRotation3D(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomRotation3D")
    
        init_args = ((15., 20., 20.),)
        init_kwargs = {"p": 1.}
        call_args = (torch.rand(1, 1, 3, 3, 3),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomRotation3D,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._3d.geometric.rotation.RandomRotation3D'>, target = 'tensorflow', init_args = ((15.0, 20.0, 20.0),), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[[0.5547, 0.5935, 0.3353],
           [0.4965, 0.2642, 0.7250],
           [0.7345, 0.3231, 0.5294]],

    ...,

          [[0.7042, 0.9522, 0.8437],
           [0.1302, 0.5587, 0.6507],
           [0.5847, 0.1653, 0.4814]]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._3d.geometric.rotation.RandomRotation3D'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomRotation3D
____________________________________________________________________________ test_RandomMotionBlur3D[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomMotionBlur3D(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomMotionBlur3D")
    
        init_args = (3, 35., 0.5)
        init_kwargs = {"p": 1.}
        call_args = (torch.rand(1, 1, 3, 5, 5),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomMotionBlur3D,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._3d.intensity.motion_blur.RandomMotionBlur3D'>, target = 'tensorflow', init_args = (3, 35.0, 0.5), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[[0.0116, 0.7208, 0.1569, 0.6370, 0.8845],
           [0.8458, 0.6219, 0.4179, 0.8310, 0.3295],
           ....5384],
           [0.0044, 0.1355, 0.7389, 0.7823, 0.5889],
           [0.5631, 0.6857, 0.5053, 0.4271, 0.2048]]]]]),)
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._3d.intensity.motion_blur.RandomMotionBlur3D'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomMotionBlur3D
__________________________________________________________________________ test_RandomTransplantation3D[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_RandomTransplantation3D(target_framework, mode, backend_compile):
        print("kornia.augmentation.RandomTransplantation3D")
    
        init_args = ()
        init_kwargs = {"p": 1.}
        call_args = (torch.randn(2, 3, 5, 5), torch.randint(0, 3, (2, 5, 5)))
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.RandomTransplantation3D,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=False,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._3d.mix.transplantation.RandomTransplantation3D'>, target = 'tensorflow', init_args = (), init_kwargs = {'p': 1.0}
call_args = (tensor([[[[ 0.6188,  0.0560,  0.9559, -1.2402,  0.8815],
          [ 2.2189, -0.6999, -2.1176, -1.2190,  0.8449],
   ...0, 1, 0, 1],
         [2, 0, 2, 0, 1],
         [0, 2, 0, 0, 0],
         [2, 0, 1, 0, 1],
         [0, 2, 2, 0, 2]]]))
call_kwargs = {}, deterministic_output = False, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._3d.mix.transplantation.RandomTransplantation3D'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.RandomTransplantation3D
______________________________________________________________________________ test_LongestMaxSize[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LongestMaxSize(target_framework, mode, backend_compile):
        print("kornia.augmentation.LongestMaxSize")
    
        init_args = (100,)
        init_kwargs = {}
        call_args = (torch.rand(10, 3, 200, 200),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.LongestMaxSize,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=True,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.resize.LongestMaxSize'>, target = 'tensorflow', init_args = (100,), init_kwargs = {}
call_args = (tensor([[[[0.4805, 0.4838, 0.7227,  ..., 0.8512, 0.5288, 0.1007],
          [0.7613, 0.4001, 0.2467,  ..., 0.9204, 0...., 0.5079, 0.2555,  ..., 0.6802, 0.8898, 0.7373],
          [0.2392, 0.3332, 0.6048,  ..., 0.4488, 0.0765, 0.1072]]]]),)
call_kwargs = {}, deterministic_output = True, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.resize.LongestMaxSize'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.LongestMaxSize
__________________________________________________________________________________ test_Resize[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_Resize(target_framework, mode, backend_compile):
        print("kornia.augmentation.Resize")
    
        init_args = ((100, 100),)
        init_kwargs = {}
        call_args = (torch.rand(10, 3, 50, 50),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.Resize,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=True,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.resize.Resize'>, target = 'tensorflow', init_args = ((100, 100),), init_kwargs = {}
call_args = (tensor([[[[2.1310e-01, 7.9679e-01, 2.9795e-01,  ..., 6.9953e-01,
           9.2940e-01, 6.9720e-02],
          [3.463... 1.9423e-02],
          [2.5908e-02, 1.3740e-01, 2.8241e-01,  ..., 4.4623e-01,
           4.1475e-01, 3.7526e-01]]]]),)
call_kwargs = {}, deterministic_output = True, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
>       transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)

kornia/augmentation/test_augmentation.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.augmentation._2d.geometric.resize.Resize'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.Resize
______________________________________________________________________________ test_SmallestMaxSize[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SmallestMaxSize(target_framework, mode, backend_compile):
        print("kornia.augmentation.SmallestMaxSize")
    
        init_args = (100,)
        init_kwargs = {}
        call_args = (torch.rand(10, 3, 50, 50),)
        call_kwargs = {}
    
>       _test_augmentation_class(
            kornia.augmentation.SmallestMaxSize,
            target_framework,
            init_args,
            init_kwargs,
            call_args,
            call_kwargs,
            deterministic_output=True,
            backend_compile=backend_compile,
        )

kornia/augmentation/test_augmentation.py:1444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

augmentation_cls = <class 'kornia.augmentation._2d.geometric.resize.SmallestMaxSize'>, target = 'tensorflow', init_args = (100,), init_kwargs = {}
call_args = (tensor([[[[0.9902, 0.2222, 0.8614,  ..., 0.5403, 0.0617, 0.0790],
          [0.4232, 0.2381, 0.1536,  ..., 0.5752, 0...., 0.4475, 0.6323,  ..., 0.6094, 0.1257, 0.6482],
          [0.8924, 0.7004, 0.2497,  ..., 0.4752, 0.4105, 0.4735]]]]),)
call_kwargs = {}, deterministic_output = True, backend_compile = False, tolerance = 0.001

    def _test_augmentation_class(
        augmentation_cls,
        target,
        init_args=(),
        init_kwargs={},
        call_args=(),
        call_kwargs={},
        deterministic_output=True,
        backend_compile=False,
        tolerance=1e-3,
    ):
        if backend_compile:
            pytest.skip()
    
        transpiled_cls = ivy.transpile(augmentation_cls, source="torch", target=target)
    
        torch_aug = augmentation_cls(*init_args, **init_kwargs)
        transpiled_init_args = _nest_torch_tensor_to_new_framework(init_args, target)
        transpiled_init_kwargs = _nest_torch_tensor_to_new_framework(init_kwargs, target)
        transpiled_aug = transpiled_cls(*transpiled_init_args, **transpiled_init_kwargs)
    
        # assert dir(torch_aug) == dir(transpiled_aug), f"attributes/methods of transpiled object do not align with the original - orig: {dir(torch_aug)} != transpiled: {dir(transpiled_aug)}"
    
        torch_out = torch_aug(*call_args, **call_kwargs)
        transpiled_call_args = _nest_torch_tensor_to_new_framework(call_args, target)
        transpiled_call_kwargs = _nest_torch_tensor_to_new_framework(call_kwargs, target)
>       transpiled_out = transpiled_aug(*transpiled_call_args, **transpiled_call_kwargs)

kornia/augmentation/test_augmentation.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bilinear, align_corners=True, antialias=False)
args = (<tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855...
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>,)
kwargs = {}
stack = [FrameInfo(frame=<frame at 0x7f9977b56c40, file '/ivy/ivy-integration-tests/Translated_Outputs/tensorflow_outputs/tens...kexec', code_context=['        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n'], index=0), ...]

    @functools.wraps(fn)
    def frame_info_wrapper(self, *args, **kwargs):
        if self._previous_frame_info is None:
            # store the info about the calling frame.
            stack = inspect.stack()
            self._previous_frame_info = stack[1]
>       res = fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bi...,
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>)
kwargs = {}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bilinear, align_corners=True, antialias=False), v = None, buffers = None
args = (<tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855...
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>,)
kwargs = {}

    @store_frame_info
    @tf.autograph.experimental.do_not_convert
    def __call__(
        self,
        *args,
        v=None,
        buffers=None,
        **kwargs,
    ):
        # TODO: Temp workaround to avoid `call`` from being transformed by AutoGraph
        if not hasattr(self.__class__.call, "autograph_info__"):
            setattr(self.__class__.call, "autograph_info__", True)
>       ret = self._call(*args, v=v, buffers=buffers, **kwargs)

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:978: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bi...,
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>)
kwargs = {'buffers': None, 'v': None}

    def wrapper(*args, **kwargs):
      with ag_ctx.ControlStatusCtx(status=ag_ctx.Status.DISABLED):
>       return func(*args, **kwargs)

/opt/fw/tensorflow/tensorflow/python/autograph/impl/api.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bilinear, align_corners=True, antialias=False), v = None, buffers = None
args = (<tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855...
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>,)
kwargs = {}
first_arr = <tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855 ...],
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>
replace_v = False, replace_buffers = False, call_signature = <Signature (input, params=None, **kwargs)>

    @tf.autograph.experimental.do_not_convert
    def _call(self, *args, v=None, buffers=None, **kwargs):
        if not self._built or not self.built:
            if not self._built:
                first_arr = self._get_first_array(*args, **kwargs)
                self.build(
                    *args,
                    **kwargs,
                    from_call=True,
                    dtype=first_arr.dtype if first_arr is not None else tf.float32,
                )
    
            if not self.built:
                # Don't use `keras` build method
                if os.environ.get("USE_KERAS_BUILD", "False").lower() == "false":
                    self.inputs = tf.nest.flatten(args)
                else:
                    input_shapes = self._get_input_shapes(*args)
                    if len(input_shapes) == 0:
                        input_shapes = tf.TensorShape(None)
                    elif len(input_shapes) == 1:
                        input_shapes = input_shapes[0]
    
                super(Layer, self).build(tf.TensorShape(None))  # noqa: UP008
    
        # If `v` was provided, replace with the module's v
        replace_v = False
        if v is not None:
            v_orig = self.v
            self._v = v
            replace_v = True
    
        # If `buffers` were provided, replace with the module's buffers
        replace_buffers = False
        if buffers is not None:
            buffers_orig = self.buffers
            self._buffers = buffers
            replace_buffers = True
    
        if replace_v or replace_buffers:
            # Call the forward pass
            ret = super(Layer, self).__call__(*args, **kwargs)  # noqa: UP008
            # Replace v, buffers if needed
            self._v = v_orig if replace_v else self._v
            self._buffers = buffers_orig if replace_buffers else self._buffers
            return ret
        elif hasattr(self.__call__, "wrapped"):
            return self.__call__(*args, **kwargs)
    
        # Get the signature of the call method
        call_signature = inspect.signature(self.call)
    
        # Convert all positional arguments to keyword arguments based on the signature
        new_kwargs = {}
        for idx, (param_name, param) in enumerate(call_signature.parameters.items()):
            if idx < len(args):
                new_kwargs[param_name] = args[idx]
    
        # Merge the existing kwargs
        new_kwargs.update(kwargs)
>       return super(Layer, self).__call__(**new_kwargs)  # noqa: UP008

Translated_Outputs/tensorflow_outputs/tensorflow__stateful.py:746: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bilinear, align_corners=True, antialias=False),)
kwargs = {'input': <tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., ...,
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>}

    @wraps(fn)
    def error_handler(*args, **kwargs):
        if not is_traceback_filtering_enabled():
            return fn(*args, **kwargs)
    
        filtered_tb = None
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            filtered_tb = _process_traceback_frames(e.__traceback__)
            # To get the full stack trace, call:
            # `keras.config.disable_traceback_filtering()`
>           raise e.with_traceback(filtered_tb) from None

/opt/fw/tensorflow/keras/src/utils/traceback_utils.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bilinear, align_corners=True, antialias=False)
input = <tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855 ...],
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>
params = {'batch_prob': <tf.Tensor: shape=(10,), dtype=float32, numpy=array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], dtype=flo...[50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50]])>, ...}
kwargs = {}, tensorflow_shape_frnt_ = <function tensorflow_shape_frnt_ at 0x7f9977b9b130>, tensorflow_set_item_bknd = <function tensorflow_set_item_bknd at 0x7f996d1cdbd0>
tensor = <function tensorflow_tensor_frnt at 0x7f9977d467a0>
in_tensor = <tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855 ...],
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>
input_shape = ivy.frontends.torch.Size([10, 3, 50, 50]), batch_shape = ivy.frontends.torch.Size([10, 3, 50, 50])
flags = {'align_corners': True, 'antialias': False, 'resample': <tensorflow_Resample.BILINEAR: 1>, 'side': 'short', ...}

    def call(self, input, params=None, **kwargs):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ...ivy.functional.ivy.general import tensorflow_set_item_bknd
        from ..core._backend import tensor
    
        in_tensor = self.__unpack_input__(input)
        input_shape = tensorflow_shape_frnt_(in_tensor)
        in_tensor = self.transform_tensor(in_tensor)
        batch_shape = tensorflow_shape_frnt_(in_tensor)
        if params is None:
            params = self.forward_parameters(batch_shape)
        if "batch_prob" not in params:
            params = tensorflow_set_item_bknd(
                params, "batch_prob", tensor([True] * batch_shape[0])
            )
        params, flags = self._process_kwargs_to_params_and_flags(
            params, self.flags, **kwargs
        )
>       output = self.apply_func(in_tensor, params, flags)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/base.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bilinear, align_corners=True, antialias=False)
in_tensor = <tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855 ...],
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>
params = {'batch_prob': <tf.Tensor: shape=(10,), dtype=float32, numpy=array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], dtype=flo...[50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50]])>, ...}
flags = {'align_corners': True, 'antialias': False, 'resample': <tensorflow_Resample.BILINEAR: 1>, 'side': 'short', ...}

    def apply_func(self, in_tensor, params, flags=None):
        if flags is None:
            flags = self.flags
>       trans_matrix = self.generate_transformation_matrix(in_tensor, params, flags)

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/base.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bilinear, align_corners=True, antialias=False)
input = <tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855 ...],
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>
params = {'batch_prob': <tf.Tensor: shape=(10,), dtype=float32, numpy=array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], dtype=flo...[50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50]])>, ...}
flags = {'align_corners': True, 'antialias': False, 'resample': <tensorflow_Resample.BILINEAR: 1>, 'side': 'short', ...}

    def generate_transformation_matrix(self, input, params, flags):
        from ....ivy.functional.frontends.torch.tensor import tensorflow_any_frnt_
        from ....ivy.functional.frontends.torch.tensor import tensorflow_all_frnt_
        from ....ivy.functional.backends.tensorflow.general import tensorflow_get_item
        from ...utils.helpers import tensorflow_is_autocast_enabled
        from ....ivy.functional.frontends.torch.tensor import tensorflow_type_frnt_
        from ....ivy.functional.frontends.torch.tensor import tensorflow_index_put_frnt_
    
        batch_prob = params["batch_prob"]
        to_apply = batch_prob > 0.5
        in_tensor = self.transform_tensor(input)
        if not tensorflow_any_frnt_(to_apply):
            trans_matrix = self.identity_matrix(in_tensor)
        elif tensorflow_all_frnt_(to_apply):
>           trans_matrix = self.compute_transformation(
                in_tensor, params=params, flags=flags
            )

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/base.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SmallestMaxSize(output_size=100, p=1.0, p_batch=1.0, same_on_batch=True, size=100, side=short, resample=bilinear, align_corners=True, antialias=False)
input = <tf.Tensor: shape=(10, 3, 50, 50), dtype=float32, numpy=
array([[[[0.99023354, 0.2222277 , 0.8614152 , ..., 0.5402855 ...],
         [0.8924377 , 0.7004009 , 0.24971884, ..., 0.47516578,
          0.41045773, 0.47348744]]]], dtype=float32)>
params = {'batch_prob': <tf.Tensor: shape=(10,), dtype=float32, numpy=array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], dtype=flo...[50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50],
       [50, 50]])>, ...}
flags = {'align_corners': True, 'antialias': False, 'resample': <tensorflow_Resample.BILINEAR: 1>, 'side': 'short', ...}

    def compute_transformation(self, input, params, flags):
        from .....ivy.functional.frontends.torch.tensor import tensorflow_shape_frnt_
        from ....utils.misc import tensorflow_eye_like
        from .....ivy.functional.frontends.torch.creation_ops import (
            tensorflow_as_tensor_frnt,
        )
        from ....geometry.transform.imgwarp import tensorflow_get_perspective_transform
        from .....ivy.functional.frontends.torch.tensor import tensorflow_expand_frnt_
    
>       if params["output_size"] == tensorflow_shape_frnt_(input)[-2:]:
E       ValueError: Exception encountered when calling tensorflow_SmallestMaxSize.call().
E       
E       [1mThe truth value of an array with more than one element is ambiguous. Use a.any() or a.all()[0m
E       
E       Arguments received by tensorflow_SmallestMaxSize.call():
E          input=tf.Tensor(shape=(10, 3, 50, 50), dtype=float32)
E          params=None
E          kwargs=<class 'inspect._empty'>

Translated_Outputs/tensorflow_outputs/kornia/augmentation/_2d/geometric/resize.py:67: ValueError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.augmentation.SmallestMaxSize

Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling SmallestMaxSize from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
                                                                                                                                          
Transpilation of SmallestMaxSize complete.
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/augmentation/test_augmentation.py::test_RandomBrightness[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/augmentation/test_augmentation.py::test_RandomChannelDropout[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api k...
FAILED kornia/augmentation/test_augmentation.py::test_RandomClahe[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensur...
FAILED kornia/augmentation/test_augmentation.py::test_RandomContrast[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, en...
FAILED kornia/augmentation/test_augmentation.py::test_RandomGaussianBlur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key...
FAILED kornia/augmentation/test_augmentation.py::test_RandomGaussianIllumination[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an...
FAILED kornia/augmentation/test_augmentation.py::test_RandomHue[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/augmentation/test_augmentation.py::test_RandomJPEG[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/augmentation/test_augmentation.py::test_RandomLinearCornerIllumination[tensorflow-s2s-False] - AttributeError: Exception encountered when calling tensorflow_LinearCornerIlluminationGe...
FAILED kornia/augmentation/test_augmentation.py::test_RandomLinearIllumination[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an a...
FAILED kornia/augmentation/test_augmentation.py::test_RandomMedianBlur[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/augmentation/test_augmentation.py::test_RandomMotionBlur[tensorflow-s2s-False] - TypeError: Exception encountered when calling tensorflow_RandomMotionBlur.call().
FAILED kornia/augmentation/test_augmentation.py::test_RandomPlanckianJitter[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ...
FAILED kornia/augmentation/test_augmentation.py::test_RandomPlasmaContrast[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api k...
FAILED kornia/augmentation/test_augmentation.py::test_RandomPlasmaShadow[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key...
FAILED kornia/augmentation/test_augmentation.py::test_RandomRain[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/augmentation/test_augmentation.py::test_RandomSaltAndPepperNoise[tensorflow-s2s-False] - AttributeError: Exception encountered when calling tensorflow_RandomSaltAndPepperNoise.call().
FAILED kornia/augmentation/test_augmentation.py::test_RandomSharpness[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, e...
FAILED kornia/augmentation/test_augmentation.py::test_RandomSnow[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/augmentation/test_augmentation.py::test_RandomSolarize[tensorflow-s2s-False] - tensorflow.python.framework.errors_impl.InvalidArgumentError: Exception encountered when calling tensorf...
FAILED kornia/augmentation/test_augmentation.py::test_CenterCrop[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/augmentation/test_augmentation.py::test_PadTo[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you ...
FAILED kornia/augmentation/test_augmentation.py::test_RandomCrop[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/augmentation/test_augmentation.py::test_RandomElasticTransform[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api...
FAILED kornia/augmentation/test_augmentation.py::test_RandomPerspective[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key,...
FAILED kornia/augmentation/test_augmentation.py::test_RandomResizedCrop[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key,...
FAILED kornia/augmentation/test_augmentation.py::test_RandomRotation[tensorflow-s2s-False] - AttributeError: Exception encountered when calling tensorflow_RandomRotation.call().
FAILED kornia/augmentation/test_augmentation.py::test_RandomThinPlateSpline[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ...
FAILED kornia/augmentation/test_augmentation.py::test_RandomVerticalFlip[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key...
FAILED kornia/augmentation/test_augmentation.py::test_RandomCutMixV2[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: source code not available
FAILED kornia/augmentation/test_augmentation.py::test_RandomJigsaw[tensorflow-s2s-False] - TypeError: got an unexpected keyword argument 'input'
FAILED kornia/augmentation/test_augmentation.py::test_RandomMixUpV2[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ens...
FAILED kornia/augmentation/test_augmentation.py::test_RandomMosaic[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/augmentation/test_augmentation.py::test_RandomTransplantation[tensorflow-s2s-False] - TypeError: Exception encountered when calling tensorflow_RandomTransplantation.call().
FAILED kornia/augmentation/test_augmentation.py::test_CenterCrop3D[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensu...
FAILED kornia/augmentation/test_augmentation.py::test_RandomAffine3D[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, en...
FAILED kornia/augmentation/test_augmentation.py::test_RandomHorizontalFlip3D[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api...
FAILED kornia/augmentation/test_augmentation.py::test_RandomRotation3D[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ...
FAILED kornia/augmentation/test_augmentation.py::test_RandomMotionBlur3D[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key...
FAILED kornia/augmentation/test_augmentation.py::test_RandomTransplantation3D[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an ap...
FAILED kornia/augmentation/test_augmentation.py::test_LongestMaxSize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, en...
FAILED kornia/augmentation/test_augmentation.py::test_Resize[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/augmentation/test_augmentation.py::test_SmallestMaxSize[tensorflow-s2s-False] - ValueError: Exception encountered when calling tensorflow_SmallestMaxSize.call().
============================================================================== 43 failed, 25 passed in 938.03s (0:15:38) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 8 items

kornia/geometry/test_linalg.py FFF.F..F                                                                                                                                                          [100%]

=============================================================================================== FAILURES ===============================================================================================
__________________________________________________________________________ test_relative_transformation[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_relative_transformation(target_framework, mode, backend_compile):
        trace_args = (
            torch.eye(4),
            torch.eye(4),
        )
        trace_kwargs = {}
        test_args = (
            torch.eye(4).repeat(5, 1, 1),
            torch.eye(4).repeat(5, 1, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.linalg.relative_transformation,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_linalg.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function relative_transformation at 0x7f22df1ad990>
trace_args = (tensor([[1., 0., 0., 0.],
        [0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.]]), tensor([[1., 0., 0., 0.],
        [0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.]]))
trace_kwargs = {}
test_args = (tensor([[[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]],

       ..., 1.]],

        [[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function relative_transformation at 0x7f22df1ad990>
trace_args = (tensor([[1., 0., 0., 0.],
        [0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.]]), tensor([[1., 0., 0., 0.],
        [0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.]]))
trace_kwargs = {}
test_args = (tensor([[[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]],

       ..., 1.]],

        [[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function relative_transformation at 0x7f22df1ad990>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.linalg.relative_transformation
__________________________________________________________________________ test_compose_transformations[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_compose_transformations(target_framework, mode, backend_compile):
        trace_args = (
            torch.eye(4),
            torch.eye(4),
        )
        trace_kwargs = {}
        test_args = (
            torch.eye(4).repeat(5, 1, 1),
            torch.eye(4).repeat(5, 1, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.linalg.compose_transformations,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_linalg.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function compose_transformations at 0x7f22df7c2950>
trace_args = (tensor([[1., 0., 0., 0.],
        [0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.]]), tensor([[1., 0., 0., 0.],
        [0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.]]))
trace_kwargs = {}
test_args = (tensor([[[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]],

       ..., 1.]],

        [[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function compose_transformations at 0x7f22df7c2950>
trace_args = (tensor([[1., 0., 0., 0.],
        [0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.]]), tensor([[1., 0., 0., 0.],
        [0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.]]))
trace_kwargs = {}
test_args = (tensor([[[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]],

       ..., 1.]],

        [[1., 0., 0., 0.],
         [0., 1., 0., 0.],
         [0., 0., 1., 0.],
         [0., 0., 0., 1.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function compose_transformations at 0x7f22df7c2950>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.linalg.compose_transformations
__________________________________________________________________________ test_inverse_transformation[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_inverse_transformation(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 4, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 4, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.linalg.inverse_transformation,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_linalg.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function inverse_transformation at 0x7f22df1ad900>
trace_args = (tensor([[[0.1098, 0.2211, 0.9214, 0.5033],
         [0.2059, 0.2294, 0.5278, 0.6966],
         [0.3821, 0.1586, 0.6041, 0.8090],
         [0.9535, 0.5518, 0.7005, 0.0570]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.9288, 0.5091, 0.3208, 0.1210],
         [0.6273, 0.5378, 0.4944, 0.7936],
         [0.7850, 0.8367, 0.602...456, 0.2693, 0.2560, 0.6140],
         [0.1540, 0.4366, 0.3768, 0.1483],
         [0.7342, 0.8025, 0.4256, 0.2267]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function inverse_transformation at 0x7f22df1ad900>
trace_args = (tensor([[[0.1098, 0.2211, 0.9214, 0.5033],
         [0.2059, 0.2294, 0.5278, 0.6966],
         [0.3821, 0.1586, 0.6041, 0.8090],
         [0.9535, 0.5518, 0.7005, 0.0570]]]),)
trace_kwargs = {}
test_args = (tensor([[[0.9288, 0.5091, 0.3208, 0.1210],
         [0.6273, 0.5378, 0.4944, 0.7936],
         [0.7850, 0.8367, 0.602...456, 0.2693, 0.2560, 0.6140],
         [0.1540, 0.4366, 0.3768, 0.1483],
         [0.7342, 0.8025, 0.4256, 0.2267]]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function inverse_transformation at 0x7f22df1ad900>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.linalg.inverse_transformation
____________________________________________________________________________ test_point_line_distance[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_point_line_distance(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(3),
            torch.rand(3),
        )
        trace_kwargs = {'eps': 1e-9}
        test_args = (
            torch.rand(5, 3),
            torch.rand(5, 3),
        )
        test_kwargs = {'eps': 1e-9}
>       _test_function(
            kornia.geometry.linalg.point_line_distance,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_linalg.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function point_line_distance at 0x7f22df1adab0>, trace_args = (tensor([0.7094, 0.4674, 0.2391]), tensor([0.5297, 0.0739, 0.2755])), trace_kwargs = {'eps': 1e-09}
test_args = (tensor([[0.0733, 0.6424, 0.5118],
        [0.2650, 0.4040, 0.5908],
        [0.8086, 0.1136, 0.4266],
        [0.6689....9065, 0.4829],
        [0.9088, 0.2834, 0.5260],
        [0.7677, 0.1967, 0.5656],
        [0.4966, 0.2352, 0.8837]]))
test_kwargs = {'eps': 1e-09}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function point_line_distance at 0x7f22df1adab0>, trace_args = (tensor([0.7094, 0.4674, 0.2391]), tensor([0.5297, 0.0739, 0.2755])), trace_kwargs = {'eps': 1e-09}
test_args = (tensor([[0.0733, 0.6424, 0.5118],
        [0.2650, 0.4040, 0.5908],
        [0.8086, 0.1136, 0.4266],
        [0.6689....9065, 0.4829],
        [0.9088, 0.2834, 0.5260],
        [0.7677, 0.1967, 0.5656],
        [0.4966, 0.2352, 0.8837]]))
test_kwargs = {'eps': 1e-09}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function point_line_distance at 0x7f22df1adab0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.linalg.point_line_distance
____________________________________________________________________________ test_euclidean_distance[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_euclidean_distance(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(3, 5),
            torch.rand(3, 5),
        )
        trace_kwargs = {'keepdim': False, 'eps': 1e-6}
        test_args = (
            torch.rand(5, 3, 5),
            torch.rand(5, 3, 5),
        )
        test_kwargs = {'keepdim': False, 'eps': 1e-6}
>       _test_function(
            kornia.geometry.linalg.euclidean_distance,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_linalg.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function euclidean_distance at 0x7f22df1adc60>
trace_args = (tensor([[0.1890, 0.2884, 0.3203, 0.5306, 0.0291],
        [0.9035, 0.6307, 0.3490, 0.1819, 0.7524],
        [0.2191, ... 0.2676, 0.9382],
        [0.2320, 0.6199, 0.9049, 0.3782, 0.5099],
        [0.0786, 0.9451, 0.1015, 0.1062, 0.6865]]))
trace_kwargs = {'eps': 1e-06, 'keepdim': False}
test_args = (tensor([[[0.6256, 0.3135, 0.2180, 0.7187, 0.6628],
         [0.4547, 0.3369, 0.3920, 0.0905, 0.3641],
         [0.290...9884, 0.6957],
         [0.4038, 0.3009, 0.8406, 0.8737, 0.1727],
         [0.7633, 0.0174, 0.6142, 0.1640, 0.5612]]]))
test_kwargs = {'eps': 1e-06, 'keepdim': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function euclidean_distance at 0x7f22df1adc60>
trace_args = (tensor([[0.1890, 0.2884, 0.3203, 0.5306, 0.0291],
        [0.9035, 0.6307, 0.3490, 0.1819, 0.7524],
        [0.2191, ... 0.2676, 0.9382],
        [0.2320, 0.6199, 0.9049, 0.3782, 0.5099],
        [0.0786, 0.9451, 0.1015, 0.1062, 0.6865]]))
trace_kwargs = {'eps': 1e-06, 'keepdim': False}
test_args = (tensor([[[0.6256, 0.3135, 0.2180, 0.7187, 0.6628],
         [0.4547, 0.3369, 0.3920, 0.0905, 0.3641],
         [0.290...9884, 0.6957],
         [0.4038, 0.3009, 0.8406, 0.8737, 0.1727],
         [0.7633, 0.0174, 0.6142, 0.1640, 0.5612]]]))
test_kwargs = {'eps': 1e-06, 'keepdim': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function euclidean_distance at 0x7f22df1adc60>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.linalg.euclidean_distance
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_linalg.py::test_relative_transformation[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ens...
FAILED kornia/geometry/test_linalg.py::test_compose_transformations[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ens...
FAILED kornia/geometry/test_linalg.py::test_inverse_transformation[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable intern...
FAILED kornia/geometry/test_linalg.py::test_point_line_distance[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/geometry/test_linalg.py::test_euclidean_distance[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure y...
=============================================================================== 5 failed, 3 passed in 102.41s (0:01:42) ================================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 35 items

kornia/test_losses.py .........FFFFFFFFFFFFFFFFFFFFFFFFFF                                                                                                                                        [100%]

=============================================================================================== FAILURES ===============================================================================================
_______________________________________________________________________ test_binary_focal_loss_with_logits[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_binary_focal_loss_with_logits(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 3, 5)),
            torch.randint(2, (1, 3, 5)),
        )
        trace_kwargs = {"alpha": 0.25, "gamma": 2.0, "reduction": 'mean'}
        test_args = (
            torch.randn((5, 3, 5)),
            torch.randint(2, (5, 3, 5)),
        )
        test_kwargs = {"alpha": 0.5, "gamma": 3.1, "reduction": 'mean'}
>       _test_function(
            kornia.losses.binary_focal_loss_with_logits,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_losses.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function binary_focal_loss_with_logits at 0x7f83e00244c0>
trace_args = (tensor([[[-2.0256, -0.3287,  1.7661,  0.1349, -1.3457],
         [ 0.7119,  0.6652, -1.0217,  0.8505,  0.4600],
     ...1.0839, -0.3203, -0.0724, -1.2765]]]), tensor([[[1, 0, 1, 1, 1],
         [0, 1, 0, 1, 1],
         [1, 0, 0, 1, 0]]]))
trace_kwargs = {'alpha': 0.25, 'gamma': 2.0, 'reduction': 'mean'}
test_args = (tensor([[[-4.7706e-01, -4.9624e-02,  1.6345e+00, -1.4367e+00, -4.8572e-01],
         [-8.9416e-01, -6.0774e-01, -7.02... 1, 1, 0],
         [0, 1, 0, 0, 1]],

        [[1, 1, 1, 0, 1],
         [0, 1, 0, 1, 1],
         [0, 0, 1, 1, 1]]]))
test_kwargs = {'alpha': 0.5, 'gamma': 3.1, 'reduction': 'mean'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function binary_focal_loss_with_logits at 0x7f83e00244c0>
trace_args = (tensor([[[-2.0256, -0.3287,  1.7661,  0.1349, -1.3457],
         [ 0.7119,  0.6652, -1.0217,  0.8505,  0.4600],
     ...1.0839, -0.3203, -0.0724, -1.2765]]]), tensor([[[1, 0, 1, 1, 1],
         [0, 1, 0, 1, 1],
         [1, 0, 0, 1, 0]]]))
trace_kwargs = {'alpha': 0.25, 'gamma': 2.0, 'reduction': 'mean'}
test_args = (tensor([[[-4.7706e-01, -4.9624e-02,  1.6345e+00, -1.4367e+00, -4.8572e-01],
         [-8.9416e-01, -6.0774e-01, -7.02... 1, 1, 0],
         [0, 1, 0, 0, 1]],

        [[1, 1, 1, 0, 1],
         [0, 1, 0, 1, 1],
         [0, 0, 1, 1, 1]]]))
test_kwargs = {'alpha': 0.5, 'gamma': 3.1, 'reduction': 'mean'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function binary_focal_loss_with_logits at 0x7f83e00244c0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.focal.binary_focal_loss_with_logits
________________________________________________________________________________ test_focal_loss[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_focal_loss(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 5, 3, 5)),
            torch.randint(5, (1, 3, 5)),
        )
        trace_kwargs = {"alpha": 0.5, "gamma": 2.0, "reduction": 'mean'}
        test_args = (
            torch.randn((5, 5, 3, 5)),
            torch.randint(5, (5, 3, 5)),
        )
        test_kwargs = {"alpha": 0.7, "gamma": 2.5, "reduction": 'mean'}
>       _test_function(
            kornia.losses.focal_loss,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_losses.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function focal_loss at 0x7f83e0024430>
trace_args = (tensor([[[[ 1.0107,  0.4238,  1.7043, -0.2313, -0.8045],
          [-2.4151,  0.3957,  0.7373,  1.7753,  0.3857],
   ....1391,  1.4708,  0.4073, -0.0312]]]]), tensor([[[3, 2, 0, 4, 1],
         [1, 0, 1, 4, 1],
         [4, 4, 2, 1, 3]]]))
trace_kwargs = {'alpha': 0.5, 'gamma': 2.0, 'reduction': 'mean'}
test_args = (tensor([[[[-1.1632e-01,  1.4712e+00,  1.0142e+00, -5.0216e-01, -9.5293e-01],
          [ 3.5609e-01, -1.7493e+00,  1.... 4, 0, 1],
         [2, 2, 1, 0, 0]],

        [[2, 0, 1, 4, 2],
         [2, 3, 3, 3, 2],
         [0, 2, 1, 0, 4]]]))
test_kwargs = {'alpha': 0.7, 'gamma': 2.5, 'reduction': 'mean'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function focal_loss at 0x7f83e0024430>
trace_args = (tensor([[[[ 1.0107,  0.4238,  1.7043, -0.2313, -0.8045],
          [-2.4151,  0.3957,  0.7373,  1.7753,  0.3857],
   ....1391,  1.4708,  0.4073, -0.0312]]]]), tensor([[[3, 2, 0, 4, 1],
         [1, 0, 1, 4, 1],
         [4, 4, 2, 1, 3]]]))
trace_kwargs = {'alpha': 0.5, 'gamma': 2.0, 'reduction': 'mean'}
test_args = (tensor([[[[-1.1632e-01,  1.4712e+00,  1.0142e+00, -5.0216e-01, -9.5293e-01],
          [ 3.5609e-01, -1.7493e+00,  1.... 4, 0, 1],
         [2, 2, 1, 0, 0]],

        [[2, 0, 1, 4, 2],
         [2, 3, 3, 3, 2],
         [0, 2, 1, 0, 4]]]))
test_kwargs = {'alpha': 0.7, 'gamma': 2.5, 'reduction': 'mean'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function focal_loss at 0x7f83e0024430>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.focal.focal_loss
_________________________________________________________________________________ test_dice_loss[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_dice_loss(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 5, 3, 5)),
            torch.empty(1, 3, 5, dtype=torch.long).random_(5),
        )
        trace_kwargs = {"average": "micro", "eps": 1e-8}
        test_args = (
            torch.randn((5, 5, 3, 5)),
            torch.empty(5, 3, 5, dtype=torch.long).random_(5),
        )
        test_kwargs = {"average": "micro", "eps": 1e-8}
>       _test_function(
            kornia.losses.dice_loss,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_losses.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dice_loss at 0x7f83e000bbe0>
trace_args = (tensor([[[[-1.2731,  1.3338,  0.2835,  1.2285,  0.4438],
          [-1.1638, -0.6963, -0.3877,  0.1431, -1.7019],
   ....8731,  0.3982,  1.9017, -0.0713]]]]), tensor([[[4, 1, 2, 0, 0],
         [2, 0, 3, 2, 1],
         [0, 4, 2, 3, 4]]]))
trace_kwargs = {'average': 'micro', 'eps': 1e-08}
test_args = (tensor([[[[-5.0091e-02, -2.9173e+00, -1.9800e-01,  1.1719e+00,  1.0861e+00],
          [-3.1411e-01,  1.4072e+00,  2.... 1, 3, 3],
         [3, 3, 2, 4, 4]],

        [[1, 4, 2, 3, 0],
         [1, 0, 3, 1, 4],
         [2, 1, 0, 1, 1]]]))
test_kwargs = {'average': 'micro', 'eps': 1e-08}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dice_loss at 0x7f83e000bbe0>
trace_args = (tensor([[[[-1.2731,  1.3338,  0.2835,  1.2285,  0.4438],
          [-1.1638, -0.6963, -0.3877,  0.1431, -1.7019],
   ....8731,  0.3982,  1.9017, -0.0713]]]]), tensor([[[4, 1, 2, 0, 0],
         [2, 0, 3, 2, 1],
         [0, 4, 2, 3, 4]]]))
trace_kwargs = {'average': 'micro', 'eps': 1e-08}
test_args = (tensor([[[[-5.0091e-02, -2.9173e+00, -1.9800e-01,  1.1719e+00,  1.0861e+00],
          [-3.1411e-01,  1.4072e+00,  2.... 1, 3, 3],
         [3, 3, 2, 4, 4]],

        [[1, 4, 2, 3, 0],
         [1, 0, 3, 1, 4],
         [2, 1, 0, 1, 1]]]))
test_kwargs = {'average': 'micro', 'eps': 1e-08}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function dice_loss at 0x7f83e000bbe0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.dice.dice_loss
_______________________________________________________________________________ test_tversky_loss[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_tversky_loss(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 5, 3, 5)),
            torch.empty(1, 3, 5, dtype=torch.long).random_(5),
        )
        trace_kwargs = {"alpha": 0.5, "beta": 0.5, "eps": 1e-8}
        test_args = (
            torch.randn(5, 5, 3, 5),
            torch.empty(5, 3, 5, dtype=torch.long).random_(5),
        )
        test_kwargs = {"alpha": 0.5, "beta": 0.5, "eps": 1e-8}
>       _test_function(
            kornia.losses.tversky_loss,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_losses.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function tversky_loss at 0x7f83e0027d00>
trace_args = (tensor([[[[-0.4268, -0.8848,  0.6461, -1.5086,  0.5915],
          [-0.3749,  0.8548,  0.3884, -1.7621,  2.1076],
   ....2764,  0.0225,  0.2489,  0.1091]]]]), tensor([[[0, 2, 0, 1, 4],
         [1, 4, 2, 1, 2],
         [4, 4, 2, 4, 4]]]))
trace_kwargs = {'alpha': 0.5, 'beta': 0.5, 'eps': 1e-08}
test_args = (tensor([[[[ 2.5419e-01,  4.3830e-01,  5.1756e-01,  9.5004e-01, -7.2953e-01],
          [-1.7937e+00, -4.9801e-01, -3.... 4, 3, 1],
         [4, 2, 1, 4, 2]],

        [[1, 3, 0, 1, 1],
         [2, 0, 4, 4, 3],
         [3, 4, 3, 4, 4]]]))
test_kwargs = {'alpha': 0.5, 'beta': 0.5, 'eps': 1e-08}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function tversky_loss at 0x7f83e0027d00>
trace_args = (tensor([[[[-0.4268, -0.8848,  0.6461, -1.5086,  0.5915],
          [-0.3749,  0.8548,  0.3884, -1.7621,  2.1076],
   ....2764,  0.0225,  0.2489,  0.1091]]]]), tensor([[[0, 2, 0, 1, 4],
         [1, 4, 2, 1, 2],
         [4, 4, 2, 4, 4]]]))
trace_kwargs = {'alpha': 0.5, 'beta': 0.5, 'eps': 1e-08}
test_args = (tensor([[[[ 2.5419e-01,  4.3830e-01,  5.1756e-01,  9.5004e-01, -7.2953e-01],
          [-1.7937e+00, -4.9801e-01, -3.... 4, 3, 1],
         [4, 2, 1, 4, 2]],

        [[1, 3, 0, 1, 1],
         [2, 0, 4, 4, 3],
         [3, 4, 3, 4, 4]]]))
test_kwargs = {'alpha': 0.5, 'beta': 0.5, 'eps': 1e-08}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function tversky_loss at 0x7f83e0027d00>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.tversky.tversky_loss
_____________________________________________________________________________ test_lovasz_hinge_loss[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_lovasz_hinge_loss(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 1, 3, 5)),
            torch.empty(1, 3, 5, dtype=torch.long).random_(1),
        )
        trace_kwargs = {}
        test_args = (
            torch.randn((5, 1, 3, 5)),
            torch.empty(5, 3, 5, dtype=torch.long).random_(1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.losses.lovasz_hinge_loss,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_losses.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function lovasz_hinge_loss at 0x7f83e0025240>
trace_args = (tensor([[[[ 1.1892, -1.5291, -1.0168, -0.4862, -0.1848],
          [-0.3499,  0.3034, -0.9799, -0.1717,  0.2129],
   ....0345, -2.1060,  0.4112, -0.4016]]]]), tensor([[[0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0]]]))
trace_kwargs = {}
test_args = (tensor([[[[-0.4096,  1.3747, -2.0644,  1.7185,  0.6732],
          [ 0.2784,  0.4741,  0.0809,  0.0726, -0.1037],
   ... 0, 0, 0],
         [0, 0, 0, 0, 0]],

        [[0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function lovasz_hinge_loss at 0x7f83e0025240>
trace_args = (tensor([[[[ 1.1892, -1.5291, -1.0168, -0.4862, -0.1848],
          [-0.3499,  0.3034, -0.9799, -0.1717,  0.2129],
   ....0345, -2.1060,  0.4112, -0.4016]]]]), tensor([[[0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0]]]))
trace_kwargs = {}
test_args = (tensor([[[[-0.4096,  1.3747, -2.0644,  1.7185,  0.6732],
          [ 0.2784,  0.4741,  0.0809,  0.0726, -0.1037],
   ... 0, 0, 0],
         [0, 0, 0, 0, 0]],

        [[0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function lovasz_hinge_loss at 0x7f83e0025240>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.lovasz_hinge.lovasz_hinge_loss
____________________________________________________________________________ test_lovasz_softmax_loss[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_lovasz_softmax_loss(target_framework, mode, backend_compile):
        trace_args = (
            torch.randn((1, 5, 3, 5)),
            torch.empty(1, 3, 5, dtype=torch.long).random_(5),
        )
        trace_kwargs = {}
        test_args = (
            torch.randn((5, 5, 3, 5)),
            torch.empty(5, 3, 5, dtype=torch.long).random_(5),
        )
        test_kwargs = {}
>       _test_function(
            kornia.losses.lovasz_softmax_loss,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_losses.py:367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function lovasz_softmax_loss at 0x7f83e00255a0>
trace_args = (tensor([[[[-0.4266,  0.1626,  0.2625, -0.9464, -0.7854],
          [ 0.3873, -0.1685,  0.6223,  0.7700,  1.3147],
   ....2489, -1.3365,  1.0392,  1.3214]]]]), tensor([[[2, 1, 3, 0, 2],
         [0, 2, 4, 2, 2],
         [4, 1, 1, 3, 3]]]))
trace_kwargs = {}
test_args = (tensor([[[[-4.8567e-01,  4.4864e-01,  7.6494e-01, -7.7625e-01,  1.0249e+00],
          [ 4.3679e-01,  9.4777e-01,  7.... 4, 0, 4],
         [2, 1, 1, 2, 2]],

        [[1, 1, 2, 0, 0],
         [3, 1, 0, 1, 2],
         [2, 2, 4, 3, 4]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function lovasz_softmax_loss at 0x7f83e00255a0>
trace_args = (tensor([[[[-0.4266,  0.1626,  0.2625, -0.9464, -0.7854],
          [ 0.3873, -0.1685,  0.6223,  0.7700,  1.3147],
   ....2489, -1.3365,  1.0392,  1.3214]]]]), tensor([[[2, 1, 3, 0, 2],
         [0, 2, 4, 2, 2],
         [4, 1, 1, 3, 3]]]))
trace_kwargs = {}
test_args = (tensor([[[[-4.8567e-01,  4.4864e-01,  7.6494e-01, -7.7625e-01,  1.0249e+00],
          [ 4.3679e-01,  9.4777e-01,  7.... 4, 0, 4],
         [2, 1, 1, 2, 2]],

        [[1, 1, 2, 0, 0],
         [3, 1, 0, 1, 2],
         [2, 2, 4, 3, 4]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function lovasz_softmax_loss at 0x7f83e00255a0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.lovasz_softmax.lovasz_softmax_loss
______________________________________________________________________________ test_js_div_loss_2d[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_js_div_loss_2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand((1, 1, 2, 4)),
            torch.rand((1, 1, 2, 4)),
        )
        trace_kwargs = {"reduction": "mean"}
        test_args = (
            torch.rand((5, 1, 2, 4)),
            torch.rand((5, 1, 2, 4)),
        )
        test_kwargs = {"reduction": "mean"}
>       _test_function(
            kornia.losses.js_div_loss_2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_losses.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function js_div_loss_2d at 0x7f83e0024160>
trace_args = (tensor([[[[0.9600, 0.3253, 0.8952, 0.2983],
          [0.3370, 0.2157, 0.3774, 0.2838]]]]), tensor([[[[0.3329, 0.6542, 0.0497, 0.6571],
          [0.3929, 0.1129, 0.4462, 0.2450]]]]))
trace_kwargs = {'reduction': 'mean'}
test_args = (tensor([[[[0.5645, 0.5435, 0.6512, 0.9839],
          [0.2503, 0.0867, 0.3652, 0.9958]]],


        [[[0.2463, 0.2848....2771, 0.9240, 0.6230]]],


        [[[0.8182, 0.8190, 0.5517, 0.4694],
          [0.1662, 0.3163, 0.8813, 0.4903]]]]))
test_kwargs = {'reduction': 'mean'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function js_div_loss_2d at 0x7f83e0024160>
trace_args = (tensor([[[[0.9600, 0.3253, 0.8952, 0.2983],
          [0.3370, 0.2157, 0.3774, 0.2838]]]]), tensor([[[[0.3329, 0.6542, 0.0497, 0.6571],
          [0.3929, 0.1129, 0.4462, 0.2450]]]]))
trace_kwargs = {'reduction': 'mean'}
test_args = (tensor([[[[0.5645, 0.5435, 0.6512, 0.9839],
          [0.2503, 0.0867, 0.3652, 0.9958]]],


        [[[0.2463, 0.2848....2771, 0.9240, 0.6230]]],


        [[[0.8182, 0.8190, 0.5517, 0.4694],
          [0.1662, 0.3163, 0.8813, 0.4903]]]]))
test_kwargs = {'reduction': 'mean'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function js_div_loss_2d at 0x7f83e0024160>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.divergence.js_div_loss_2d
______________________________________________________________________________ test_kl_div_loss_2d[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_kl_div_loss_2d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand((1, 1, 2, 4)),
            torch.rand((1, 1, 2, 4)),
        )
        trace_kwargs = {"reduction": "mean"}
        test_args = (
            torch.rand((5, 1, 2, 4)),
            torch.rand((5, 1, 2, 4)),
        )
        test_kwargs = {"reduction": "mean"}
>       _test_function(
            kornia.losses.kl_div_loss_2d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/test_losses.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function kl_div_loss_2d at 0x7f83e00241f0>
trace_args = (tensor([[[[0.5923, 0.1816, 0.1470, 0.0226],
          [0.5888, 0.5211, 0.5904, 0.2654]]]]), tensor([[[[0.1293, 0.8191, 0.3664, 0.6985],
          [0.0929, 0.4627, 0.9357, 0.4940]]]]))
trace_kwargs = {'reduction': 'mean'}
test_args = (tensor([[[[0.3124, 0.8271, 0.4126, 0.8944],
          [0.5763, 0.6062, 0.3103, 0.0525]]],


        [[[0.0859, 0.4310....2000, 0.5590, 0.4899]]],


        [[[0.8854, 0.2788, 0.2588, 0.6517],
          [0.0015, 0.5121, 0.4435, 0.7669]]]]))
test_kwargs = {'reduction': 'mean'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function kl_div_loss_2d at 0x7f83e00241f0>
trace_args = (tensor([[[[0.5923, 0.1816, 0.1470, 0.0226],
          [0.5888, 0.5211, 0.5904, 0.2654]]]]), tensor([[[[0.1293, 0.8191, 0.3664, 0.6985],
          [0.0929, 0.4627, 0.9357, 0.4940]]]]))
trace_kwargs = {'reduction': 'mean'}
test_args = (tensor([[[[0.3124, 0.8271, 0.4126, 0.8944],
          [0.5763, 0.6062, 0.3103, 0.0525]]],


        [[[0.0859, 0.4310....2000, 0.5590, 0.4899]]],


        [[[0.8854, 0.2788, 0.2588, 0.6517],
          [0.0015, 0.5121, 0.4435, 0.7669]]]]))
test_kwargs = {'reduction': 'mean'}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function kl_div_loss_2d at 0x7f83e00241f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.divergence.kl_div_loss_2d
______________________________________________________________________________ test_HausdorffERLoss[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_HausdorffERLoss(target_framework, mode, backend_compile):
        print("kornia.losses.HausdorffERLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledHausdorffERLoss = ivy.transpile(kornia.losses.HausdorffERLoss, source="torch", target=target_framework)

kornia/test_losses.py:434: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.hausdorff.HausdorffERLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.HausdorffERLoss
_____________________________________________________________________________ test_HausdorffERLoss3D[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_HausdorffERLoss3D(target_framework, mode, backend_compile):
        print("kornia.losses.HausdorffERLoss3D")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledHausdorffERLoss3D = ivy.transpile(kornia.losses.HausdorffERLoss3D, source="torch", target=target_framework)

kornia/test_losses.py:459: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.hausdorff.HausdorffERLoss3D'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.HausdorffERLoss3D
_________________________________________________________________________________ test_SSIMLoss[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SSIMLoss(target_framework, mode, backend_compile):
        print("kornia.losses.SSIMLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSSIMLoss = ivy.transpile(kornia.losses.SSIMLoss, source="torch", target=target_framework)

kornia/test_losses.py:484: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.ssim.SSIMLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.SSIMLoss
________________________________________________________________________________ test_SSIM3DLoss[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SSIM3DLoss(target_framework, mode, backend_compile):
        print("kornia.losses.SSIM3DLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSSIM3DLoss = ivy.transpile(kornia.losses.SSIM3DLoss, source="torch", target=target_framework)

kornia/test_losses.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.ssim3d.SSIM3DLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.SSIM3DLoss
________________________________________________________________________________ test_MS_SSIMLoss[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_MS_SSIMLoss(target_framework, mode, backend_compile):
        print("kornia.losses.MS_SSIMLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledMS_SSIMLoss = ivy.transpile(kornia.losses.MS_SSIMLoss, source="torch", target=target_framework)

kornia/test_losses.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.ms_ssim.MS_SSIMLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.MS_SSIMLoss
______________________________________________________________________________ test_TotalVariation[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_TotalVariation(target_framework, mode, backend_compile):
        print("kornia.losses.TotalVariation")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledTotalVariation = ivy.transpile(kornia.losses.TotalVariation, source="torch", target=target_framework)

kornia/test_losses.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.total_variation.TotalVariation'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.TotalVariation
_________________________________________________________________________________ test_PSNRLoss[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PSNRLoss(target_framework, mode, backend_compile):
        print("kornia.losses.PSNRLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledPSNRLoss = ivy.transpile(kornia.losses.PSNRLoss, source="torch", target=target_framework)

kornia/test_losses.py:583: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.psnr.PSNRLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.PSNRLoss
________________________________________________________________________ test_InverseDepthSmoothnessLoss[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_InverseDepthSmoothnessLoss(target_framework, mode, backend_compile):
        print("kornia.losses.InverseDepthSmoothnessLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledInverseDepthSmoothnessLoss = ivy.transpile(kornia.losses.InverseDepthSmoothnessLoss, source="torch", target=target_framework)

kornia/test_losses.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.depth_smooth.InverseDepthSmoothnessLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.InverseDepthSmoothnessLoss
______________________________________________________________________________ test_CharbonnierLoss[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_CharbonnierLoss(target_framework, mode, backend_compile):
        print("kornia.losses.CharbonnierLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledCharbonnierLoss = ivy.transpile(kornia.losses.CharbonnierLoss, source="torch", target=target_framework)

kornia/test_losses.py:633: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.charbonnier.CharbonnierLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.CharbonnierLoss
________________________________________________________________________________ test_WelschLoss[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_WelschLoss(target_framework, mode, backend_compile):
        print("kornia.losses.WelschLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledWelschLoss = ivy.transpile(kornia.losses.WelschLoss, source="torch", target=target_framework)

kornia/test_losses.py:658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.welsch.WelschLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.WelschLoss
________________________________________________________________________________ test_CauchyLoss[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_CauchyLoss(target_framework, mode, backend_compile):
        print("kornia.losses.CauchyLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledCauchyLoss = ivy.transpile(kornia.losses.CauchyLoss, source="torch", target=target_framework)

kornia/test_losses.py:683: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.cauchy.CauchyLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.CauchyLoss
_____________________________________________________________________________ test_GemanMcclureLoss[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_GemanMcclureLoss(target_framework, mode, backend_compile):
        print("kornia.losses.GemanMcclureLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledGemanMcclureLoss = ivy.transpile(kornia.losses.GemanMcclureLoss, source="torch", target=target_framework)

kornia/test_losses.py:708: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.geman_mcclure.GemanMcclureLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.GemanMcclureLoss
_________________________________________________________________________ test_BinaryFocalLossWithLogits[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_BinaryFocalLossWithLogits(target_framework, mode, backend_compile):
        print("kornia.losses.BinaryFocalLossWithLogits")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledBinaryFocalLossWithLogits = ivy.transpile(kornia.losses.BinaryFocalLossWithLogits, source="torch", target=target_framework)

kornia/test_losses.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.focal.BinaryFocalLossWithLogits'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.BinaryFocalLossWithLogits
_________________________________________________________________________________ test_DiceLoss[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_DiceLoss(target_framework, mode, backend_compile):
        print("kornia.losses.DiceLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledDiceLoss = ivy.transpile(kornia.losses.DiceLoss, source="torch", target=target_framework)

kornia/test_losses.py:758: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.dice.DiceLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.DiceLoss
________________________________________________________________________________ test_TverskyLoss[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_TverskyLoss(target_framework, mode, backend_compile):
        print("kornia.losses.TverskyLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledTverskyLoss = ivy.transpile(kornia.losses.TverskyLoss, source="torch", target=target_framework)

kornia/test_losses.py:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.tversky.TverskyLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.TverskyLoss
_________________________________________________________________________________ test_FocalLoss[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_FocalLoss(target_framework, mode, backend_compile):
        print("kornia.losses.FocalLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledFocalLoss = ivy.transpile(kornia.losses.FocalLoss, source="torch", target=target_framework)

kornia/test_losses.py:808: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.focal.FocalLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.FocalLoss
______________________________________________________________________________ test_LovaszHingeLoss[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LovaszHingeLoss(target_framework, mode, backend_compile):
        print("kornia.losses.LovaszHingeLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledLovaszHingeLoss = ivy.transpile(kornia.losses.LovaszHingeLoss, source="torch", target=target_framework)

kornia/test_losses.py:833: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.lovasz_hinge.LovaszHingeLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.LovaszHingeLoss
_____________________________________________________________________________ test_LovaszSoftmaxLoss[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LovaszSoftmaxLoss(target_framework, mode, backend_compile):
        print("kornia.losses.LovaszSoftmaxLoss")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledLovaszSoftmaxLoss = ivy.transpile(kornia.losses.LovaszSoftmaxLoss, source="torch", target=target_framework)

kornia/test_losses.py:858: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.losses.lovasz_softmax.LovaszSoftmaxLoss'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.losses.LovaszSoftmaxLoss
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_losses.py::test_binary_focal_loss_with_logits[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/test_losses.py::test_focal_loss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_losses.py::test_dice_loss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_losses.py::test_tversky_loss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have ...
FAILED kornia/test_losses.py::test_lovasz_hinge_loss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/test_losses.py::test_lovasz_softmax_loss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
FAILED kornia/test_losses.py::test_js_div_loss_2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/test_losses.py::test_kl_div_loss_2d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/test_losses.py::test_HausdorffERLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_losses.py::test_HausdorffERLoss3D[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
FAILED kornia/test_losses.py::test_SSIMLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_losses.py::test_SSIM3DLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_losses.py::test_MS_SSIMLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_losses.py::test_TotalVariation[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not hav...
FAILED kornia/test_losses.py::test_PSNRLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_losses.py::test_InverseDepthSmoothnessLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/test_losses.py::test_CharbonnierLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_losses.py::test_WelschLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_losses.py::test_CauchyLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an...
FAILED kornia/test_losses.py::test_GemanMcclureLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not h...
FAILED kornia/test_losses.py::test_BinaryFocalLossWithLogits[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you...
FAILED kornia/test_losses.py::test_DiceLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an I...
FAILED kornia/test_losses.py::test_TverskyLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have a...
FAILED kornia/test_losses.py::test_FocalLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_losses.py::test_LovaszHingeLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ha...
FAILED kornia/test_losses.py::test_LovaszSoftmaxLoss[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not ...
=============================================================================== 26 failed, 9 passed in 175.16s (0:02:55) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 14 items

kornia/test_feature4.py FFFFF.FFFFFFFF                                                                                                                                                           [100%]

=============================================================================================== FAILURES ===============================================================================================
________________________________________________________________________________ test_SIFTFeature[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SIFTFeature(target_framework, mode, backend_compile):
        print("kornia.feature.SIFTFeature")
    
        if backend_compile:
            pytest.skip()
    
        import os
        flag = os.environ.get("APPLY_TRANSPOSE_OPTIMIZATION")
        os.environ["APPLY_TRANSPOSE_OPTIMIZATION"] = "false"
    
>       TranspiledSIFTFeature = ivy.transpile(kornia.feature.SIFTFeature, source="torch", target=target_framework)

kornia/test_feature4.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.integrated.SIFTFeature'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.SIFTFeature
___________________________________________________________________________ test_SIFTFeatureScaleSpace[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_SIFTFeatureScaleSpace(target_framework, mode, backend_compile):
        print("kornia.feature.SIFTFeatureScaleSpace")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledSIFTFeatureScaleSpace = ivy.transpile(kornia.feature.SIFTFeatureScaleSpace, source="torch", target=target_framework)

kornia/test_feature4.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.integrated.SIFTFeatureScaleSpace'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.SIFTFeatureScaleSpace
_____________________________________________________________________________ test_GFTTAffNetHardNet[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_GFTTAffNetHardNet(target_framework, mode, backend_compile):
        print("kornia.feature.GFTTAffNetHardNet")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledGFTTAffNetHardNet = ivy.transpile(kornia.feature.GFTTAffNetHardNet, source="torch", target=target_framework)
    
        x = torch.rand(1, 1, 256, 256)
        torch_out = kornia.feature.GFTTAffNetHardNet(num_features=5000)(x)
    
        transpiled_x = _nest_torch_tensor_to_new_framework(x, target_framework)
>       transpiled_out = TranspiledGFTTAffNetHardNet(num_features=5000)(transpiled_x)

kornia/test_feature4.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'NoneType' object has no attribute 'items'") raised in repr()] tensorflow_GFTTAffNetHardNet object at 0x7f636576e650>, num_features = 5000, upright = False, device = 'cpu'
config = {'nms_size': 15, 'pyramid_levels': 4, 's_mult': 22.0, 'scale_factor_levels': 1.4142135623730951, ...}

    def __init__(
        self,
        num_features=8000,
        upright=False,
        device=tensorflow_device_frnt("cpu"),
        config=tensorflow_get_default_detector_config(),
    ):
        from ...ivy.functional.frontends.torch.tensor import tensorflow_to_frnt_
        from .scale_space_detector import tensorflow_MultiResolutionDetector
        from .responses import tensorflow_CornerGFTT
        from .orientation import tensorflow_PassLAF
        from .orientation import tensorflow_LAFOrienter
        from .affine_shape import tensorflow_LAFAffNetShapeEstimator
    
        detector = tensorflow_to_frnt_(
            tensorflow_MultiResolutionDetector(
                tensorflow_CornerGFTT(),
                num_features,
                config,
                ori_module=tensorflow_PassLAF()
                if upright
                else tensorflow_LAFOrienter(19),
>               aff_module=tensorflow_LAFAffNetShapeEstimator(True).eval(),
            ),
            device,
        )

Translated_Outputs/tensorflow_outputs/kornia/feature/integrated.py:853: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNor...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
args = (True,), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LAFAffNetShapeEstimator(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNor...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
pretrained = True, preserve_orientation = True

    @tensorflow_store_config_info
    def __init__(self, pretrained=False, preserve_orientation=True):
        from ...torch.nn.modules.container import tensorflow_Sequential
        from ...torch.nn.modules.activation import tensorflow_ReLU
        from ...torch.nn.modules.dropout import tensorflow_Dropout
        from ...torch.nn.modules.activation import tensorflow_Tanh
        from ...torch.nn.modules.pooling import tensorflow_AdaptiveAvgPool2d
        from ...torch.hub import tensorflow_load_state_dict_from_url
        from ..utils.helpers import tensorflow_map_location_to_cpu
        from ...tensorflow__stateful_layers import KerasConv2D
        from ...tensorflow__stateful_layers import KerasBatchNorm2D
    
        self.super___init__(
            pretrained=pretrained,
            preserve_orientation=preserve_orientation,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.features = tensorflow_Sequential(
            KerasConv2D(
                in_channels=1,
                filters=16,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=16,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=16,
                filters=16,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=16,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=16,
                filters=32,
                kernel_size=3,
                strides=2,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=32,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=32,
                filters=32,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=32,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=32,
                filters=64,
                kernel_size=3,
                strides=2,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=64,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=64,
                filters=64,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=64,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            tensorflow_Dropout(0.25),
            KerasConv2D(
                in_channels=64,
                filters=3,
                kernel_size=8,
                strides=1,
                padding=0,
                use_bias=True,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            tensorflow_Tanh(),
            tensorflow_AdaptiveAvgPool2d(1),
        )
        self.patch_size = 32
        if pretrained:
            pretrained_dict = tensorflow_load_state_dict_from_url(
>               urls["affnet"], map_location=tensorflow_map_location_to_cpu
            )
E           KeyError: 'affnet'

Translated_Outputs/tensorflow_outputs/kornia/feature/affine_shape.py:210: KeyError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.GFTTAffNetHardNet

Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling GFTTAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                            
Transpilation of GFTTAffNetHardNet complete.
----------------------------------------------------------------------------------------- Captured stderr call -----------------------------------------------------------------------------------------
Downloading: "https://github.com/ducha-aiki/affnet/raw/master/pretrained/AffNet.pth" to /root/.cache/torch/hub/checkpoints/AffNet.pth

  0%|          | 0.00/332k [00:00<?, ?B/s]
100%|| 332k/332k [00:00<00:00, 12.4MB/s]
Downloading: "https://github.com/DagnyT/hardnet/raw/master/pretrained/train_liberty_with_aug/checkpoint_liberty_with_aug.pth" to /root/.cache/torch/hub/checkpoints/checkpoint_liberty_with_aug.pth

  0%|          | 0.00/5.10M [00:00<?, ?B/s]
100%|| 5.10M/5.10M [00:00<00:00, 80.5MB/s]
____________________________________________________________________________ test_KeyNetAffNetHardNet[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_KeyNetAffNetHardNet(target_framework, mode, backend_compile):
        print("kornia.feature.KeyNetAffNetHardNet")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledKeyNetAffNetHardNet = ivy.transpile(kornia.feature.KeyNetAffNetHardNet, source="torch", target=target_framework)
    
        x = torch.rand(1, 1, 256, 256)
        torch_out = kornia.feature.KeyNetAffNetHardNet(num_features=5000)(x)
    
        transpiled_x = _nest_torch_tensor_to_new_framework(x, target_framework)
>       transpiled_out = TranspiledKeyNetAffNetHardNet(num_features=5000)(transpiled_x)

kornia/test_feature4.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'NoneType' object has no attribute 'items'") raised in repr()] tensorflow_KeyNetAffNetHardNet object at 0x7f636dc0cdc0>, num_features = 5000, upright = False, device = 'cpu'
scale_laf = 1.0

    def __init__(
        self,
        num_features=8000,
        upright=False,
        device=tensorflow_device_frnt("cpu"),
        scale_laf=1.0,
    ):
        from .orientation import tensorflow_PassLAF
        from .orientation import tensorflow_LAFOrienter
        from .orientation import tensorflow_OriNet
        from ...ivy.functional.frontends.torch.tensor import tensorflow_to_frnt_
        from .keynet import tensorflow_KeyNetDetector
        from .affine_shape import tensorflow_LAFAffNetShapeEstimator
    
        ori_module = (
            tensorflow_PassLAF()
            if upright
>           else tensorflow_LAFOrienter(angle_detector=tensorflow_OriNet(True))
        )

Translated_Outputs/tensorflow_outputs/kornia/feature/integrated.py:882: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_OriNet(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
    (2): te...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
args = (True,), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_OriNet(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
    (2): te...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
pretrained = True, eps = 1e-08

    @tensorflow_store_config_info
    def __init__(self, pretrained=False, eps=1e-08):
        from ...torch.nn.modules.container import tensorflow_Sequential
        from ...torch.nn.modules.activation import tensorflow_ReLU
        from ...torch.nn.modules.dropout import tensorflow_Dropout
        from ...torch.nn.modules.activation import tensorflow_Tanh
        from ...torch.nn.modules.pooling import tensorflow_AdaptiveAvgPool2d
        from ...torch.hub import tensorflow_load_state_dict_from_url
        from ..utils.helpers import tensorflow_map_location_to_cpu
        from ...tensorflow__stateful_layers import KerasConv2D
        from ...tensorflow__stateful_layers import KerasBatchNorm2D
    
        self.super___init__(
            pretrained=pretrained,
            eps=eps,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.features = tensorflow_Sequential(
            KerasConv2D(
                in_channels=1,
                filters=16,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=16,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=16,
                filters=16,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=16,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=16,
                filters=32,
                kernel_size=3,
                strides=2,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=32,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=32,
                filters=32,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=32,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=32,
                filters=64,
                kernel_size=3,
                strides=2,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=64,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=64,
                filters=64,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=64,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            tensorflow_Dropout(0.25),
            KerasConv2D(
                in_channels=64,
                filters=2,
                kernel_size=8,
                strides=1,
                padding=1,
                use_bias=True,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            tensorflow_Tanh(),
            tensorflow_AdaptiveAvgPool2d(1),
        )
        self.eps = eps
        if pretrained:
            pretrained_dict = tensorflow_load_state_dict_from_url(
>               urls["orinet"], map_location=tensorflow_map_location_to_cpu
            )
E           KeyError: 'orinet'

Translated_Outputs/tensorflow_outputs/kornia/feature/orientation.py:1042: KeyError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.KeyNetAffNetHardNet

Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetAffNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
                                                                                                                                              
Transpilation of KeyNetAffNetHardNet complete.
----------------------------------------------------------------------------------------- Captured stderr call -----------------------------------------------------------------------------------------
Downloading: "https://github.com/ducha-aiki/affnet/raw/master/pretrained/OriNet.pth" to /root/.cache/torch/hub/checkpoints/OriNet.pth

  0%|          | 0.00/316k [00:00<?, ?B/s]
100%|| 316k/316k [00:00<00:00, 11.4MB/s]
Downloading: "https://github.com/axelBarroso/Key.Net-Pytorch/raw/main/model/weights/keynet_pytorch.pth" to /root/.cache/torch/hub/checkpoints/keynet_pytorch.pth

  0%|          | 0.00/78.0k [00:00<?, ?B/s]
100%|| 78.0k/78.0k [00:00<00:00, 7.33MB/s]
_______________________________________________________________________________ test_KeyNetHardNet[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_KeyNetHardNet(target_framework, mode, backend_compile):
        print("kornia.feature.KeyNetHardNet")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledKeyNetHardNet = ivy.transpile(kornia.feature.KeyNetHardNet, source="torch", target=target_framework)
    
        x = torch.rand(1, 1, 256, 256)
        torch_out = kornia.feature.KeyNetHardNet(num_features=5000)(x)
    
        transpiled_x = _nest_torch_tensor_to_new_framework(x, target_framework)
>       transpiled_out = TranspiledKeyNetHardNet(num_features=5000)(transpiled_x)

kornia/test_feature4.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'NoneType' object has no attribute 'items'") raised in repr()] tensorflow_KeyNetHardNet object at 0x7f636d7a3580>, num_features = 5000, upright = False, device = 'cpu'
scale_laf = 1.0

    def __init__(
        self,
        num_features=8000,
        upright=False,
        device=tensorflow_device_frnt("cpu"),
        scale_laf=1.0,
    ):
        from .orientation import tensorflow_PassLAF
        from .orientation import tensorflow_LAFOrienter
        from .orientation import tensorflow_OriNet
        from ...ivy.functional.frontends.torch.tensor import tensorflow_to_frnt_
        from .keynet import tensorflow_KeyNetDetector
    
        ori_module = (
            tensorflow_PassLAF()
            if upright
>           else tensorflow_LAFOrienter(angle_detector=tensorflow_OriNet(True))
        )

Translated_Outputs/tensorflow_outputs/kornia/feature/integrated.py:881: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_OriNet(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
    (2): te...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
args = (True,), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_OriNet(
  (features): tensorflow_Sequential(
    (0): KerasConv2D()
    (1): KerasBatchNorm2D()
    (2): te...tensorflow_Dropout()
    (19): KerasConv2D()
    (20): tensorflow_Tanh()
    (21): tensorflow_AdaptiveAvgPool2d()
  )
)
pretrained = True, eps = 1e-08

    @tensorflow_store_config_info
    def __init__(self, pretrained=False, eps=1e-08):
        from ...torch.nn.modules.container import tensorflow_Sequential
        from ...torch.nn.modules.activation import tensorflow_ReLU
        from ...torch.nn.modules.dropout import tensorflow_Dropout
        from ...torch.nn.modules.activation import tensorflow_Tanh
        from ...torch.nn.modules.pooling import tensorflow_AdaptiveAvgPool2d
        from ...torch.hub import tensorflow_load_state_dict_from_url
        from ..utils.helpers import tensorflow_map_location_to_cpu
        from ...tensorflow__stateful_layers import KerasConv2D
        from ...tensorflow__stateful_layers import KerasBatchNorm2D
    
        self.super___init__(
            pretrained=pretrained,
            eps=eps,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.features = tensorflow_Sequential(
            KerasConv2D(
                in_channels=1,
                filters=16,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=16,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=16,
                filters=16,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=16,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=16,
                filters=32,
                kernel_size=3,
                strides=2,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=32,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=32,
                filters=32,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=32,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=32,
                filters=64,
                kernel_size=3,
                strides=2,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=64,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            KerasConv2D(
                in_channels=64,
                filters=64,
                kernel_size=3,
                strides=1,
                padding=1,
                use_bias=False,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            KerasBatchNorm2D(
                num_features=64,
                momentum=0.1,
                epsilon=1e-05,
                center=False,
                scale=False,
                axis=1,
                track_running_stats=True,
            ),
            tensorflow_ReLU(),
            tensorflow_Dropout(0.25),
            KerasConv2D(
                in_channels=64,
                filters=2,
                kernel_size=8,
                strides=1,
                padding=1,
                use_bias=True,
                dilation_rate=1,
                groups=1,
                padding_mode="zeros",
                data_format="channels_first",
            ),
            tensorflow_Tanh(),
            tensorflow_AdaptiveAvgPool2d(1),
        )
        self.eps = eps
        if pretrained:
            pretrained_dict = tensorflow_load_state_dict_from_url(
>               urls["orinet"], map_location=tensorflow_map_location_to_cpu
            )
E           KeyError: 'orinet'

Translated_Outputs/tensorflow_outputs/kornia/feature/orientation.py:1042: KeyError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.KeyNetHardNet

Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling KeyNetHardNet from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                        
Transpilation of KeyNetHardNet complete.
______________________________________________________________________ test_GeometryAwareDescriptorMatcher[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_GeometryAwareDescriptorMatcher(target_framework, mode, backend_compile):
        print("kornia.feature.GeometryAwareDescriptorMatcher")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledGeometryAwareDescriptorMatcher = ivy.transpile(kornia.feature.GeometryAwareDescriptorMatcher, source="torch", target=target_framework)

kornia/test_feature4.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.matching.GeometryAwareDescriptorMatcher'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.GeometryAwareDescriptorMatcher
____________________________________________________________________________ test_LocalFeatureMatcher[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LocalFeatureMatcher(target_framework, mode, backend_compile):
        print("kornia.feature.LocalFeatureMatcher")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledGFTTAffNetHardNet = ivy.transpile(kornia.feature.GFTTAffNetHardNet, source="torch", target=target_framework)

kornia/test_feature4.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.integrated.GFTTAffNetHardNet'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LocalFeatureMatcher
_____________________________________________________________________________ test_LightGlueMatcher[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LightGlueMatcher(target_framework, mode, backend_compile):
        print("kornia.feature.LightGlueMatcher")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledLightGlueMatcher = ivy.transpile(kornia.feature.LightGlueMatcher, source="torch", target=target_framework)
    
        torch_args = (
            torch.rand(2, 128),
            torch.rand(5, 128),
            torch.rand(1, 2, 2, 3),
            torch.rand(1, 5, 2, 3),
        )
        torch_out = kornia.feature.LightGlueMatcher('disk')(*torch_args)
    
        transpiled_args = _nest_torch_tensor_to_new_framework(torch_args, target_framework)
>       transpiled_out = TranspiledLightGlueMatcher('disk')(*transpiled_args)

kornia/test_feature4.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LightGlueMatcher(), feature_name = 'disk', params = {}

    def __init__(self, feature_name="disk", params={}):
        from .lightglue import tensorflow_LightGlue
    
        feature_name_: typing.Any = feature_name.lower()
        super().__init__(feature_name_)
        self.feature_name = feature_name_
        self.params = params
>       self.matcher = tensorflow_LightGlue(self.feature_name, **params)

Translated_Outputs/tensorflow_outputs/kornia/feature/integrated.py:953: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LightGlue(
  (input_proj): KerasDense()
  (posenc): tensorflow_LearnableFourierPositionalEncoding(
    (Wr): KerasDense()
  )
), args = ('disk',), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LightGlue(
  (input_proj): KerasDense()
  (posenc): tensorflow_LearnableFourierPositionalEncoding(
    (Wr): KerasDense()
  )
), features = 'disk', conf_ = {}
tensorflow_KORNIA_CHECK = <function tensorflow_KORNIA_CHECK at 0x7f636c82d630>, tensorflow_get_item = <function tensorflow_get_item at 0x7f636c7df5b0>
tensorflow_Identity = <class 'Translated_Outputs.tensorflow_outputs.torch.nn.modules.linear.tensorflow_Identity'>
tensorflow_load_state_dict_from_url = <function tensorflow_load_state_dict_from_url at 0x7f636695c5e0>, tensorflow_load_frnt = <function tensorflow_load_frnt at 0x7f636ce9bf40>
ModuleList = <class 'Translated_Outputs.tensorflow_outputs.torch.nn.modules.container.tensorflow_ModuleList'>
KerasDense = <class 'Translated_Outputs.tensorflow_outputs.tensorflow__stateful_layers.KerasDense'>

    @tensorflow_store_config_info
    def __init__(self, features="superpoint", **conf_):
        from ..core.check import tensorflow_KORNIA_CHECK
        from ...ivy.functional.backends.tensorflow.general import tensorflow_get_item
        from ...torch.nn.modules.linear import tensorflow_Identity
        from ...torch.hub import tensorflow_load_state_dict_from_url
        from ...ivy.functional.frontends.torch.serialization.serialization import (
            tensorflow_load_frnt,
        )
        from ..core._backend import ModuleList
        from ...tensorflow__stateful_layers import KerasDense
    
        self.super___init__(
            features=features,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.conf = conf = SimpleNamespace(**{**self.default_conf, **conf_})
        if features is not None:
            tensorflow_KORNIA_CHECK(
                features in list(self.features.keys()), "Features keys are wrong"
            )
            for k, v in tensorflow_get_item(self.features, features).items():
                setattr(conf, k, v)
        tensorflow_KORNIA_CHECK(not (self.conf.add_scale_ori and self.conf.add_laf))
        if conf.input_dim != conf.descriptor_dim:
            self.input_proj = KerasDense(
                in_features=conf.input_dim, units=conf.descriptor_dim, use_bias=True
            )
        else:
            self.input_proj = tensorflow_Identity()
        head_dim = conf.descriptor_dim // conf.num_heads
        self.posenc = tensorflow_LearnableFourierPositionalEncoding(
            2 + 2 * conf.add_scale_ori + 4 * conf.add_laf, head_dim, head_dim
        )
        h, n, d = conf.num_heads, conf.n_layers, conf.descriptor_dim
        ag__result_list_0 = []
        for _ in range(n):
>           res = tensorflow_TransformerLayer(d, h, conf.flash)

Translated_Outputs/tensorflow_outputs/kornia/feature/lightglue.py:3177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_TransformerLayer(), args = (256, 4, True), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_TransformerLayer(), args = (256, 4, True), kwargs = {}

    @tensorflow_store_config_info
    def __init__(self, *args, **kwargs):
        self.super___init__(
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
>       self.self_attn = tensorflow_SelfBlock(*args, **kwargs)

Translated_Outputs/tensorflow_outputs/kornia/feature/lightglue.py:2224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SelfBlock(
  (Wqkv): KerasDense()
), args = (256, 4, True), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SelfBlock(
  (Wqkv): KerasDense()
), embed_dim = 256, num_heads = 4, flash = True, bias = True

    @tensorflow_store_config_info
    def __init__(self, embed_dim, num_heads, flash=False, bias=True):
        from ..core.check import tensorflow_KORNIA_CHECK
        from ...torch.nn.modules.container import tensorflow_Sequential
        from ...torch.nn.modules.normalization import tensorflow_LayerNorm
        from ...torch.nn.modules.activation import tensorflow_GELU
        from ...tensorflow__stateful_layers import KerasDense
    
        self.super___init__(
            embed_dim,
            num_heads,
            flash=flash,
            bias=bias,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.embed_dim = embed_dim
        self.num_heads = num_heads
        tensorflow_KORNIA_CHECK(
            self.embed_dim % num_heads == 0,
            "Embed dimension should be dividable by num_heads",
        )
        self.head_dim = self.embed_dim // num_heads
        self.Wqkv = KerasDense(
            in_features=embed_dim, units=3 * embed_dim, use_bias=bias
        )
>       self.inner_attn = tensorflow_Attention(flash)

Translated_Outputs/tensorflow_outputs/kornia/feature/lightglue.py:1362: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Attention(), args = (True,), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Attention(), allow_flash = True

    @tensorflow_store_config_info
    def __init__(self, allow_flash):
        from ...torch.backends.cuda.__init__ import tensorflow_enable_flash_sdp
    
        self.super___init__(
            allow_flash,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        if allow_flash and not FLASH_AVAILABLE:
            warnings.warn(
                "FlashAttention is not available. For optimal speed, consider installing torch >= 2.0 or flash-attn.",
                stacklevel=2,
            )
        self.enable_flash = allow_flash and FLASH_AVAILABLE
>       self.has_sdp = hasattr(torch.nn.functional, "scaled_dot_product_attention")
E       NameError: name 'torch' is not defined

Translated_Outputs/tensorflow_outputs/kornia/feature/lightglue.py:911: NameError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LightGlueMatcher

Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LightGlueMatcher from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
                                                                                                                                           
Transpilation of LightGlueMatcher complete.
Loaded LightGlue model
----------------------------------------------------------------------------------------- Captured stderr call -----------------------------------------------------------------------------------------
Downloading: "https://github.com/cvg/LightGlue/releases/download/v0.1_arxiv/disk_lightglue.pth" to /root/.cache/torch/hub/checkpoints/disk_lightglue_v0-1_arxiv-pth

  0%|          | 0.00/45.4M [00:00<?, ?B/s]
 22%|       | 10.1M/45.4M [00:00<00:00, 77.4MB/s]
 51%|    | 23.4M/45.4M [00:00<00:00, 109MB/s] 
 81%|  | 36.9M/45.4M [00:00<00:00, 122MB/s]
100%|| 45.4M/45.4M [00:00<00:00, 110MB/s]
_________________________________________________________________________________ test_LightGlue[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LightGlue(target_framework, mode, backend_compile):
        print("kornia.feature.LightGlue")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledLightGlue = ivy.transpile(kornia.feature.LightGlue, source="torch", target=target_framework)
    
        data = {
            "image0": {
                "keypoints": torch.rand(1, 100, 2),
                "descriptors": torch.rand(1, 100, 256),
                "image_size": torch.tensor([[640, 480]]),
            },
            "image1": {
                "keypoints": torch.rand(1, 120, 2),
                "descriptors": torch.rand(1, 120, 256),
                "image_size": torch.tensor([[640, 480]]),
            }
        }
        torch_out = kornia.feature.LightGlue(features='superpoint')(data)
    
        transpiled_data = _nest_torch_tensor_to_new_framework(data, target_framework)
>       transpiled_out = TranspiledLightGlue(features='superpoint')(transpiled_data)

kornia/test_feature4.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LightGlue(
  (input_proj): tensorflow_Identity()
  (posenc): tensorflow_LearnableFourierPositionalEncoding(
    (Wr): KerasDense()
  )
), args = ()
kwargs = {'features': 'superpoint'}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_LightGlue(
  (input_proj): tensorflow_Identity()
  (posenc): tensorflow_LearnableFourierPositionalEncoding(
    (Wr): KerasDense()
  )
), features = 'superpoint', conf_ = {}
tensorflow_KORNIA_CHECK = <function tensorflow_KORNIA_CHECK at 0x7f636c82d630>, tensorflow_get_item = <function tensorflow_get_item at 0x7f636c7df5b0>
tensorflow_Identity = <class 'Translated_Outputs.tensorflow_outputs.torch.nn.modules.linear.tensorflow_Identity'>
tensorflow_load_state_dict_from_url = <function tensorflow_load_state_dict_from_url at 0x7f636695c5e0>, tensorflow_load_frnt = <function tensorflow_load_frnt at 0x7f636ce9bf40>
ModuleList = <class 'Translated_Outputs.tensorflow_outputs.torch.nn.modules.container.tensorflow_ModuleList'>
KerasDense = <class 'Translated_Outputs.tensorflow_outputs.tensorflow__stateful_layers.KerasDense'>

    @tensorflow_store_config_info
    def __init__(self, features="superpoint", **conf_):
        from ..core.check import tensorflow_KORNIA_CHECK
        from ...ivy.functional.backends.tensorflow.general import tensorflow_get_item
        from ...torch.nn.modules.linear import tensorflow_Identity
        from ...torch.hub import tensorflow_load_state_dict_from_url
        from ...ivy.functional.frontends.torch.serialization.serialization import (
            tensorflow_load_frnt,
        )
        from ..core._backend import ModuleList
        from ...tensorflow__stateful_layers import KerasDense
    
        self.super___init__(
            features=features,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.conf = conf = SimpleNamespace(**{**self.default_conf, **conf_})
        if features is not None:
            tensorflow_KORNIA_CHECK(
                features in list(self.features.keys()), "Features keys are wrong"
            )
            for k, v in tensorflow_get_item(self.features, features).items():
                setattr(conf, k, v)
        tensorflow_KORNIA_CHECK(not (self.conf.add_scale_ori and self.conf.add_laf))
        if conf.input_dim != conf.descriptor_dim:
            self.input_proj = KerasDense(
                in_features=conf.input_dim, units=conf.descriptor_dim, use_bias=True
            )
        else:
            self.input_proj = tensorflow_Identity()
        head_dim = conf.descriptor_dim // conf.num_heads
        self.posenc = tensorflow_LearnableFourierPositionalEncoding(
            2 + 2 * conf.add_scale_ori + 4 * conf.add_laf, head_dim, head_dim
        )
        h, n, d = conf.num_heads, conf.n_layers, conf.descriptor_dim
        ag__result_list_0 = []
        for _ in range(n):
>           res = tensorflow_TransformerLayer(d, h, conf.flash)

Translated_Outputs/tensorflow_outputs/kornia/feature/lightglue.py:3177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_TransformerLayer(), args = (256, 4, True), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_TransformerLayer(), args = (256, 4, True), kwargs = {}

    @tensorflow_store_config_info
    def __init__(self, *args, **kwargs):
        self.super___init__(
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
>       self.self_attn = tensorflow_SelfBlock(*args, **kwargs)

Translated_Outputs/tensorflow_outputs/kornia/feature/lightglue.py:2224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SelfBlock(
  (Wqkv): KerasDense()
), args = (256, 4, True), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_SelfBlock(
  (Wqkv): KerasDense()
), embed_dim = 256, num_heads = 4, flash = True, bias = True

    @tensorflow_store_config_info
    def __init__(self, embed_dim, num_heads, flash=False, bias=True):
        from ..core.check import tensorflow_KORNIA_CHECK
        from ...torch.nn.modules.container import tensorflow_Sequential
        from ...torch.nn.modules.normalization import tensorflow_LayerNorm
        from ...torch.nn.modules.activation import tensorflow_GELU
        from ...tensorflow__stateful_layers import KerasDense
    
        self.super___init__(
            embed_dim,
            num_heads,
            flash=flash,
            bias=bias,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.embed_dim = embed_dim
        self.num_heads = num_heads
        tensorflow_KORNIA_CHECK(
            self.embed_dim % num_heads == 0,
            "Embed dimension should be dividable by num_heads",
        )
        self.head_dim = self.embed_dim // num_heads
        self.Wqkv = KerasDense(
            in_features=embed_dim, units=3 * embed_dim, use_bias=bias
        )
>       self.inner_attn = tensorflow_Attention(flash)

Translated_Outputs/tensorflow_outputs/kornia/feature/lightglue.py:1362: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Attention(), args = (True,), kwargs = {}

    @functools.wraps(fn)
    def wrapper(self, *args, **kwargs):
>       fn(self, *args, **kwargs)

Translated_Outputs/tensorflow_outputs/ivy/utils/decorator_utils.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensorflow_Attention(), allow_flash = True

    @tensorflow_store_config_info
    def __init__(self, allow_flash):
        from ...torch.backends.cuda.__init__ import tensorflow_enable_flash_sdp
    
        self.super___init__(
            allow_flash,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        if allow_flash and not FLASH_AVAILABLE:
            warnings.warn(
                "FlashAttention is not available. For optimal speed, consider installing torch >= 2.0 or flash-attn.",
                stacklevel=2,
            )
        self.enable_flash = allow_flash and FLASH_AVAILABLE
>       self.has_sdp = hasattr(torch.nn.functional, "scaled_dot_product_attention")
E       NameError: name 'torch' is not defined

Translated_Outputs/tensorflow_outputs/kornia/feature/lightglue.py:911: NameError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LightGlue
Loaded LightGlue model
----------------------------------------------------------------------------------------- Captured stderr call -----------------------------------------------------------------------------------------
Downloading: "https://github.com/cvg/LightGlue/releases/download/v0.1_arxiv/superpoint_lightglue.pth" to /root/.cache/torch/hub/checkpoints/superpoint_lightglue_v0-1_arxiv-pth

  0%|          | 0.00/45.3M [00:00<?, ?B/s]
 18%|        | 8.38M/45.3M [00:00<00:00, 76.5MB/s]
 35%|      | 15.8M/45.3M [00:00<00:00, 59.3MB/s]
 48%|     | 21.6M/45.3M [00:00<00:00, 50.6MB/s]
 67%|   | 30.1M/45.3M [00:00<00:00, 62.3MB/s]
 83%| | 37.6M/45.3M [00:00<00:00, 67.3MB/s]
 98%|| 44.4M/45.3M [00:00<00:00, 59.1MB/s]
100%|| 45.3M/45.3M [00:00<00:00, 61.3MB/s]
___________________________________________________________________________________ test_LoFTR[tensorflow-s2s-False] ___________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LoFTR(target_framework, mode, backend_compile):
        print("kornia.feature.LoFTR")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledLoFTR = ivy.transpile(kornia.feature.LoFTR, source="torch", target=target_framework)

kornia/test_feature4.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.loftr.loftr.LoFTR'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LoFTR
__________________________________________________________________________________ test_PassLAF[tensorflow-s2s-False] __________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PassLAF(target_framework, mode, backend_compile):
        print("kornia.feature.PassLAF")
    
        if backend_compile:
            pytest.skip()
    
>       TranspiledPassLAF = ivy.transpile(kornia.feature.PassLAF, source="torch", target=target_framework)

kornia/test_feature4.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <class 'kornia.feature.orientation.PassLAF'>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def transpile(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import transpile as _transpile
    
>       return _transpile(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.PassLAF
_________________________________________________________________________ test_PatchAffineShapeEstimator[tensorflow-s2s-False] _________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_PatchAffineShapeEstimator(target_framework, mode, backend_compile):
        print("kornia.feature.PatchAffineShapeEstimator")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledPatchAffineShapeEstimator = ivy.transpile(kornia.feature.PatchAffineShapeEstimator, source="torch", target=target_framework)
    
        patch = torch.rand(1, 1, 19, 19)
        torch_out = kornia.feature.PatchAffineShapeEstimator()(patch)
    
        transpiled_patch = _nest_torch_tensor_to_new_framework(patch, target_framework)
>       transpiled_out = TranspiledPatchAffineShapeEstimator()(transpiled_patch)

kornia/test_feature4.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'tensorflow_PatchAffineShapeEstimator' object has no attribute 'eps'") raised in repr()] tensorflow_PatchAffineShapeEstimator object at 0x7f636d8277c0>, patch_size = 19
eps = 1e-10

    def __init__(self, patch_size=19, eps=1e-10):
        from ..filters.sobel import tensorflow_sobel
        from ..filters.kernels import tensorflow_get_gaussian_kernel2d
    
        self.super___init__(
            patch_size=patch_size,
            eps=eps,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.patch_size: typing.Any = patch_size
>       self.gradient: typing.Any = tensorflow_sobel.SpatialGradient("sobel", 1)
E       AttributeError: 'function' object has no attribute 'SpatialGradient'

Translated_Outputs/tensorflow_outputs/kornia/feature/affine_shape.py:53: AttributeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.PatchAffineShapeEstimator

Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling PatchAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
                                                                                                                                                    
Transpilation of PatchAffineShapeEstimator complete.
__________________________________________________________________________ test_LAFAffineShapeEstimator[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_LAFAffineShapeEstimator(target_framework, mode, backend_compile):
        print("kornia.feature.LAFAffineShapeEstimator")
    
        if backend_compile:
            pytest.skip()
    
        TranspiledLAFAffineShapeEstimator = ivy.transpile(kornia.feature.LAFAffineShapeEstimator, source="torch", target=target_framework)
    
        laf = torch.rand(1, 2, 2, 3)
        img = torch.rand(1, 1, 32, 32)
        torch_out = kornia.feature.LAFAffineShapeEstimator()(laf, img)
    
        transpiled_laf = _nest_torch_tensor_to_new_framework(laf, target_framework)
        transpiled_img = _nest_torch_tensor_to_new_framework(img, target_framework)
>       transpiled_out = TranspiledLAFAffineShapeEstimator()(transpiled_laf, transpiled_img)

kornia/test_feature4.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'tensorflow_LAFAffineShapeEstimator' object has no attribute 'affine_shape_detector'") raised in repr()] tensorflow_LAFAffineShapeEstimator object at 0x7f636dda0130>
patch_size = 32, affine_shape_detector = None, preserve_orientation = True

    def __init__(
        self, patch_size=32, affine_shape_detector=None, preserve_orientation=True
    ):
        self.super___init__(
            patch_size=patch_size,
            affine_shape_detector=affine_shape_detector,
            preserve_orientation=preserve_orientation,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.patch_size = patch_size
        self.affine_shape_detector = (
            affine_shape_detector
>           or tensorflow_PatchAffineShapeEstimator(self.patch_size)
        )

Translated_Outputs/tensorflow_outputs/kornia/feature/affine_shape.py:484: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'tensorflow_PatchAffineShapeEstimator' object has no attribute 'eps'") raised in repr()] tensorflow_PatchAffineShapeEstimator object at 0x7f6365e178b0>, patch_size = 32
eps = 1e-10

    def __init__(self, patch_size=19, eps=1e-10):
        from ..filters.sobel import tensorflow_sobel
        from ..filters.kernels import tensorflow_get_gaussian_kernel2d
    
        self.super___init__(
            patch_size=patch_size,
            eps=eps,
            v=getattr(self, "_v", None),
            buffers=getattr(self, "_buffers", None),
            module_dict=getattr(self, "_module_dict", None),
        )
        self.patch_size: typing.Any = patch_size
>       self.gradient: typing.Any = tensorflow_sobel.SpatialGradient("sobel", 1)
E       AttributeError: 'function' object has no attribute 'SpatialGradient'

Translated_Outputs/tensorflow_outputs/kornia/feature/affine_shape.py:53: AttributeError
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.feature.LAFAffineShapeEstimator

Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.. 
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time...
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time   
Transpiling LAFAffineShapeEstimator from torch to tensorflow. This could take a few minutes if you're transpiling this class for the first time.  
                                                                                                                                                  
Transpilation of LAFAffineShapeEstimator complete.
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/test_feature4.py::test_SIFTFeature[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have...
FAILED kornia/test_feature4.py::test_SIFTFeatureScaleSpace[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet conne...
FAILED kornia/test_feature4.py::test_GFTTAffNetHardNet[tensorflow-s2s-False] - KeyError: 'affnet'
FAILED kornia/test_feature4.py::test_KeyNetAffNetHardNet[tensorflow-s2s-False] - KeyError: 'orinet'
FAILED kornia/test_feature4.py::test_KeyNetHardNet[tensorflow-s2s-False] - KeyError: 'orinet'
FAILED kornia/test_feature4.py::test_GeometryAwareDescriptorMatcher[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ens...
FAILED kornia/test_feature4.py::test_LocalFeatureMatcher[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do ...
FAILED kornia/test_feature4.py::test_LightGlueMatcher[tensorflow-s2s-False] - NameError: name 'torch' is not defined
FAILED kornia/test_feature4.py::test_LightGlue[tensorflow-s2s-False] - NameError: name 'torch' is not defined
FAILED kornia/test_feature4.py::test_LoFTR[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IV...
FAILED kornia/test_feature4.py::test_PassLAF[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an ...
FAILED kornia/test_feature4.py::test_PatchAffineShapeEstimator[tensorflow-s2s-False] - AttributeError: 'function' object has no attribute 'SpatialGradient'
FAILED kornia/test_feature4.py::test_LAFAffineShapeEstimator[tensorflow-s2s-False] - AttributeError: 'function' object has no attribute 'SpatialGradient'
=============================================================================== 13 failed, 1 passed in 947.95s (0:15:47) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 19 items

kornia/geometry/test_camera.py FFFFFFFFFFF..FF....                                                                                                                                               [100%]

=============================================================================================== FAILURES ===============================================================================================
_____________________________________________________________________________ test_project_points_z1[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_project_points_z1(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.project_points_z1,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function project_points_z1 at 0x7f59949f40d0>, trace_args = (tensor([[0.4166, 0.9179, 0.7277],
        [0.5408, 0.9779, 0.6337]]),), trace_kwargs = {}
test_args = (tensor([[0.4346, 0.0212, 0.7699],
        [0.9405, 0.3134, 0.9477],
        [0.1458, 0.2892, 0.8587],
        [0.5949, 0.6484, 0.3506],
        [0.0678, 0.0699, 0.0420]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function project_points_z1 at 0x7f59949f40d0>, trace_args = (tensor([[0.4166, 0.9179, 0.7277],
        [0.5408, 0.9779, 0.6337]]),), trace_kwargs = {}
test_args = (tensor([[0.4346, 0.0212, 0.7699],
        [0.9405, 0.3134, 0.9477],
        [0.1458, 0.2892, 0.8587],
        [0.5949, 0.6484, 0.3506],
        [0.0678, 0.0699, 0.0420]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function project_points_z1 at 0x7f59949f40d0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.projection_z1.project_points_z1
____________________________________________________________________________ test_unproject_points_z1[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_unproject_points_z1(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2),
            torch.rand(1),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(2),
            torch.rand(1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.unproject_points_z1,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function unproject_points_z1 at 0x7f59949f4160>, trace_args = (tensor([0.9663, 0.9138]), tensor([0.5790])), trace_kwargs = {}, test_args = (tensor([0.5655, 0.2404]), tensor([0.2651]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function unproject_points_z1 at 0x7f59949f4160>, trace_args = (tensor([0.9663, 0.9138]), tensor([0.5790])), trace_kwargs = {}, test_args = (tensor([0.5655, 0.2404]), tensor([0.2651]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function unproject_points_z1 at 0x7f59949f4160>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.projection_z1.unproject_points_z1
___________________________________________________________________________ test_dx_project_points_z1[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_dx_project_points_z1(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.dx_project_points_z1,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dx_project_points_z1 at 0x7f59949f41f0>, trace_args = (tensor([[0.6394, 0.8070, 0.4734],
        [0.4727, 0.2282, 0.5211]]),), trace_kwargs = {}
test_args = (tensor([[0.9541, 0.1059, 0.9435],
        [0.6749, 0.0389, 0.7860],
        [0.7158, 0.0272, 0.5073],
        [0.2988, 0.7125, 0.9022],
        [0.4663, 0.3094, 0.5006]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dx_project_points_z1 at 0x7f59949f41f0>, trace_args = (tensor([[0.6394, 0.8070, 0.4734],
        [0.4727, 0.2282, 0.5211]]),), trace_kwargs = {}
test_args = (tensor([[0.9541, 0.1059, 0.9435],
        [0.6749, 0.0389, 0.7860],
        [0.7158, 0.0272, 0.5073],
        [0.2988, 0.7125, 0.9022],
        [0.4663, 0.3094, 0.5006]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function dx_project_points_z1 at 0x7f59949f41f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.projection_z1.dx_project_points_z1
________________________________________________________________________ test_project_points_orthographic[tensorflow-s2s-False] ________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_project_points_orthographic(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.project_points_orthographic,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function project_points_orthographic at 0x7f5995017e20>, trace_args = (tensor([[0.7142, 0.4471, 0.8779],
        [0.7925, 0.5170, 0.8725]]),), trace_kwargs = {}
test_args = (tensor([[0.8749, 0.9673, 0.4185],
        [0.2921, 0.6051, 0.1058],
        [0.2746, 0.1278, 0.9210],
        [0.5192, 0.2139, 0.1013],
        [0.7449, 0.2487, 0.8995]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function project_points_orthographic at 0x7f5995017e20>, trace_args = (tensor([[0.7142, 0.4471, 0.8779],
        [0.7925, 0.5170, 0.8725]]),), trace_kwargs = {}
test_args = (tensor([[0.8749, 0.9673, 0.4185],
        [0.2921, 0.6051, 0.1058],
        [0.2746, 0.1278, 0.9210],
        [0.5192, 0.2139, 0.1013],
        [0.7449, 0.2487, 0.8995]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function project_points_orthographic at 0x7f5995017e20>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.projection_orthographic.project_points_orthographic
_______________________________________________________________________ test_unproject_points_orthographic[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_unproject_points_orthographic(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 2),
            torch.rand(2, 1),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 2),
            torch.rand(5, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.unproject_points_orthographic,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function unproject_points_orthographic at 0x7f5995017eb0>, trace_args = (tensor([[0.8027, 0.4001],
        [0.6990, 0.9118]]), tensor([[0.8420],
        [0.6704]])), trace_kwargs = {}
test_args = (tensor([[0.4612, 0.8116],
        [0.3051, 0.4259],
        [0.2077, 0.2361],
        [0.3688, 0.6545],
        [0.7400, 0.2760]]), tensor([[0.6184],
        [0.7551],
        [0.3735],
        [0.5399],
        [0.2919]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function unproject_points_orthographic at 0x7f5995017eb0>, trace_args = (tensor([[0.8027, 0.4001],
        [0.6990, 0.9118]]), tensor([[0.8420],
        [0.6704]])), trace_kwargs = {}
test_args = (tensor([[0.4612, 0.8116],
        [0.3051, 0.4259],
        [0.2077, 0.2361],
        [0.3688, 0.6545],
        [0.7400, 0.2760]]), tensor([[0.6184],
        [0.7551],
        [0.3735],
        [0.5399],
        [0.2919]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function unproject_points_orthographic at 0x7f5995017eb0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.projection_orthographic.unproject_points_orthographic
______________________________________________________________________ test_dx_project_points_orthographic[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_dx_project_points_orthographic(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.dx_project_points_orthographic,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dx_project_points_orthographic at 0x7f5995017f40>, trace_args = (tensor([[0.4359, 0.2996, 0.4380],
        [0.8508, 0.7407, 0.1802]]),), trace_kwargs = {}
test_args = (tensor([[0.6154, 0.4349, 0.4321],
        [0.4704, 0.4973, 0.3768],
        [0.2824, 0.6458, 0.4570],
        [0.0386, 0.5769, 0.5277],
        [0.7097, 0.6019, 0.9090]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dx_project_points_orthographic at 0x7f5995017f40>, trace_args = (tensor([[0.4359, 0.2996, 0.4380],
        [0.8508, 0.7407, 0.1802]]),), trace_kwargs = {}
test_args = (tensor([[0.6154, 0.4349, 0.4321],
        [0.4704, 0.4973, 0.3768],
        [0.2824, 0.6458, 0.4570],
        [0.0386, 0.5769, 0.5277],
        [0.7097, 0.6019, 0.9090]]),)
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function dx_project_points_orthographic at 0x7f5995017f40>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.projection_orthographic.dx_project_points_orthographic
___________________________________________________________________________ test_distort_points_affine[tensorflow-s2s-False] ___________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_distort_points_affine(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 2),
            torch.rand(2, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 2),
            torch.rand(5, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.distort_points_affine,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function distort_points_affine at 0x7f5995015ab0>
trace_args = (tensor([[0.8705, 0.4534],
        [0.8365, 0.5546]]), tensor([[0.3150, 0.5687, 0.5940, 0.9225],
        [0.4447, 0.3172, 0.1119, 0.1576]])), trace_kwargs = {}
test_args = (tensor([[0.3639, 0.4837],
        [0.7211, 0.8624],
        [0.8651, 0.9121],
        [0.0592, 0.9032],
        [0.27...[0.1096, 0.6105, 0.5854, 0.4343],
        [0.4439, 0.3656, 0.7632, 0.6491],
        [0.1337, 0.0357, 0.9040, 0.9040]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function distort_points_affine at 0x7f5995015ab0>
trace_args = (tensor([[0.8705, 0.4534],
        [0.8365, 0.5546]]), tensor([[0.3150, 0.5687, 0.5940, 0.9225],
        [0.4447, 0.3172, 0.1119, 0.1576]])), trace_kwargs = {}
test_args = (tensor([[0.3639, 0.4837],
        [0.7211, 0.8624],
        [0.8651, 0.9121],
        [0.0592, 0.9032],
        [0.27...[0.1096, 0.6105, 0.5854, 0.4343],
        [0.4439, 0.3656, 0.7632, 0.6491],
        [0.1337, 0.0357, 0.9040, 0.9040]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function distort_points_affine at 0x7f5995015ab0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.distortion_affine.distort_points_affine
__________________________________________________________________________ test_undistort_points_affine[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_undistort_points_affine(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 2),
            torch.rand(2, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 2),
            torch.rand(5, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.undistort_points_affine,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function undistort_points_affine at 0x7f5995015b40>
trace_args = (tensor([[0.7486, 0.0922],
        [0.5504, 0.3454]]), tensor([[0.9172, 0.5840, 0.5088, 0.9855],
        [0.8457, 0.2585, 0.5143, 0.2131]])), trace_kwargs = {}
test_args = (tensor([[0.5309, 0.4537],
        [0.7230, 0.2652],
        [0.8601, 0.9659],
        [0.2308, 0.7766],
        [0.05...,
        [8.5514e-01, 2.6813e-02, 4.0806e-01, 1.8106e-01],
        [3.2996e-01, 5.5403e-01, 5.5568e-01, 5.6198e-01]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function undistort_points_affine at 0x7f5995015b40>
trace_args = (tensor([[0.7486, 0.0922],
        [0.5504, 0.3454]]), tensor([[0.9172, 0.5840, 0.5088, 0.9855],
        [0.8457, 0.2585, 0.5143, 0.2131]])), trace_kwargs = {}
test_args = (tensor([[0.5309, 0.4537],
        [0.7230, 0.2652],
        [0.8601, 0.9659],
        [0.2308, 0.7766],
        [0.05...,
        [8.5514e-01, 2.6813e-02, 4.0806e-01, 1.8106e-01],
        [3.2996e-01, 5.5403e-01, 5.5568e-01, 5.6198e-01]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function undistort_points_affine at 0x7f5995015b40>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.distortion_affine.undistort_points_affine
_________________________________________________________________________ test_dx_distort_points_affine[tensorflow-s2s-False] __________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_dx_distort_points_affine(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 2),
            torch.rand(2, 4),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 2),
            torch.rand(5, 4),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.dx_distort_points_affine,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dx_distort_points_affine at 0x7f5995015bd0>
trace_args = (tensor([[0.6260, 0.6860],
        [0.4703, 0.7744]]), tensor([[0.2468, 0.5768, 0.9024, 0.9857],
        [0.1120, 0.0075, 0.0061, 0.5573]])), trace_kwargs = {}
test_args = (tensor([[0.9516, 0.7339],
        [0.3739, 0.1187],
        [0.5547, 0.5870],
        [0.1725, 0.8904],
        [0.73...[0.9142, 0.4387, 0.5914, 0.0921],
        [0.5582, 0.3959, 0.0473, 0.6453],
        [0.0547, 0.4846, 0.7356, 0.8692]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function dx_distort_points_affine at 0x7f5995015bd0>
trace_args = (tensor([[0.6260, 0.6860],
        [0.4703, 0.7744]]), tensor([[0.2468, 0.5768, 0.9024, 0.9857],
        [0.1120, 0.0075, 0.0061, 0.5573]])), trace_kwargs = {}
test_args = (tensor([[0.9516, 0.7339],
        [0.3739, 0.1187],
        [0.5547, 0.5870],
        [0.1725, 0.8904],
        [0.73...[0.9142, 0.4387, 0.5914, 0.0921],
        [0.5582, 0.3959, 0.0473, 0.6453],
        [0.0547, 0.4846, 0.7356, 0.8692]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function dx_distort_points_affine at 0x7f5995015bd0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.distortion_affine.dx_distort_points_affine
_______________________________________________________________________ test_distort_points_kannala_brandt[tensorflow-s2s-False] _______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_distort_points_kannala_brandt(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 2),
            torch.rand(2, 8),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 2),
            torch.rand(5, 8),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.distort_points_kannala_brandt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function distort_points_kannala_brandt at 0x7f5995015ea0>
trace_args = (tensor([[0.1405, 0.6816],
        [0.9469, 0.1861]]), tensor([[0.9776, 0.1625, 0.2605, 0.1510, 0.4498, 0.1694, 0.6169, 0.0976],
        [0.7128, 0.9331, 0.1747, 0.2493, 0.3561, 0.6717, 0.7947, 0.7584]]))
trace_kwargs = {}
test_args = (tensor([[0.3094, 0.3869],
        [0.9789, 0.6164],
        [0.9066, 0.7055],
        [0.3279, 0.2124],
        [0.82...0, 0.6994, 0.0224, 0.2120, 0.4289, 0.3888],
        [0.6899, 0.3541, 0.5707, 0.7520, 0.2435, 0.2645, 0.9456, 0.7184]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function distort_points_kannala_brandt at 0x7f5995015ea0>
trace_args = (tensor([[0.1405, 0.6816],
        [0.9469, 0.1861]]), tensor([[0.9776, 0.1625, 0.2605, 0.1510, 0.4498, 0.1694, 0.6169, 0.0976],
        [0.7128, 0.9331, 0.1747, 0.2493, 0.3561, 0.6717, 0.7947, 0.7584]]))
trace_kwargs = {}
test_args = (tensor([[0.3094, 0.3869],
        [0.9789, 0.6164],
        [0.9066, 0.7055],
        [0.3279, 0.2124],
        [0.82...0, 0.6994, 0.0224, 0.2120, 0.4289, 0.3888],
        [0.6899, 0.3541, 0.5707, 0.7520, 0.2435, 0.2645, 0.9456, 0.7184]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function distort_points_kannala_brandt at 0x7f5995015ea0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.distortion_kannala_brandt.distort_points_kannala_brandt
______________________________________________________________________ test_undistort_points_kannala_brandt[tensorflow-s2s-False] ______________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_undistort_points_kannala_brandt(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 2),
            torch.rand(2, 8),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 2),
            torch.rand(5, 8),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.undistort_points_kannala_brandt,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function undistort_points_kannala_brandt at 0x7f5995015f30>
trace_args = (tensor([[0.9301, 0.2566],
        [0.9182, 0.7689]]), tensor([[0.4936, 0.6102, 0.4420, 0.1329, 0.4911, 0.7134, 0.3870, 0.3003],
        [0.8677, 0.0210, 0.0746, 0.9809, 0.6306, 0.7125, 0.2503, 0.2253]]))
trace_kwargs = {}
test_args = (tensor([[0.3304, 0.7875],
        [0.9403, 0.0996],
        [0.5620, 0.1032],
        [0.8721, 0.4477],
        [0.36...0, 0.1263, 0.5212, 0.5587, 0.3092, 0.8216],
        [0.0922, 0.7308, 0.5374, 0.7120, 0.6705, 0.9998, 0.0743, 0.8484]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function undistort_points_kannala_brandt at 0x7f5995015f30>
trace_args = (tensor([[0.9301, 0.2566],
        [0.9182, 0.7689]]), tensor([[0.4936, 0.6102, 0.4420, 0.1329, 0.4911, 0.7134, 0.3870, 0.3003],
        [0.8677, 0.0210, 0.0746, 0.9809, 0.6306, 0.7125, 0.2503, 0.2253]]))
trace_kwargs = {}
test_args = (tensor([[0.3304, 0.7875],
        [0.9403, 0.0996],
        [0.5620, 0.1032],
        [0.8721, 0.4477],
        [0.36...0, 0.1263, 0.5212, 0.5587, 0.3092, 0.8216],
        [0.0922, 0.7308, 0.5374, 0.7120, 0.6705, 0.9998, 0.0743, 0.8484]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function undistort_points_kannala_brandt at 0x7f5995015f30>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.distortion_kannala_brandt.undistort_points_kannala_brandt
_________________________________________________________________________________ test_pixel2cam[tensorflow-s2s-False] _________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_pixel2cam(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 1, 3, 3),
            torch.rand(2, 4, 4),
            torch.rand(2, 3, 3, 3),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 3, 3),
            torch.rand(5, 4, 4),
            torch.rand(5, 3, 3, 3),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.pinhole.pixel2cam,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function pixel2cam at 0x7f5995017d00>
trace_args = (tensor([[[[0.2155, 0.3662, 0.4596],
          [0.5156, 0.1914, 0.4728],
          [0.9149, 0.1554, 0.5049]]],


     ...507]],

         [[0.6727, 0.7029, 0.6213],
          [0.7534, 0.5869, 0.4726],
          [0.4247, 0.8848, 0.1091]]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.0095, 0.5392, 0.5130],
          [0.2039, 0.7863, 0.3422],
          [0.8333, 0.8389, 0.9203]]],


     ...569]],

         [[0.2087, 0.4372, 0.5293],
          [0.2551, 0.9969, 0.6435],
          [0.0736, 0.3903, 0.3868]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function pixel2cam at 0x7f5995017d00>
trace_args = (tensor([[[[0.2155, 0.3662, 0.4596],
          [0.5156, 0.1914, 0.4728],
          [0.9149, 0.1554, 0.5049]]],


     ...507]],

         [[0.6727, 0.7029, 0.6213],
          [0.7534, 0.5869, 0.4726],
          [0.4247, 0.8848, 0.1091]]]]))
trace_kwargs = {}
test_args = (tensor([[[[0.0095, 0.5392, 0.5130],
          [0.2039, 0.7863, 0.3422],
          [0.8333, 0.8389, 0.9203]]],


     ...569]],

         [[0.2087, 0.4372, 0.5293],
          [0.2551, 0.9969, 0.6435],
          [0.0736, 0.3903, 0.3868]]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function pixel2cam at 0x7f5995017d00>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.pinhole.pixel2cam
______________________________________________________________________________ test_project_points[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_project_points(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(2, 3),
            torch.eye(3)[None].repeat(2, 1, 1),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 3),
            torch.eye(3)[None].repeat(5, 1, 1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.camera.perspective.project_points,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_camera.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function project_points at 0x7f5995016200>
trace_args = (tensor([[0.8535, 0.5337, 0.7780],
        [0.5484, 0.1164, 0.0469]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
trace_kwargs = {}
test_args = (tensor([[0.0477, 0.0999, 0.8260],
        [0.3832, 0.4122, 0.2672],
        [0.0951, 0.0496, 0.5714],
        [0.6956...         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function project_points at 0x7f5995016200>
trace_args = (tensor([[0.8535, 0.5337, 0.7780],
        [0.5484, 0.1164, 0.0469]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
trace_kwargs = {}
test_args = (tensor([[0.0477, 0.0999, 0.8260],
        [0.3832, 0.4122, 0.2672],
        [0.0951, 0.0496, 0.5714],
        [0.6956...         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function project_points at 0x7f5995016200>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.camera.perspective.project_points
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_camera.py::test_project_points_z1[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/geometry/test_camera.py::test_unproject_points_z1[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/geometry/test_camera.py::test_dx_project_points_z1[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure...
FAILED kornia/geometry/test_camera.py::test_project_points_orthographic[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key,...
FAILED kornia/geometry/test_camera.py::test_unproject_points_orthographic[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ke...
FAILED kornia/geometry/test_camera.py::test_dx_project_points_orthographic[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api k...
FAILED kornia/geometry/test_camera.py::test_distort_points_affine[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensur...
FAILED kornia/geometry/test_camera.py::test_undistort_points_affine[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ens...
FAILED kornia/geometry/test_camera.py::test_dx_distort_points_affine[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable inte...
FAILED kornia/geometry/test_camera.py::test_distort_points_kannala_brandt[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ke...
FAILED kornia/geometry/test_camera.py::test_undistort_points_kannala_brandt[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api ...
FAILED kornia/geometry/test_camera.py::test_pixel2cam[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not...
FAILED kornia/geometry/test_camera.py::test_project_points[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you d...
=============================================================================== 13 failed, 6 passed in 152.76s (0:02:32) ===============================================================================

========================================================================================= test session starts ==========================================================================================
platform linux -- Python 3.10.0, pytest-8.3.3, pluggy-1.5.0
rootdir: /ivy/ivy-integration-tests
plugins: anyio-4.4.0, hypothesis-6.98.10, metadata-3.1.1, json-report-1.5.0
collected 6 items

kornia/geometry/test_depth.py FFFFF.                                                                                                                                                             [100%]

=============================================================================================== FAILURES ===============================================================================================
___________________________________________________________________________ test_depth_from_disparity[tensorflow-s2s-False] ____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_depth_from_disparity(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(4, 1, 4, 4),
            torch.rand(1),
            torch.rand(1),
        )
        trace_kwargs = {}
        test_args = (
            torch.rand(5, 1, 5, 5),
            torch.rand(1),
            torch.rand(1),
        )
        test_kwargs = {}
>       _test_function(
            kornia.geometry.depth.depth_from_disparity,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_depth.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function depth_from_disparity at 0x7fbb8d491b40>
trace_args = (tensor([[[[0.6599, 0.7281, 0.1396, 0.1863],
          [0.8845, 0.5414, 0.0595, 0.7567],
          [0.1076, 0.2481, 0....  [0.8040, 0.5100, 0.8093, 0.6465],
          [0.4609, 0.2738, 0.6122, 0.1634]]]]), tensor([0.3614]), tensor([0.1128]))
trace_kwargs = {}
test_args = (tensor([[[[0.0457, 0.4596, 0.4695, 0.0721, 0.2517],
          [0.9771, 0.9066, 0.9073, 0.0214, 0.2599],
          [0....5, 0.9259, 0.9658, 0.9619],
          [0.1996, 0.7188, 0.6988, 0.8864, 0.8243]]]]), tensor([0.3203]), tensor([0.8030]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function depth_from_disparity at 0x7fbb8d491b40>
trace_args = (tensor([[[[0.6599, 0.7281, 0.1396, 0.1863],
          [0.8845, 0.5414, 0.0595, 0.7567],
          [0.1076, 0.2481, 0....  [0.8040, 0.5100, 0.8093, 0.6465],
          [0.4609, 0.2738, 0.6122, 0.1634]]]]), tensor([0.3614]), tensor([0.1128]))
trace_kwargs = {}
test_args = (tensor([[[[0.0457, 0.4596, 0.4695, 0.0721, 0.2517],
          [0.9771, 0.9066, 0.9073, 0.0214, 0.2599],
          [0....5, 0.9259, 0.9658, 0.9619],
          [0.1996, 0.7188, 0.6988, 0.8864, 0.8243]]]]), tensor([0.3203]), tensor([0.8030]))
test_kwargs = {}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function depth_from_disparity at 0x7fbb8d491b40>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.depth.depth_from_disparity
________________________________________________________________________________ test_depth_to_3d[tensorflow-s2s-False] ________________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_depth_to_3d(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 4, 4),
            torch.rand(1, 3, 3),
        )
        trace_kwargs = {'normalize_points': False}
        test_args = (
            torch.rand(5, 1, 5, 5),
            torch.rand(5, 3, 3),
        )
        test_kwargs = {'normalize_points': False}
>       _test_function(
            kornia.geometry.depth.depth_to_3d,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_depth.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function depth_to_3d at 0x7fbb8d4915a0>
trace_args = (tensor([[[[0.0720, 0.9450, 0.3783, 0.4314],
          [0.8143, 0.4782, 0.1343, 0.9415],
          [0.4808, 0.5624, 0.....4760]]]]), tensor([[[0.0226, 0.3007, 0.4245],
         [0.6360, 0.6862, 0.9909],
         [0.0660, 0.3570, 0.9793]]]))
trace_kwargs = {'normalize_points': False}
test_args = (tensor([[[[0.5982, 0.4080, 0.5201, 0.9649, 0.9768],
          [0.7455, 0.3142, 0.4183, 0.8931, 0.7665],
          [0.... 0.8233]],

        [[0.7610, 0.9841, 0.7514],
         [0.4872, 0.5435, 0.3088],
         [0.7813, 0.5072, 0.2085]]]))
test_kwargs = {'normalize_points': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function depth_to_3d at 0x7fbb8d4915a0>
trace_args = (tensor([[[[0.0720, 0.9450, 0.3783, 0.4314],
          [0.8143, 0.4782, 0.1343, 0.9415],
          [0.4808, 0.5624, 0.....4760]]]]), tensor([[[0.0226, 0.3007, 0.4245],
         [0.6360, 0.6862, 0.9909],
         [0.0660, 0.3570, 0.9793]]]))
trace_kwargs = {'normalize_points': False}
test_args = (tensor([[[[0.5982, 0.4080, 0.5201, 0.9649, 0.9768],
          [0.7455, 0.3142, 0.4183, 0.8931, 0.7665],
          [0.... 0.8233]],

        [[0.7610, 0.9841, 0.7514],
         [0.4872, 0.5435, 0.3088],
         [0.7813, 0.5072, 0.2085]]]))
test_kwargs = {'normalize_points': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function depth_to_3d at 0x7fbb8d4915a0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.depth.depth_to_3d
______________________________________________________________________________ test_depth_to_3d_v2[tensorflow-s2s-False] _______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_depth_to_3d_v2(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(4, 4),
            torch.eye(3),
        )
        trace_kwargs = {'normalize_points': False}
        test_args = (
            torch.rand(5, 5),
            torch.eye(3),
        )
        test_kwargs = {'normalize_points': False}
>       _test_function(
            kornia.geometry.depth.depth_to_3d_v2,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_depth.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function depth_to_3d_v2 at 0x7fbb8d4913f0>
trace_args = (tensor([[0.1897, 0.3627, 0.2061, 0.7722],
        [0.6264, 0.2665, 0.0775, 0.6081],
        [0.2927, 0.0292, 0.0763, 0.0496],
        [0.1557, 0.0750, 0.0587, 0.5137]]), tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
trace_kwargs = {'normalize_points': False}
test_args = (tensor([[0.4847, 0.6549, 0.7246, 0.0489, 0.1952],
        [0.7301, 0.8001, 0.2261, 0.2643, 0.0256],
        [0.7712, ...        [0.3420, 0.1748, 0.2140, 0.0959, 0.5188]]), tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
test_kwargs = {'normalize_points': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function depth_to_3d_v2 at 0x7fbb8d4913f0>
trace_args = (tensor([[0.1897, 0.3627, 0.2061, 0.7722],
        [0.6264, 0.2665, 0.0775, 0.6081],
        [0.2927, 0.0292, 0.0763, 0.0496],
        [0.1557, 0.0750, 0.0587, 0.5137]]), tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
trace_kwargs = {'normalize_points': False}
test_args = (tensor([[0.4847, 0.6549, 0.7246, 0.0489, 0.1952],
        [0.7301, 0.8001, 0.2261, 0.2643, 0.0256],
        [0.7712, ...        [0.3420, 0.1748, 0.2140, 0.0959, 0.5188]]), tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
test_kwargs = {'normalize_points': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function depth_to_3d_v2 at 0x7fbb8d4913f0>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.depth.depth_to_3d_v2
____________________________________________________________________________ test_unproject_meshgrid[tensorflow-s2s-False] _____________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_unproject_meshgrid(target_framework, mode, backend_compile):
        trace_args = (
            4,
            4,
            torch.eye(3),
        )
        trace_kwargs = {'normalize_points': False, 'device': 'cpu', 'dtype': torch.float32}
        test_args = (
            5,
            5,
            torch.eye(3),
        )
        test_kwargs = {'normalize_points': False, 'device': 'cpu', 'dtype': torch.float32}
>       _test_function(
            kornia.geometry.depth.unproject_meshgrid,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_depth.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function unproject_meshgrid at 0x7fbb8d491360>, trace_args = (4, 4, tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
trace_kwargs = {'device': 'cpu', 'dtype': torch.float32, 'normalize_points': False}, test_args = (5, 5, tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
test_kwargs = {'device': 'cpu', 'dtype': torch.float32, 'normalize_points': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function unproject_meshgrid at 0x7fbb8d491360>, trace_args = (4, 4, tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
trace_kwargs = {'device': 'cpu', 'dtype': torch.float32, 'normalize_points': False}, test_args = (5, 5, tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
test_kwargs = {'device': 'cpu', 'dtype': torch.float32, 'normalize_points': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function unproject_meshgrid at 0x7fbb8d491360>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do not have an IVY_KEY environment variable set, and have no ivy-key.pem file in your working directory. If your api key should be valid, please try again, or reach out to enterprise@ivy.dev for support.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.depth.unproject_meshgrid
_____________________________________________________________________________ test_depth_to_normals[tensorflow-s2s-False] ______________________________________________________________________________

target_framework = 'tensorflow', mode = 's2s', backend_compile = False

    def test_depth_to_normals(target_framework, mode, backend_compile):
        trace_args = (
            torch.rand(1, 1, 4, 4),
            torch.eye(3)[None],
        )
        trace_kwargs = {'normalize_points': False}
        test_args = (
            torch.rand(1, 1, 5, 5),
            torch.eye(3)[None],
        )
        test_kwargs = {'normalize_points': False}
>       _test_function(
            kornia.geometry.depth.depth_to_normals,
            trace_args,
            trace_kwargs,
            test_args,
            test_kwargs,
            target_framework,
            backend_compile,
            tolerance=1e-3,
            mode=mode,
        )

kornia/geometry/test_depth.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function depth_to_normals at 0x7fbb8d491480>
trace_args = (tensor([[[[0.8549, 0.0758, 0.2865, 0.9981],
          [0.2422, 0.8581, 0.5051, 0.1307],
          [0.2109, 0.0057, 0....          [0.9000, 0.5966, 0.8996, 0.7886]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
trace_kwargs = {'normalize_points': False}
test_args = (tensor([[[[0.8374, 0.2815, 0.8087, 0.2773, 0.5998],
          [0.7922, 0.5562, 0.0599, 0.4714, 0.7032],
          [0....  [0.4033, 0.1134, 0.4645, 0.2943, 0.2057]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
test_kwargs = {'normalize_points': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, mode = 's2s', skip = False, deterministic = True

    def _test_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        mode="transpile",
        skip=False,
        deterministic=True,
    ):
        # print out the full function module/name, so it will appear in the test_report.json
        print(f"{fn.__module__}.{fn.__name__}")
    
        if skip and mode != "s2s":
            # any skipped due to DCF issues should still work with ivy.source_to_source
            pytest.skip()
    
        if mode == "s2s":
>           _test_source_to_source_function(
                fn,
                trace_args,
                trace_kwargs,
                test_args,
                test_kwargs,
                target,
                backend_compile,
                tolerance=tolerance,
                deterministic=deterministic,

helpers.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function depth_to_normals at 0x7fbb8d491480>
trace_args = (tensor([[[[0.8549, 0.0758, 0.2865, 0.9981],
          [0.2422, 0.8581, 0.5051, 0.1307],
          [0.2109, 0.0057, 0....          [0.9000, 0.5966, 0.8996, 0.7886]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
trace_kwargs = {'normalize_points': False}
test_args = (tensor([[[[0.8374, 0.2815, 0.8087, 0.2773, 0.5998],
          [0.7922, 0.5562, 0.0599, 0.4714, 0.7032],
          [0....  [0.4033, 0.1134, 0.4645, 0.2943, 0.2057]]]]), tensor([[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]))
test_kwargs = {'normalize_points': False}, target = 'tensorflow', backend_compile = False, tolerance = 0.001, deterministic = True

    def _test_source_to_source_function(
        fn,
        trace_args,
        trace_kwargs,
        test_args,
        test_kwargs,
        target,
        backend_compile,
        tolerance=1e-3,
        deterministic=True,
    ):
        if backend_compile and target == "numpy":
            pytest.skip()
    
>       translated_fn = ivy.source_to_source(fn, source="torch", target=target)

helpers.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

object = <function depth_to_normals at 0x7fbb8d491480>, source = 'torch', target = 'tensorflow', reuse_existing = True

    def source_to_source(
        object,
        source: str = "torch",
        target: str = "tensorflow",
        reuse_existing: bool = True,
    ):
        """Converts a given object (class/function) from one framework to another.
    
        This function performs source-to-source translation of a given object from the source framework
        to the target framework.
    
        The object can be translated between two frameworks or between the Ivy IR as well
        e.g. (source="torch_frontend", target="ivy") or (source="torch_frontend", target="tensorflow") etc.
    
        Args:
            object: The object (class/function) to be translated.
            source (str, optional): The source framework. Defaults to 'torch'.
            target (str, optional): The target framework. Defaults to 'tensorflow'.
            reuse_existing (bool, optional): If True, the function will check if `object`
                                             already exists in the translated directory and reuse it.
                                             If False, it will re-translate `object`,
                                             even if it already exists in the directory, and overwrite
                                             the old implementation. Defaults to 'True'.
    
        Returns:
            The translated object."""
    
        from ._compiler import source_to_source as _source_to_source
    
>       return _source_to_source(
            object=object,
            source=source,
            target=target,
            reuse_existing=reuse_existing,
        )

../ivy/ivy/compiler/compiler.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

IXC.pyx:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet connection.

IXC.pyx:240: IvyException
----------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------
kornia.geometry.depth.depth_to_normals
--------------------------------------------------------------------------------------------- JSON report ----------------------------------------------------------------------------------------------
report saved to: test_report.json
======================================================================================= short test summary info ========================================================================================
FAILED kornia/geometry/test_depth.py::test_depth_from_disparity[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure ...
FAILED kornia/geometry/test_depth.py::test_depth_to_3d[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do no...
FAILED kornia/geometry/test_depth.py::test_depth_to_3d_v2[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure you do...
FAILED kornia/geometry/test_depth.py::test_unproject_meshgrid[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to validate api key. If you did not mean to use an api key, ensure yo...
FAILED kornia/geometry/test_depth.py::test_depth_to_normals[tensorflow-s2s-False] - ivy.utils.exceptions.IvyException: Unable to connect to ivy server. Please ensure you have a stable internet conn...
=============================================================================== 5 failed, 1 passed in 150.17s (0:02:30) ================================================================================

